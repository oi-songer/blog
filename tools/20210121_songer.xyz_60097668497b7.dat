```01postpublish011105ee7f7748027829b3695e8ad5ff6fa94{"cid":2,"title":15,"slug":2,"created":10,"modified":10,"text":4361,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}46约瑟夫问题4615090206401533781353<!--markdown-->## 线段树

> 用线段树历经千辛万苦终于做出来了，(;´༎ຶД༎ຶ )，写的似乎过于复杂了，就当是练习代码能力呢吧_(:з)∠)_

<!--more-->

题目来源：[_Code\[VS\]_](http://codevs.cn/problem/1282/)

题目是经典的约瑟夫问题，但是数据比原题大了许多，若直接模拟的话一定会超时，所以我们需要用其他方法优化。

我们知道，模拟的时间复杂度为$ O(nm) $,第一个`n`为`n`次游戏，没有优化的空间，所以我们要从`m`下手。`m`应为从当前结点向右找到第`m`个结点，对于每个结点我们都需判断其是否被取过，所以较慢。所以我们可以记录一下某个区间内还存在多少个结点，因为游戏的过程中还要更改结点，所以用线段树再合适不过了。

于是我们建立一棵树，将其分为以下几个模块：
```c++
struct SegmentTree{
	int a[MAXN];		//记录当前结点代表的数(若非叶节点则为0)
    int num[MAXN];		//记录当前结点下有几个数

	void Build();	//建树
	void Del();		//删除某一结点
	void Update();	//一次游戏过程
	void Main();	//主程序的运行
};
```

其中，`Build()`,`Del()`与`Main()`都较易实现，唯一需要慎重考虑的即为`Update()`函数。

以下，我们对`Upate()`所需实现的功能从普遍到特殊进行简单的分析(设我们剩余需跳过的长度为`last`):

1. 用`Update(i,m)`表示从`i`开始走`m`步(不包括`i`).
2. (刚进入`Update(i,m)`时)当前为一个普通的叶结点时，我们需要向父节点搜素，搜至当前 结点`i`使得`num[i]`为小于`m`的最大值.
3. 当前结点已搜至跟结点时，我们只需执行`Update(0，last%num[1])`,等价于已经多次跑遍整个环。
4. 当前结点不为叶结点时，若右兄弟存在，则跳至右兄弟，否则跳至父节点的右兄弟，以此类推.
5. 若当前结点及其父节点等不存在右兄弟(即它们一直都是右子树),则`Upate(0,last)`,即结束此圈。

```C++
#include <cstdio>
#include <algorithm>

using namespace std;

struct SegmentTree
{
	int a[5000000];
	int num[5000000];				//记录当前结点

	void Build(int i,int n,int l)			//建树
	{
		num[i] = n;
		if (n==1)	
		{
			a[i] = l;
			return;
		}

		a[i] = 0;

		Build(i*2,n/2,l);
		Build(i*2+1,(n+1)/2,l+n/2);
	}

	bool Check(int i)
	{
		int x = i;
		while (x%2==1 && x!=1)
			x /= 2;
		return x==1?true:false;
	}	

	void Del(int x)					//删除当前结点
	{
		for (int i = x; i>=1; i/=2)
			num[i] --;
	}

	int Update(int x,int m)			//继续报数 
	{
		int last = m;
		int i;

		if (x==0)
			for (x=1; !a[x]; x*=2);						//x为0时，先向左下搜到子叶

		//只有当1.当前节点不为1；2.当前结点为左子树；3.当前结点为右子树且其左兄弟的Num为0 时可以向上搜素
		for (i=x; num[i/2]<=m && i!=1 &&(i%2==0 || num[i]==num[i/2]); i/=2);		//向上找到能跳过的最多节点的区间或找到根节点

		//printf("\n!%d %d\n",i,m);

		while (1)				//如果没有搜至子叶
		{
			//printf("--%d %d %d\n",i,num[i],last);

			if (num[i]>last)
				i = i*2;
			else if (num[i]==last){		//如果正好相等，则直接找到当前区间的最后一个数
				//printf("[1*]%d %d \n",i,last);
				while (!a[i])
					i = num[i*2+1]?i*2+1:i*2;			//找到存在的最后面的子叶
				return i;
			}else{
				last -= num[i];			//跳过当前区间
				//printf("[2*]%d %d \n",i,last);
				if (Check(i))		return Update(0,last);						//如果当前结点及其父节点不存在右兄弟
				if (i%2==0)	i++;					//跳至右兄弟
				else i = i/2 + 1;						//或跳至父节点的右兄弟 
			}
		}

		return i;
	}

	void Main(int n,int m)			//主函数
	{
		Build(1,n,1);
	//	int x = Build(1,n,1,m);		//获取第一个要删除的数
	//	Del(x);
	//	printf("%d ",a[x]);
/*
		for (int i =1 ; i<=3*n; i++)
			printf("%d ",a[i]);
		printf("\n");

		for (int i =1 ; i<=3*n; i++)
			printf("%d ",num[i]);
		printf("\n");
*/
		int x = 0;
		for (int i =1; i<=n; i++)			//循环删除剩下的数
		{
			x = Update(x,m);
			Del(x);
			printf("%d ",a[x]);
		}
	}
}Tree;

int main()
{
	int n,m;
	scanf("%d%d",&n,&m);

	Tree.Main(n,m);

}

```01postpublish011105ee7f7748027829b3695e8ad5ff6fa94{"cid":1,"title":5,"slug":10,"created":10,"modified":10,"text":175,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}2Aboutstart-page15040898401587549646<!--markdown-->HIT@wh的ACM退役选手，好求知，不求甚解。
主用C++，其它语言也略有涉猎。
喜欢钻研奇技淫巧，对函数式编程充满兴趣。11pagepublish01110765eb8a8b8e1761c0568bb6ce189ffec{"cid":1,"title":29,"slug":1,"created":10,"modified":10,"text":6304,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}3centos 7服务器初始设置315040912201517567471<!--markdown-->> 第一次研究服务器，期间走了不少弯路，在我把整个服务器搞得一团糟了之后，我终于决定重装系统了。在这里记录一下cent os 7装系统后常用的命令与更改。


<!--more-->

> <!-- index-menu -->


## 更新源
[参考网站](http://www.linuxidc.com/Linux/2015-03/114690.htm)

注意，因为一般源安装后都是disable的，所以我们需要到$/etc/yum.repos.d/$中找到该源，并将想要启用的源改为$enable=1$。
##### RHEL官方扩展源
```bash
yum localinstall http://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-5.noarch.rpm -y
```
##### remi源(php相关的扩展库)
```bash
yum localinstall http://rpms.famillecollet.com/enterprise/remi-release-7.rpm
```
##### puias源(科学计算等)(选择安装)
因为一般只用其科学计算模块，所以我们手动添加。在$/etc/yum.repo.d/$建立文件，内容为：

```
[PUIAS_computational]
name=PUIAS computational Base $releasever - $basearch
mirrorlist=http://puias.math.ias.edu/data/puias/computational/$releasever/$basearch/mirrorlist
#baseurl=http://puias.math.ias.edu/data/puias/computational/$releasever/$basearch
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-puias 
```

然后因为我们不是用rpm安装的，所以我们需要import一下GPG KEY:
```bash
rpm --import http://puias.princeton.edu/data/puias/7/x86_64/os/RPM-GPG-KEY-puias 
```
## 常用软件的下载
```bash
#yum常用的命令
update		#升级
install		#安装
remove		#删除
#rpm常用的命令
-i			#安装
-u			#升级
-e			#卸载
```
* vim--这个不多说

* axel--很好用的多线程下载工具

* w3m--嗯，如果你想用bash浏览网页的话。。。

* top--很好用的后台监测软件

* wget--下载软件

* php--建站必须。。。

* nginx--同样建站必须

* sl--(大雾

## 关于Firewalld
[参考网站](http://blog.csdn.net/xlgen157387/article/details/52672988)

因为CentOS的防火墙对端口的管控较严，所以当我们需要用到一个端口是我们需要手动将其打开，例如下面的ss搭建时需要用到的端口，常用命令如下：
```bash
#打开666端口端口的tcp(--permanent代表永久)
firewall-cmd --permanent --add-port=666/tcp

#打开666端口端口的udp
firewall-cmd --permanent --add-port=666/udp

#另外，firewalld有zone的概念，可以将具体的端口制定到具体的zone中:
#指定的zone为public
--zone=public

#重启、关闭、开启firewalld.service服务
service firewalld restart 
service firewalld start 
service firewalld stop

#查看firewall服务状态
systemctl status firewall

#查看firewall的状态
firewall-cmd --state

#查看防火墙规则
firewall-cmd --list-all 
```
同时，我们可以通过的更改$/etc/firewalld/zones/public.xml$方法打开端口,不再详述。
* 注意：一定要想着打开ssh的端口(好几次都自己打开firewalld然后把自己ban出来。。。。。)

## SS的搭建
因为这里要下载python版的shadowsocks,故需下下载python,所有操作如下：
```json
(1)yum install python
(2)wget https://bootstrap.pypa.io/get-pip.py
(3)python get-pip.py
(4)pip install shadowsocks	#下载ss
(5)pip install M2Crypto		#加密的依赖包
(6)新建配置文件/etc/shadowsocks.json,在里面写入
{
    "server":"my_server_ip",
    "server_port": number,
    "local_address": "127.0.0.1",
    "local_port":1080,
    "password":"my_password",
    "timeout":300,
    "method":"aes-256-cfb"
}
(7)使用ssserver -c /etc/shadowsocks.json -d start打开ss服务
```

> 设置时要记得打开firewalld的相应接口

> 若要令其开机启动，需要将7中的命令加入/etc/rc.local中

##### 多用户设置
将/etc/shadowsocks.json改为如下格式即可(记得在防火墙中打开端口):
```json
{
    "server":"your_server_ip",
    "local_address": "127.0.0.1",
    "local_port":1080,
    "port_password":{   #端口号与密码
         "8989":"password0",   # 左边是端口号，右边是密码
         "9001":"password1",
         "9002":"password2",
         "9003":"password3",
         "9004":"password4"
    },
    "timeout":300,
    "method":"aes-256-cfb",
    "fast_open": false
}
```

##### 安装锐速
参考网站:[内核更换及锐速安装](http://www.vpsdx.com/2812.html)
锐速是一款强大的服务器加速软件。由于这个软件只针对特定的Linux内核才能使用，所以需要修改服务器系统的内核。 

对于centos7，内核更换为： 3.10.0-229.1.2.el7.x86_64，这里是一个一间更换的bash:
```bash
wget --no-check-certificate https://blog.asuhu.com/sh/ruisu.sh
bash ruisu.sh
```
然后再安装锐速：
```bash
wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/serverspeeder/master/serverspeeder-all.sh && bash serverspeeder-all.sh
```
启动锐速：
```bash
service serverSpeeder start
```

## Blog的搭建
[LNMP安装参考](https://lnmp.org/install.html)

[typecho安装参考](http://qmiss.cn/archives/199)

[typecho官网](http://typecho.org/)

来来回回搭建了许多遍，又查询了许多次，终于决定用LNMP+[typecho](http://typecho.org/)来搭建blog。以下为步骤：

1.首先我们需要搭建LNMP环境，为方便起见我们使用一键安装包：

```bash
wget -c http://soft.vpser.net/lnmp/lnmp1.4.tar.gz && tar zxf lnmp1.4.tar.gz && cd lnmp1.4 && ./install.sh lnmp
```

2.下载typecho并解压
```bash
wget https://github.com/typecho/typecho/releases/download/v1.0-14.10.10-release/1.0.14.10.10.-release.tar.gz
tar -xzf 1.0.14.10.10.-release.tar.gz 
```
3.将解压出的build文件夹中的文件移至网站目录下

4.在开始前一定要提前建好mysql库，否则安装时会出现错误：
```bash
mysql -u root -p
create database typecho
```

5.进入网站主页开始安装

6.安装后我们会发现除了主页外全部404.这是pathinfo的原因,我们只需更改nginx.conf中的一项include enable-php.conf为include enalbe-php-pathinfo.conf就可以了。

7.结束了，享受你的网站吧！

> 安装后需要注意打开53端口，否则可能外网无法访问。01postpublish01110ba89264c62792f35295e21cfd3b2c69c{"cid":1,"title":12,"slug":1,"created":10,"modified":10,"text":1885,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}4树状数组415040950001508374267<!--markdown-->>树状数组也是好久之前学的东西了，但近一年不接触，多少有些生疏，所以我会尽力做一下总结，以便回顾。


<!--more-->


关于树状数组的原理：使用数组中第`i`项来存储包括第`i`项在内的前`lowbit(i)`项的数的和，`lowbit()`函数计算的是`i`的二进制表示中从右向左一直到第一个`1`的串代表的十进制数的大小，或这可以说是`i`的最大的可以表示成`2^n`的因数。例如`lowbit(3)=1,lowbit(6)=2,lowbit(8)=8`.

因此，该数组所代表的数的意义便如下图所示：
![photo](http://images2015.cnblogs.com/blog/997388/201608/997388-20160811142050137-1641841650.png)

图中的`1,10,100`均为二进制表示。

而根据上面所写的`lowbit()`函数的第一个含意，我们可以用一个简单的公式来计算:

 $$  lowbit(i)=i&(-i)  $$

其原理为计算机用补码的方式存储负数，不再累述。

因此，我们可以得出其update与query操作：
```c++
//点操作，区间查询
void update(int x,int y)
{
	for (int i = x; i<=n; i += lowbit(i))
    	a[i] += y;
}

int query(int x)
{
	int ans = 0;
	for (int i = x; i>0; i -= lowbit(i))
    	ans += a[i];
	return ans;
}

int query(int l,int r)
{
	return query(r)-query(l-1);
}
```

```c++
//区间操作，点查询(此时树状数组中只存储该范围的数都需增加的值
//而不存储初始值)

//这里需要注意可能会过度更改
//例：更改3~8加上v，但更改a[8]后1~8都被更改，所以需要
//更改1~2加上-v
void update(int l,int r,int v)
{
	int i;
	for (i = r; i>=l; i-=lowbit(i)
    	a[i] += v;
    if (i<l-1）		//可能会过度更改，进行纠正
    update(i+1,l-1,-v);
}

void query(int x)
{
	int ans = 0;
	for (int i=x; i<=n; i++)
    	ans += a[i];
    return ans;
}
```
01postpublish0111045a7c546f39c15b0abcc65fd1309c87d{"cid":2,"title":19,"slug":2,"created":10,"modified":10,"text":954,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}19大学-新的开始1915057441001505744609<!--markdown--># 展望

> 拖了半天，也算是拖到现在了。终究建好了Blog，可总是无目的地写总是不行的。总要为自己找些目标，对自己的未来有所规划。


<!--more-->


来到大学已然半个月了，军训已经结束，课程也亦将开始。大学四年，不知不觉，就要真正启航了。而如今，于此，我或许也该定下一些属于自己的目标。

首先的，亦是最重要的--算法。高中两年的OI生涯，让我有了起跑线，亦有了目标。虽高中时的梦想化为泡影，可大学四年是一次重新的开始。这是我的梦，我不想让它再次成为一次泡影。

其次，要维护好自己的Blog,学习一些网络基础的知识。

还有，要制作一个UWP的app，锻炼自己的项目能力。

最后，要巩固好自己的计算机基础能力与数学能力。

文笔不佳，但只愿能一直鞭策自己前行。
01postpublish111105987e387506d19c75f14b5766e1f825e{"cid":2,"title":18,"slug":2,"created":10,"modified":10,"text":506,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}23大一上第四周2315067812001506781348<!--markdown-->## 2017

> 果然，自己不是一般的懒啊，明明一直想着要写日记的，却到现在只写了开头一篇，还被自己误删了。。。现在开始，正式开始写吧

<!--more-->

### 9/30 周六

开学一个月了，明天就要放假啦！开学有好多事，但总算办完了。今天买了3本书，花了不少钱，但是感觉好开心ヾ(o◕∀◕)ﾉ (虽然买了也看不懂)。就要回家了，今天要早睡，明天还要站一天_(┐「ε:)_01postprivate011101eaa70467ecb69100e78d8d0faadc612{"cid":2,"title":24,"slug":2,"created":10,"modified":10,"text":1963,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}25各种关键字的用法2515071836201508382945<!--markdown-->> 记录c,cpp或c#中各个用在声明与定义前的关键字的作用。

> 打算记录的关键字有`ref,out,inline,register,static，auto,extern,volatile`

<!--more-->

初学到这两个函数，貌似很相似，但其实还是有些区别的，使用时也有很多需要注意的地方。

> <!-- index-menu -->

## inline

`inline` 一般放于函数的定义前，表明当前的函数会在编译时直接将该函数的代码置于调用的地方。一般都会放在调用次数较少的函数前。(注意，在gcc中，该函数只起建议作用，若函数不适合直接替换汇编码，gcc会按正常情况编译)

## static

[*参考*](http://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777441.html)

加了`static`关键字的变量或函数被称为静态变量或静态函数。其有以下特性：

1. 加了`static`关键字的变量或函数不具备全局可见性，即无法在该工程的其他源文件中调用
2. `static`会将当前变量放在与全局变量相同的静态数据区，而非局部变量的栈。所以该变量只会在程序被调用时进行一次初始化
3. `static`会令当前变量初始值为0
4. 函数前加`static`会使函数变为静态函数，但此处的`static`并不会改变其存储方式，而是使函数只能在本文件中被调用

## register

在变量的声明前加上此关键字，会使用寄存器来存储当前变量，加快速度。

## ref 与 out

1. `ref` 在被调用前必须初始化,`out` 则不必。如下：
```c#
int n;
solve(ref n);  //错误
solve(out n);  //正确
```

2. `ref` 传进去的参数在函数内部可以直接使用，而 `out` 不可：
```c#
public void solve(ref int n)
{
int x = n;  //right
}

public void solve(out int n)
{
int x = n;  //wrong
}
```

3. `ref` 传进去的参数在函数内部可以不被修改，但 `out`须在离开函数体前进行赋值。01postpublish01110241c61686154cc8a815c33e55e34eec3{"cid":1,"title":10,"slug":1,"created":10,"modified":10,"text":2449,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}7Jury Marks715040956001508374764<!--markdown-->## Codeforces 424 C

题目来源：[Codeforces](http://codeforces.com/contest/831/problem/C)

> 这道题在提交的时候有一个非常小的问题没有发现，打比赛时怎么也没有通过，最后比赛后看数据明白了过来。虽然这道题比赛时想出来了，但是我觉得解法还是有所启发的，故记录一下。


<!--more-->


题目大概为对一个人有`k`个人进行`k`次评分，其中Polycarp知道其中`k`个人的评分（评分可以是负的）与$n$次评分后该人的总分（`n<=k`）,而这个人进行第一次评分前的总分不可知，求满足已知条件下初始分数有几种可能（`k`人的评分按顺序给出，`n`个总分不按顺序给出）。

乍一看我们若是暴力就极为复杂，但我们可以发现，第`i`次总分与初始分数之间的差值总是固定的，即可用前缀和求出。然后我们只要确定了`a[]`中的任意一个数与`b[]`中对应即可确定其差值，而这个差值对于其他`a[]`与`b[]`是固定的，所以可以这样验证。(`a[]`用来记录前缀和，`b[]`用来记`n`次总分)

但是这是我们需要注意不能重复查找，因为即使位置不同，但若其差相同，初始值便相同。但用数组记录则会浪费时间与空间。我们又可以发现该题目中求出前缀和后顺序对数列`a,b`都无影响，故可以先排序，再通过确定`b[1]`与a数列中某一数对应来确定差值，再寻找其他数是否可以对应。

而初始值对应的即是` a[ 0 ](a[ 0 ]=0) `,即
$$ b[1]-a[i]=ans-a[ 0 ] $$

i即是需要一个个尝试的与`b[1]`对应的数。

而我们可以通过不尝试`a[i]=a[i-1]`的数来避免重复计算。

代码如下（我的`n`与`k`与题目中恰好相反）:
```C++
#include <cstdio>
#include <algorithm>

using namespace std;

int n,k;
int a[2010];
int b[2010];

int main()
{
	scanf("%d%d",&n,&k);
	a[0] = 0;
	for (int i = 1; i<=n; i++)
	{
		int x;
		scanf("%d",&x);
		a[i] = a[i-1] + x;
	}

	for  (int i = 1; i<=k; i++)
		scanf("%d",&b[i]);

	sort(a+1,a+n+1);
	sort(b+1,b+k+1);

	int ans = 0;
	for (int i = 1; i<=n-k+1; i++)
	{
		if (a[i]==a[i-1] && i!=1)	continue;
		int t = b[1]-a[i];
		int j = i+1;
		int kk = 2;
		for (;kk<=k && j<=n;)
			if ((b[kk]-a[j])==t)
			{
				kk++;
				j++;
			}else j++;
		if (kk==(k+1))	ans++;
	}
	printf("%d",ans);
}
```01postpublish21110afde4f03588108302810b2befa15a5f6{"cid":2,"title":18,"slug":2,"created":10,"modified":10,"text":1152,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}39最优布线问题3915088342801520068330<!--markdown--># Kruskal

> 另一个用来复(cou)习(shu)的水题(逃


<!--more-->


题目来源：[_code\[VS\]_](http://codevs.cn/problem/1231/)

典型的最小生成树，用的Kruskal，没加任何优化。。。

代码如下：

```C++
#include <cstdio>
#include <algorithm>
#include <iostream>

using namespace std;

int fa[100010];

struct Edge
{
	int from,to,val;
	Edge(int from =0,int to=0,int val =0):from(from),to(to),val(val)	{}

	const bool  operator < (const Edge& tmp)const {
		return this->val < tmp.val;
	}
}e[100010];

int find(int i){
	return fa[i]==i?i: fa[i] = find(fa[i]);
}

long long Kruskal(int n)
{
	long long ans = 0;
	for (int num=0,i=1;num<n-1; i++)
	{
		int fl = find(e[i].from) , fr = find(e[i].to);
		if (fl != fr){
			fa[fl] = fr;
			num ++;
			ans += e[i].val;
		}
	}
	return ans;
}

int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for (int i = 1; i<=m; i++)
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		e[i]  = Edge(x,y,z);
	}

	sort(e+1,e+1+m);

	for (int i =1 ; i<=n; i++)
		fa[i]  = i;

	long long ans = Kruskal(n);

	cout << ans;
}
```01postpublish0111050b7a15728cdb8e30029638800d1c4aa{"cid":2,"title":6,"slug":2,"created":10,"modified":10,"text":1384,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}37热浪 [Dijkstra]3715088296001535091989<!--markdown--># SPFA
> 多做几个比较经典的题，巩(cou)固(yi)基(xia)础(shu)(逃

<!--more-->

题目来源：[_code\[VS\]_](http://codevs.cn/problem/1557/)

题目很经典，不再多说了，但是！在当前`c[head]`向下搜索完后一！定！要！让其出队列！！

代码如下：
```C++
#include <cstdio>
#include <cstring>

#define INF 0x3f3f3f3f

struct Edge
{
	int from,to,val,next;
	Edge(int from = 0,int to = 0,int val = 0,int next = 0):from(from),to(to),val(val),next(next)	{}
}e[13000];

int f[3000];
int dist[3000];
bool b[3000];

void SPFA(int s)
{
	int c[20000];
	dist[s] = 0;
	c[1] = s;
	int head = 1, tail = 1;
	while (head<=tail)
	{
		int v = f[c[head]];
		while (v)
		{
			if (e[v].val + dist[c[head]] < dist[e[v].to])
			{
				dist[e[v].to] = dist[c[head]] + e[v].val;
				if (!b[e[v].to])
				{
					b[e[v].to] = true;
					c[++tail] = e[v].to;
				}
			}
			v = e[v].next;
		}
		b[c[head++]] = false ;
	}
}

int main()
{
	memset(f,0,sizeof(f));
	memset(dist,INF,sizeof(dist));
	memset(b,false,sizeof(b));

	int t,c,st,en;
	scanf("%d%d%d%d",&t,&c,&st,&en);
	for (int i = 1;  i<=c; i++)
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		e[i*2-1] = Edge(x,y,z,f[x]);
		f[x] = i*2 -1;
		e[2*i] = Edge(y,x,z,f[y]);
		f[y] = i*2;
	}

	SPFA(st);

	printf("%d",dist[en]);
}
```01postpublish01110a77797721ab381d140a71f457f941580{"cid":2,"title":17,"slug":2,"created":10,"modified":10,"text":576,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}48Poker键位编程4815091555361509156191<!--markdown-->> 嗯，不务正业系列。。。。

<!--more-->

<!--index-menu-->

## 编程说明

1. 按PMode(Fn+右Ctrl)进入编程模式(空格右键闪烁)
2. 按想要对其编程的键(空格右键常亮)
3. 键入变成内容然后按 PN(空格右键再次闪烁)
4. 重复可编程其他按键
5. 按Fn + 右Ctrl 退出

示例:
把A编程为123:FN+右Ctrl,A,1,2,3,PN;
继续把FN+A编程为456:FN+A,4,5,6,PN.

## 我的更改

PN+A:    LEFT
PN+S:    DOWN
PN+D:    RIGHT
PN+W:    UP
PN+CAPSLOCK:    ENTER
PN+TAB:    BACKSPACE
WIN:    FN01postpublish0111065e6a80f0b1cbd9ea7a6bf447ac249b3{"cid":3,"title":23,"slug":3,"created":10,"modified":10,"text":2203,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}146操作系统[HNOI 2003]14615198708001549800745<!--markdown--># Luogu 2278 
> | 好久以前就做了一次，没有做出来。这次又做了一遍，感觉思路清晰了不少。

<!--more-->

题目来源: [_Luogu_](https://www.luogu.org/problemnew/show/P2278)

## 分析

由题目可得，我们当前应当运行的进程应该主要取决于进程的优先级，其次取决于进程进入的时间。由于我们只需要知道优先级最高的程序，所以这明显是个堆，所以我们应该使用优先队列来完成。

## 实现步骤

我们首先维护一个当前的时间，然后有一个优先队列。

对于每一次的输入，我们都需要对优先队列进行update，从而将当前时间到此次输入开始的时间这个时间范围中能够运行完毕的进程进行输出，然后在有限队列中插入该进程。

在输入完所有进程后，依次将优先队列中的进程取出，其中应记得更新时间。

## 代码
```C++
#include <cstdio>
#include <algorithm>
#include <queue>

using namespace std;

struct Point
{
	int pid,st,last,rank;

	Point(int pid=0,int st=0,int last=0,int rank=0):pid(pid),st(st),last(last),rank(rank)	{}

	void Print(int t)			//进程运行完毕时的输出
	{
		printf("%d %d\n",pid,t);
	}

	const bool operator < (const Point& tmp)const{		//将rank高或者rank相等并且st早的进程排在前面
		return rank<tmp.rank || (rank==tmp.rank && st>tmp.st);
	}
};

priority_queue<Point> q;

int main()
{
	int a,b,c,d;
	int t = 0;
	while (scanf("%d%d%d%d",&a,&b,&c,&d)!=EOF)			//这里一定要写!=EOF,否则可能超时
	{
		while ((!q.empty()) && q.top().last + t <= b)
		{
			Point p = q.top();
			t += p.last;		//更改时间
			p.Print(t);			//输出
			q.pop();			//取出已经运行完毕的而进程
		}
		if (!q.empty())			//如果还有进程的话
		{						//该进程可以运行一定时间，但是不能运行完毕
			Point p = q.top();	q.pop();
			p.last -= b - t;
			q.push(p);
		}
		t = b;		//调整时间

		q.push(Point(a,b,c,d));
	}

	while (!q.empty())		//输出所有剩下的进程
	{
		Point p = q.top();
		t += p.last;
		p.Print(t);
		
		q.pop();
	}
}
```01postpublish0111091c868e728d599974b5441090dbb83c4{"cid":2,"title":18,"slug":2,"created":10,"modified":10,"text":867,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}42大一上第八周4215088498801509031154<!--markdown-->> 算了，写不写日记只能随心情了，实在养不成这个习惯（瘫


<!--more-->

### 10/24 周二

今天刚刚完成英语offic hour，没想到还要做debate，看样只能下周再去一次了。。。不过本周没有什么事了，除了周五的体测。今天做了一道SPFA与一道Kruskal，都调试了好多次，有些生疏了，果然是整天不务正业的恶果啊（逃

### 10/25 周三

今天查了一下银行卡，有一千元。想了想，攒钱似乎不太现实，只有没钱时才能攒下来钱，咬牙买了poker。ヽ(^o^)丿不过这段时间只能吃土了_(┐「ε:)_

### 10/26 周四

今天又瘫了一天，上课也没好好听(；一_一)。而且明天要！体！测！了！！啊啊啊，好慌。感觉最近体重还是在涨，已经没救了｡ﾟ(ﾟ´Д｀ﾟ)ﾟ｡01postprivate0111095947f77d007829aeb05e321cb100cc6{"cid":2,"title":19,"slug":2,"created":10,"modified":10,"text":2370,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}93Inversioin Counting9315159377401516156762<!--markdown--># CF Edu 35 D

> 这题还是比较简单的，可惜上次比赛时脑袋短路，一直卡在C题上了，这题看都没有看，导致掉了rating.....

<!--more-->

题目来源:[_Codeforces_](http://codeforces.com/contest/911/problem/D)

这道题看完题目以后，立刻就想到了以前学过的逆序对的一些性质。其中有一个性质是:消除一个逆序对的步数一定是奇数。虽然和这题没有太大的关系，但是由此认为这题可以最终推出一个较为简单的数学公式。

那么，这题让我们输出的是每次交换后的逆序对数的奇偶性，由此我们可以就每次交换来分析其对逆序对数的影响。

### 题解

在此之前，显然可以得知，每次对区间翻转时只会对区间内的逆序对数造成影响。即只有对于$ i,j \in [l,r]$，由$i,j$构成的逆序对会变化。并且是逆序对变为"正序对"，"正序对"变为逆序对。

首先，我们假设在区间$[l,r]$共$x(x=r-l+1)$个数当中共有$ w $个逆序对。

与此同时，我们可以得出在这$x$个数中，我们有$C^2_n$个数对。

所以说，我们当前共有$ C^2_n - m $ 个 "正序对"，当我们对当前的区间进行翻转时，它们便变成了逆序对。

所以，当每次翻转前$m$的奇偶性已知时，若我们知道$C^2_n$的奇偶性，便可算出最后每次操作后的奇偶性。

每次操作后$m$的变化率$ \Delta m = C^2_n - m*2 $,所以当$C^2_n$为奇数时答案奇偶性取反，偶数时则不变。

因为$ C^2_n = \frac{n*(n-1)}{2}$，所以只要$n\%4=0$或$(n-1)\%4=0$，$C^2_n$就是偶数，否则为奇数。

由此，我们只要在读入数组后先算出逆序数的奇偶性，然后每读入一个$l,r$，再如此计算就好了。

### 代码
```C++
#include <cstdio>

int a[1510];

int main()
{
	int n;
	scanf("%d",&n);
	for (int i = 1; i<=n; i++)
		scanf("%d",&a[i]);

	bool b = true;
	for (int i = 2; i<=n; i++)
		for (int j = 1; j<i; j++)
			if (a[j] > a[i])
				b = !b;
/*
	if (b)
		printf("even\n");
	else printf("odd\n");
*/
	int m;
	scanf("%d",&m);
	for (int i = 1; i<=m; i++)
	{
		int l,r;
		scanf("%d%d",&l,&r);
		int x = r-l+1;
		if (x%4!=0 && (x-1)%4!=0)
			b = !b;
	
		if (b)
			printf("even\n");
		else printf("odd\n");
	}
}
```01postpublish01110a9b03199b750353a6a1ccf8f4d7ccf86{"cid":2,"title":13,"slug":2,"created":10,"modified":10,"text":2884,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}95Stack Sorting9515161566801517652092<!--markdown--># CF Edu 35 E

> |写出来一个玄学的做法。。。。

<!--more-->

题目来源: [_Codeforces_](http://codeforces.com/contest/911/problem/E)

### 证明

题目要求的是令一个数组stack-sortable,也就是说这个数组可以通过一个栈中转从而变成非严格递增的有序数列。

那么我们就看一看一下这样的数组需要满足什么样的条件：

对于某一个数，因为当它在栈中被取出时所有比它小的数一定已经被取出了，所以所有比它小的数在栈中一定在它上面或者已在它进栈前出栈。并且所有比它大的数只能在它下面或者未被取出。

所以，对于某一个数`x`，所有比她小的数必须满足下面两种情况之一：

1. 在它的左面；
2. 在它的右面并且从这个数到`x`之间的所有数都比`x`小。

若我们用区间来表示，那么一个stack-sortalbe的数列中对于每一个`x`都满足以下形式(每个项的位置不能改变)：
$$ x + [1,x-1] + [x+1,n] $$

那么，由于题目中已经给出了`k`个数，所以我们可以推断这`k`个数是否满足条件。

### 实现

我们要维护一个式子，其中包含数字与区间。初始时该式子中无数字，只有一个区间$ [1,n] $。

然后我们每读入一个数，就判断这个数是否在第一个区间中，是的话对区间进行处理，不是的话则这个数列不是一个stack-sortable的数列。

对区间处理时，假设插入了`x`,区间为`[l,r]`，那么若$x \neq l\ \&\ x \neq r$,就把区间分为`[l,x-1]`和`[x+1,r]`。否则直接更改区间为`[l,r-1]`或`[l+1,r]`即可。

最后生成整个数列时，只要将这些区间从前到后对于每个区间中的数从大到小输出即可。

### 代码
```C++
#include <cstdio>

int a[200100];

struct Point
{
	int l,r;
	Point* next;

	Point(int l=0,int r=0,Point* next=NULL):l(l),r(r),next(next)	{}
};

struct S
{
	int a[200100];
	Point* b;

	bool Insert(int x)
	{
		if (x < b->l || x> b->r)
			return false;

		if (x==b->l && x==b->r)
		{
			Point*p = b;
			b = b-> next;
			delete p;
		}else if (x==b->r)
		{
			b->r = x-1;
		}else if (x==b->l)
		{
			b->l = x+1;
		}else{
			Point* c = new Point(x+1,b->r,b->next);
			b->r = x-1;
			b->next = c;
		}
		a[++a[0]] = x;

		return true;
	}

	void Make()
	{
		while (b!=NULL)
		{
			for (int i = b->r; i>= b->l; i--)
				a[++a[0]] = i;
			Point* p = b;
			b = b->next;
			delete p;
		}

		return;
	}
}St;

int main()
{
	int n,k;
	scanf("%d%d",&n,&k);

	St.b = new Point(1,n,NULL);
	St.a[0] = 0;

	for (int i = 1; i<=k; i++)
	{
		scanf("%d",&a[i]);
		if (!St.Insert(a[i]))
		{
			printf("-1");
			return 0;
		}
	}

	St.Make();

	for (int i = 1; i<=St.a[0]; i++)
		printf("%d ",St.a[i]);
}
```01postpublish0111028c3c907accee12c28a4801f48b79860{"cid":2,"title":5,"slug":2,"created":10,"modified":10,"text":1487,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}54Pride5415109731601510973473<!--markdown--># Codeforces 446 C

> 比赛时我用的模拟跑的，结果不对。所以比赛后看着题解重新做了一遍。

<!--more-->

题目来源:[Codeforces](http://http://codeforces.com/blog/entry/55841)

首先我们考虑比较特殊的情况：数组中有$ 1 $。这种情况下我们只需统计$ 1 $的个数`num`，最后输出`n-num`即可。

然后我们考虑普遍情况：

如果存在最短的`j`个数使得其所有数的`gcd()`为$ 1 $，那么我们可以得知通过题目给出的变换使得该数列中出现第一个$ 1 $的操作次数为`j-1`，即为分别对两个数取`gcd()`，然后传给后一个数。此时便化为有$ 1 $的状态，所以总的需要的运算次数为`n+j-2`。

> 注意：我在代码中使用的`j`与描述中略有不同，代码中的`j+1`等于该组数的长度。

```c++
#include <cstdio>

#define MAXN 2010

int a[MAXN],g[MAXN][MAXN];

int gcd(int a,int b)
{
	return a%b==0?b:gcd(b,a%b);
}

int main()
{
	int n;
	scanf("%d",&n);

	int ans = 0;
	for (int i = 0; i < n; i ++)
	{
		scanf("%d",&a[i]);
		if (a[i]==1)
			ans ++;
		g[i][i] = a[i];
	}

	if(ans)
	{
		printf("%d",n-ans);
		return 0;
	}

	for (int j = 1; j < n; j++)
	{
		for (int i = 0; i < n; i++)
			if (i+j<n)
			{
				g[i][i+j] = gcd(g[i][i+j-1],g[i+j][i+j]);
				if (g[i][i+j]==1)
				{
					printf("%d",n+j-1);
					return 0;
				}
			}
	}

	printf("-1");
	return 0;
}
```
01postpublish011108976acc9bdcdf3c8a5be344331dac2f0{"cid":2,"title":8,"slug":2,"created":10,"modified":10,"text":1944,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}56Gluttony5615109775401510977741<!--markdown--># Codeforces 446 D

> 这题答案很好写，但纯粹是个数学题。。。根本想不出来○|￣|_

<!--more-->

题目来源：[Codeforces](http://http://codeforces.com/contest/892/problem/D)

### 解法

令数组`b`等于数组`a`，记录其对应关系，将数组`b`排序，然后将`b[1]`变为`b[n]`，数组前移。再一一对应的替换`a`数组的数。

### 证明

当我们替换回`a`数组后，除了原来的最大值变为了最小值外，每个数都变大了，我们称这个数组为`c`数组。所以对于不包括最小值的区间$[i,j]$，我们可以得出

$\sum^j_{k=i}c_k > \sum^j_{k=i} a_k$

否则若$[i,j]$中含有最小值，则因为对于除$[i,j]$以外的区间中满足上述式子，又因为总和相等，所以对于$k \in [i,j]$，我们可以得出
$\sum^j_{k=i} c_k < \sum^j_{k=i} a_k$

> 注意：计算完后需判断当前解是否可行，若不可行则输出`-1`。


```c++
#include <cstdio>

int a[35],b[35];
int pre[2][35];

void sort(int l,int r)
{
	int mid = a[b[(l+r)/2]];
	int i = l, j = r;

	while (i<j)
	{
		while (a[b[i]] < mid)	i++;
		while (a[b[j]] > mid)	j--;

		if (i<=j)
		{
			int t = b[i];
			b[i] = b[j];
			b[j] = t;
			i++;
			j--;
		}
	}

	if (i<r)	sort(i,r);
	if (l<j)	sort(l,j);
}

int main()
{
	int n;
	scanf("%d",&n);

	pre[0][0] = 0;
	pre[1][0] = 0;
	for (int i = 1; i<=n; i++)
	{
		scanf("%d",&a[i]);
		b[i] = i;
		pre[0][i] = pre[0][i-1] + a[i];
	}

	sort(1,n);

	int t = a[b[1]];
	for (int i=1; i<n; i++)
		a[b[i]] = a[b[i+1]];		//转移
	a[b[n]] = t;

	for (int i = 1; i<=n; i++)
		pre[1][i] = pre[1][i-1] + a[i];

	for (int i = 1; i<n; i++)
		for (int j =0; j<i; j++)
			if (pre[0][i]-pre[0][j] == pre[1][i]-pre[1][j])
			{
				printf("-1");		//判断是否可行
				return 0;
			}

	for (int i = 1; i<=n; i++)
		printf("%d ",a[i]);
}
```
01postpublish31110ad49c0cab73adf1d3f9fe5322410ff8c{"cid":3,"title":12,"slug":3,"created":10,"modified":10,"text":1654,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}107大一寒假10715166009801520931061<!--markdown--># 2018 1 22

<!--more-->

早已经进入2018年了，现在是大学的第一个寒假。近一个月没有写点什么了，感觉无事可写，但又总想写点什么。

昨天收拾了一下我的房间，从一堆书中间找到了我高一时写给高三的我的信(笑)。高三时看这封信已然是羞耻的不得了，现在看就更尴尬了。自大，乐观，想要标新立异，这是高一的我给我现在的感觉。我高一时仿佛感觉自己已经足够成熟了，但是这三年的高中还是改变了我许多。

大学呢？大学毕业之后的我又会是怎么样呢？或许我自己都会全然不认识了吧。我现在又何尝不是在自大呢？仗着自己高中学过一点东西便颓废度日，结果期末考试又是怎样呢--十分不理想。现在已经可以感受到一点压力了。

我要学的东西还是有很多的，不论是人生还是知识。但是从大学以来我就有些迷茫--我到底该干什么？之前从知乎上看到一个回答--有些人学奥赛知识为了享受他们智商上的碾压感。我不知道自己是不是。我很喜欢信息竞赛，可这种喜欢真的是来自于其本身吗?而不是从中获得的成就感。我还能记得我到高中前一直坚持着的梦想--天文学家。虽然有些不切实际，但是或许我真的想做。当然，这也只是或许。

但这些都是我的臆想罢了，真正热爱什么不是想出来的，是感受出来的。正像我大学刚刚开学时感受到的那样：我真的喜欢孤独吗？不，我只是喜欢独自一人罢了。我恐惧真正的孤独。01postprivate01110799ccccfc3c2266968be44a17756af5a{"cid":2,"title":15,"slug":2,"created":10,"modified":10,"text":2043,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}91DNS记录类型9115155527201516598740<!--markdown-->> 因为最近还在研究网站的一些配置，发现域名提供商给我的域名自动加了一堆看不懂的配置文件，所以打算仔细了解一下。

<!--more-->

## 记录类型
### A记录(Address)
A记录也成为主机记录，是使用最广泛也是最基础的DNS记录。其基本作用就是将某一域名指向一个IP地址，即记录域名与IP的对应关系。这也是DNS最基础的功能。

### Cname记录(Canonical Name)
该记录又叫别名记录，它的作用是将域名与域名绑定在一起。比较常用的用法是将`www`域名指向不带`www`的域名。

### MX记录(Mail Exchanger)
邮件交换记录，指向一个邮件服务器。例如，当某个用户发送邮件给user@domain.com时，DNS会查找domain.com的MX记录，若指向了某一邮件服务器，则将该邮件发至该服务器。它可以实现网页服务器与邮件服务器的分流。

### TXT记录
一般指某个主机名或域名的说明，如：admin IN TXT“管理员，电话:xxxxxxxxxx”。其应用之一是SPF(Sender Policy Framework)反垃圾邮件。它可以向收信者表明，哪些邮件服务器是经过某个域名认可会发送邮件的。

### SRV记录
服务器资源记录。记录了一个服务器能提供什么资源。我的域名下多出来的一堆记录就是他们。主要是微软使用，所以我觉得我的nginx服务器应该是用不太上，所以出于(qiang)整(po)洁(zheng)把它们全删了(￣▽￣)"。

### PTR记录
A记录的逆向记录，将某个IP指向域名，必须从DNS的反向区域中创建。不是很懂_(:з)∠)_。

## 其他
### TTL属性
所有记录中都有的一个属性，它告诉网络路由器包在网络中多久进行一次更新。TTL时间越长，客户端就可以减少更多的域名解析时间。但是在更改记录时会带来不便，因为只有上一个路由器包寿命终结时才会进行更新，这样会导致记录的更改会延时很长时间才能生效。01postpublish01110ad1c03a7a9470b153a7a6b31f13abf12{"cid":2,"title":9,"slug":2,"created":10,"modified":10,"text":2213,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}89传纸条8915147970201520068366<!--markdown--># Luogu 1006
> 比较简单的四维棋盘动归，只要能想明白，还是蛮好写的。

<!--more-->
题目来源:[_Luogu_](https://www.luogu.org/problemnew/show/P1006)

设两个人同时从`(0,0)`点出发，我们用`i,j`来表示第一个人的坐标，用`k,l`表示第二个人的坐标，我们只需要确定两个人不会重叠，然后进行DP就好了。
比如，我们假设(i,j)在(k,l)”上面“，则最终状态为`f[n-1][n][n][n-1]`，即两个点最终走到了终点的上边和左边。

状态转移方程为:
$$ f[i][j][k][l] = a[i][j] + a[k][l] + max(f[i-1][j][k-1][l],f[i-1][j][k][l-1],f[i][j-1][k-1][l],f[i][j-1][k][l-1]) $$

所以，我们有了一个$O(n^2m^2)$的算法，最终的代码为：
```c++
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

int a[52][52];
int f[52][52][52][52];

int Max(int a,int b,int c,int d)
{
	return max(max(a,b),max(c,d));
}

int main()
{
	memset(f,0,sizeof(f));

	int n,m;
	scanf("%d%d",&m,&n);

	for (int i = 1; i<=m; i++)
		for (int j = 1; j<=n; j++)
			scanf("%d",&a[i][j]);

	//我们设(i,j)在(k,l)上面
	for (int i = 1; i<m; i++)
		for (int j = 2; j<=n; j++)
			for (int k = i+1; k<=m; k++)
				for (int l = 1; l<j; l++)
					f[i][j][k][l] = a[i][j] + a[k][l] + Max(f[i-1][j][k-1][l],f[i-1][j][k][l-1],f[i][j-1][k-1][l],f[i][j-1][k][l-1]);

	printf("%d",f[m-1][n][m][n-1]);
}
```

但是，我们可以发现一个规律，$ i+j == k+l $,也就是说我们可以用三个变量来表示这两个点的位置。如此，我们便有了`f[i][j][k]`来表示两点位置，`i,j`分别为两点的纵坐标，`k`则为当前`i,j`之和。因为每次只可能是横坐标或纵坐标加一，所以总步数减去纵坐标即是横坐标。

转移方程为:
$$
f[i][j][k] = a[i][k-i] + a[j][k-j] + max(f[i][j][k-1],f[i-1][j][k-1],f[i][j-1][k-1],f[i-1][j-1][k-1]);
$$

DP时的循环应为:
```C++
for (int k = 3; k<n+m; k++)	//因为在(1,1)时k已为2，所以这里从3开始
	for (int i = 1; i<m; i++)
    	for (int j = i+1; j<=m; j++)	//i点在j点上面
```

最后输出`f[m-1][m][n+m-1]`即可，代码不再赘述。01postpublish01110884963a3683b64bbec3b9bdde7a232ec{"cid":2,"title":29,"slug":2,"created":10,"modified":10,"text":1614,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}96Latex数学公式常用用法9615161695801517652086<!--markdown-->> Latex用的比较多，但是很多地方并不熟练，需要整理一下。

<!--more-->

参考网站及文档:

> [_常用数学符号的 LaTeX 表示方法_](http://mohu.org/info/symbols/symbols.htm)

> [_一份不太简短的 LATEX2e 介绍_](http://www.mohu.org/info/lshort-cn.pdf)(文档)

### 上下标

* 上标`^`:	`2^n` $ 2^n $
* 下标`_`:  `2_i` $ 2_i $
* 特殊符号时：  `\sum_{i=1}^n` $ \sum_{i=1}^{n} $

### 平方根

* `\sqrt x`: $\sqrt x$ 
* `\sqrt{x+1}`: $\sqrt{x+1}$
* `\sqrt[3]{x+1}`: $\sqrt[3]{x+1}$

### 水平线

* `\overline`: $\overline{x+y}$
* `\underline`: $\underline{x+y}$

* `\overbrace{x+y}^{z}`: $\overbrace{x+y}^{z}$
* `\underbrace{x+y}_{35}`: $\underbrace{x+y}_{35}$

同理，有`\overrightarrow,\overleftarrow,\underrightarrow,\underleftarrow`。

### 向量

* `\vec a`: $ \vec a $

### 分数

* `\frac 1 2`: $\frac 1 2$
* `\frac{x+1}{y*z^2}`: $\frac{x+1}{y*z^2}$

### 积分，求和与乘积运算符

* `\int_0^n`: $\int_0^n$
* `\sum_{i=0}^n`: $\sum_{i=0}^n$
* `\prod_x`: $\prod_x$ 

### 常用关系符

* `\leq`或`\le`: $\leq$
* `\geq`或`\ge`: $\ge$
* `\equiv`: $\equiv$
* `\ll`: $\ll$
* `\gg`: $\gg$
* `\in`: $\in$
* `\notin`: $\notin$
* `\subset`: $\subset$
* `\supset`: $\supset$
* `\subseteq`: $\subseteq$
* `\supseteq`: $\supseteq$
* `\approx`: $\approx$
* `\neq`或`\ne`: $\ne$

### 常用运算符

* `\mp`: $\mp$
* `\pm`: $\pm$
* `\times`: $\times$
* `\div`: $\div$
* `\cdot`: $\cdot$
* `\setminus`: $\setminus$ 
* `\cup`: $\cup$
* `\cap`: $\cap$
* `\ast`: $\ast$01postpublish011107a607b6a44fe0b0417854c073acd6c4c{"cid":2,"title":24,"slug":2,"created":10,"modified":10,"text":5533,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}59莫妮卡的博弈游戏5915136086001535423195<!--markdown--># HITwh 23
>我是多久没写过题解了，感觉自己已经快要废掉了(≧﹏ ≦)

> PS:现在用的Latex插件有些问题，有的公式解析不出来，所以。。。。先凑合着看吧

<!--more-->
题目来源：[HITwh OJ](http://10.245.130.74:81/problem/23/)(学校内网的oj，外网不能访问。。。。。)

时间限制: 1000ms   内存限制: 64M

### 题目描述

你最近从Steam上下载了一款名为《心跳文学社》的游戏，然后你开始玩，但逐渐地你发现一个问题，无论你使用什么方法，你都无法攻略游戏中一个名为莫妮卡的角色。随着游戏的进行，你发现你逐渐地无法控制游戏的走向，更糟糕的是，你发现莫妮卡十分清楚她正处于一个游戏当中，接着她破坏了你的游戏存档文件。为了拯救你的存档，你决定与莫妮卡玩一个游戏，如果你获胜了就可以恢复你的存档文件。

游戏规则是这样的：在你面前有$N$个单词，每一个单词都有一个类似好感值的属性$X_i$，你和你莫妮卡轮流进行每个回合的操作。在每个回合中，玩家必须从这$N$个单词中选择两个，然后把这两个单词组合成一个新的单词，假设之前的两个单词的好感值分别为$X_a$与$X_b$，那么新单词的好感值可以是$ X_a − X_b $或者$ X_b − X_a $。游戏将持续进行直到只剩下一个单词，这个单词的好感值Xf将决定游戏的胜负。

如果$ X_f \% 3==0 $，那么当前回合进行操作的玩家失败；
如果$ X_f \% 3==1 $，那么你获胜；
如果$ X_f \% 3==2 $，那么莫妮卡获胜。
注意，这里的取模运算是数学意义上的，比如说：$ 3 \% 3 = 0 $，$ 1 \% 3 = 1 $，$ \−1 \% 3 = 2 $，结果不会为负数。

我们都知道，AI是十分聪明的，这意味着莫妮卡每次都会选择最佳的操作方式。而你为了拯救你的存档，你学习了博弈论的相关知识，这意味着你每次也会选择最佳的操作方式。

现在你想知道对于一个给定的局面，谁将成为最后的胜利者。

### 输入
输入包含多行。
第一行为一个整数$ T(1 \le T \le 233) $，代表测试用例的组数。
对于每组测试用例，第一行为两个整数，分别是单词的数量$ N (1 \le N \le 233) $和先进行操作的玩家$ F \in {0,1} $，如果$F=0$，则你先进行操作，否则由莫妮卡先进行操作。
接下来的一行为N个整数，代表第i个单词的好感值$ X_i ( −233 \le X_i \le 233) $。

### 输出
对于每组测试用例，如果你能获胜，则在新的一行中输出"`WIN`"，否则输出"`LOST`"。
如果你觉得不能确定谁会获胜，就输出"`OUTPUT THIS TO GET WA`"。

### 样例输入
> 3

> 1 0

> 9

> 3 1

> 1 2 3

> 5 0

> 1 3 5 7 9


### 样例输出
> LOST

> WIN

> LOST

## 题解

这一题乍一看很复杂，但是其中其实可以找到很巧妙的规律。我们可以发现最后的答案是与$\%3$的值有关的，也就是说，对于`n`个数$\{x_1,x_2,x_3,\dots,x_n\}$，我们可以将其转化为$\{ x _1\%3 , x _2\%3 , x _3\%3 , \dots ,x _n\%3 \}$，而答案不变。在这种情况的基础下我们研究能够出现必胜策略的情况。

#### 当$n==1$时
我们可以根据$n,k,x_1$的值来推断谁能获胜。其方程如下：

~ Answer = \\left\\{ \\begin{aligned} WIN & , & x_1\\%3=1 \\\\ LOST & , & x_1\\%3=2 \\\\ WIN & , & k=1 \\ \\&\\&\\  x_1\\%3=0 \\\\ LOST & , & k=0 \\ \\&\\&\\  x_1\\%3=0  \\end{aligned} \\right. ~

#### 当$n==2$时
对于$(x _1,x _2)$我们可以得出共有以下5种情况：
~\{ (0,0) , (1,1) , (2,2) , (0,1) , (0,2) , (1,2) \} ~
而因为我们只能进行减法运算，所以我们可以得出$\{ (0,0),(1,1),(2,2)\}$,$\{ (0,1),(1,2)\}$都是相等的，所以我们最后只有$\{ (0,0),(0,1),(0,2)\}$三种情况。

我们假设第一步由"我"来下，即$k=0$。那么，对于以上三种情况：
##### (0,0)
因为下一局变为$(0)$,所以答案为`WIN`
##### (0,1)
我们有两种选择 $ 0-1 $ 和 $ 1-0 $ ,第一种$\%3$后为$2$,第二种为$1$。因为我们总会选择最佳策略，所以肯定会选择$1-0$，然后获胜。
##### (0,2)
我们也有两种选择$ 0-2 $ 和 $ 2-0 $ ，第一种为$2$,第二种$\%3$后为$1$。同理，我们会选择$0-2$，所以我们一定能获胜。

#### 总结

当$n==2$时，无论$x _1,x _2$为多少，当前进行操作的人一定能获胜。

所以当$n>2$时，我们不需要关注$x_i$的数值，而只需要关注当最后选至$n==2$时谁进行操作，即：
~ Answer = \\left\\{ \\begin{aligned} WIN & , & (n+k)\\%2=0\ ,\\ n>1 \\\\ LOST &, & (n+k)\\%2=1\ ,\\ n>1 \\end{aligned} \\right. ~

得出该结论后，代码就很简单了，如下：
```c++
#include <cstdio>

int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
    {
        int n,k;
        scanf("%d%d",&n,&k);
        int x;
        for (int i = 1; i<=n; i++)
            scanf("%d",&x);
        if (n==1)
        {
            if (x%3==1)
                printf("WIN\n");
            else if (x%3==2)
                printf("LOST\n");
            else{
                if (k==0)
                    printf("LOST\n");
                else printf("WIN\n");
            }
        }
        else if ((n+k)%2==1)
            printf("LOST\n");
        else printf("WIN\n");
    }

    return 0;
}

```
01postpublish01110969b8f72d7d518d7142aac1f5490a8e3{"cid":2,"title":15,"slug":2,"created":10,"modified":10,"text":219,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}69关于服务器6915143900401514777632<!--markdown-->> 先占个空，否则我肯定懒得写。。。。

<!--more-->

* 如何解决Markdown与Latex的冲突
* 如何实现301重定向
* 申请ssl证书
* 令markdown的代码段支持Haskell代码01postpublish01110d39fdb6d5d0a78da323621464052c423{"cid":2,"title":21,"slug":2,"created":10,"modified":10,"text":1128,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}71大一上第十七周7115144294141514429471<!--markdown--># 2017 12 28

<!--more-->

又是好久没有写日记了，因为快要放假，最近的课程少了不少，之前连续浪了好几天。但是最近因为考试与答辩事情反而又稍微多了一些。

昨天晚上刚刚把答辩用的ppt写完，感觉完全被各种关系图给绕晕了。今天晚上7点又要去做答辩，感觉整个人要废掉了。

不过昨(jin)天(tian)晚(ling)上(chen)过的还算充实。答辩ppt做完后，设置了一个`songer@songer.xyz`的邮箱，转到我的outlook邮箱。顺便改了下后台登入地址，然后又把带`www`前缀的网址设置了以下(话说我之前一直不能用原来只是因为少加了一个`.`)。。。。。。

然后。。。12:35开始了一场CF的比赛，结果，第一道题看不懂，虽然题水得狠。。。。果然还是要提高自己的英语姿势水平啊。结果最后3点半才睡。

今天晚上还有一场比赛，而且我打算抽时间把301重定向设置好，然后争取把mathjax和markdown冲突的问题解决一下，算是对这几天我这么浪的补偿。。。。。
01postprivate01110e37d1d4f212e617cfeabf9231a35b447{"cid":2,"title":14,"slug":2,"created":10,"modified":10,"text":1785,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}72Haskell基础17215144322201517217390<!--markdown--># 函数，列表，元组
> 一些Haskell的基础语法
<!--more-->
---
## 函数定义
> * Haskell中函数不能大写字母开头

```Haskell
--函数名 :: 类型
add :: Int -> Int -> Int
doubleMe :: Int -> Int
```

## 类型
```Haskell
-- 普通类型
Int,Double,String,Char etc.
-- 函数类型
使用 -> 进行拼接
如若 add 函数需传入两个Int，输出一个Int，则其类型为
Int -> Int -> Int
-- 而当我们想要 add 函数可对任何类型进行操作操作，我们可以设置为
a -> a -> a
-- 其中a代表任意类型
-- 当我们只需对数字进行操作时，可以使用类型类进行限定，如
(Num a) => a -> a -> a
```

## 函数实现
> 通过**模式匹配**实现

```haskell
--计算平方的函数
doubleMe x = x * x

--计算平方和的函数
doubleUs x y = x * x + y * y

--将小于100的数乘2
doubleSmallNumber = if x>100
					then x
                    else 2 * x
```

## 列表
> 类似数组

1. 可以使用 `x:xs` 或 `x ++ xs`的方式来拼接列表

2. 列表支持嵌套

3. 可以通过 `!!` 函数访问列表

4. Haskell可以自动补全区间，诸如`[1..20]`或`['a'..'z']`

## 列表推导式

> 列表推导式写法类似于数学中的集合，如下：

```haskell
--1到20中的所有技术
[ x | x<-[1..20] , x 'mod' 2 /=0]

--x与y的所有乘积
[ x * y | x<-[1..20] , y<-[1..20] ]

--以上的函数一般写法
Multiply xs ys = [ x * y | x<-xs , y<-ys]
```

## 元组
> 类似结构体，可以结合不同类型的元素

> 元组中只有两个元素时被称为序对

```haskell
--使用括号进行组合
(a,b)
(a,"what",x)
--可以限定a的类型
add :: (Num a) => (a,a) -> a
add (a,b) = a + b
```
01postpublish011109966dc5e9c500328bee66eb6a3d55418{"cid":2,"title":12,"slug":2,"created":10,"modified":10,"text":403,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}86301重定向8615147772271514777227<!--markdown-->> 因为之前一直没有启用www域名，故没有注意到这些问题，近来发现若要合并两个网站，须做301重定向。

<!--more-->

301重定向的设置极为简单，只需要在nginx.conf文件中的server中，在server_name后加入以下几行代码即可：

```nginx
if ($host != 'songer.xyz' ) {
rewrite ^/(.*)$ http://songer.xyz/$1 permanent;
}
```01postpublish01110017cae00d35bb53cb3522b26dc363cd1{"cid":2,"title":11,"slug":2,"created":10,"modified":10,"text":2952,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}99C#基础--19915165970201517652080<!--markdown--># CTS类型，枚举类型，控制语句

> |由于已经~~(精通)~~学过了C++语言，所以会着重与C#与CPP的不同之处，不再从头整理。

<!--more-->

## 变量的定义
* 支持类型推断，使用`var`来定义变量；
* 变量在使用前必须初始化。

## CTS类型
由于C#并没有内置类型，所有的类型都内置于.NET Framework中，C#中的类型只是.NET类型(CTS类型)的示例。这一点和Haskell中的类型类比较相似。因此，我们可以实现以下操作:

```
string s = i.ToString();
```

CTS类型共有15种值类型，2中引用类型(string和object)。如下:

1.整型(8种)
 
|  名称 |    CTS类型    |   说明   |
|-------|--------------|----------|
| sbyte | System.SByte | 8位有符号 |
| short | System.Int16 | 16位有符号|
| int   | System.Int32 | 32位有符号|
| long  | System.Int64 | 64位有符号|
| byte  | System.Byte  | 8位无符号 |
| ushort| System.UInt16| 16位无符号|
| uint  | System.UInt32| 32位无符号|
| ulong | System.Uint64| 64位无符号|


一个整数默认为int类型，若要将其付给其他整个书类型，可以在后面加上'L'(long),'U'(uint),'UL'(ulong)。

2.浮点类型(2种)

|  名称  |    CTS类型     |   说明   |
|--------|---------------|----------|
| float  | System.Single | 32位单精度 |
| double | System.Double | 64位双精度|
3.decimal类型--高精度浮点类型

> CTS类型: System.Decinal

> 说明: 128位高精度

4.bool类型

> CTS类型: System.Boolean

5.字符类型

> CTS类型: System.Char

6.引用类型

|  名称  |    CTS类型     |      说明     |
|--------|---------------|---------------|
| string | System.String | Unicode字符串 |
| object | System.Object | 根类型，CTS中所有其他类型都有它派生|

## 控制语句

### switch
* 除非`case`后什么都不写，否则必须要写`break`语句。

### foreach
foreach循环可以迭代集合中的每一项。我们假定`Array`是一个整型数组，则可使用如下:
```C++
foreach (int temp in  Array)
{
	Console.WriteLine(temp);
}
```
注意，foreach不能改变集合中各项的值，即上面的`temp`不可更改。

## 枚举类型
> 虽然CPP也有枚举类型，但是我使(mei)用(yong)较(guo)少.

写法如下:
```C#
public enum TimeOfDay
{
	Morning = 0;
    Afternoon = 1;
    Evening = 2;
}
```
我们可以用形如`TimeOfDay.Morning`直接取出数值，然后和当前时间进行比较，从而判断时间。

在C#中，enum基于`System.Enum`基类，速度上没有损失，且支持一些已经写好的方法，如:
```C#
TimeOfDay time = TimeOfDay.Afternoon;
Console.WriteLine(time.ToString());
//按字符串输出

//从字符串中获取值
TimeOfDay time2 = (TimeOfDay) Enum.Parse(typeof(TimeOfDay),"afternoon",true);
Console.WriteLine((int)time2);
```01postpublish011103fb660030d218142e5d0a96c9ab359c3{"cid":3,"title":11,"slug":3,"created":10,"modified":10,"text":2527,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}109C#基础--210915168551401518244885<!--markdown--># 名称空间,Main()方法

> |仍旧是一些基础的东西

<!--more-->

## 名称空间
### 特性
* 名称空间是一种逻辑组合而非物理组合
* C#中名称空间可以互相嵌套，下列写法等价
``` C#
namespace Songer
{
	namespace CSharp
    {
    	namespace Basics
        {
        	class NamespaceExample
            {
            	//Code for the class here
            }
        }
    }
}
```
```c#
namespace Songer.CSharp.Basics
{
	class NamespaceExample
    {
    	//Code for the class here
    }
}
```
* 不允许在嵌套的名称空间中声明多部分的名称空间

### using语句
C#中可以通过使用`using`语句来简化名称空间的应用操作。其作用类似于C++中的`using namespace`，不过使用更广泛。

> 注：由于using常写于C#文件开头，故有人会认为其余C,CPP中的`#include`等价，这是错误的。`using`并没有在文件之间建立物理链接。

### 别名
若是想要简化引用函数式的操作，但是又想避免类名冲突，就要用到别名了。注意，别名的修饰符为`::`，与直接引用名称空间不同。其用法为：
```C#
using alias = NamespaceName;

例:
using Introduction = Songer.CSharp.Basics;
//下面两句等价
Introduction::NamespaceExample NE = new Introduction::NamespaceExample();
Songer.CSharp.Basics.NamespaceExample NE = new Songer.CSharp.Basics.NamespaceExample();
```

## Main()方法
C#的程序从`Main()`方法开始执行，其返回类型必须为`int`或`void`。一般来说，加入`public`修饰符是很常见的。但是，若加入`private`修饰符也不会影响程序运行。

编译软件在编译时会自动寻找所有类中的`Main()`方法，若只有一个则编译完成。若有多个则会报错，这是我们需要在编译时指定一个类(需写全称)，以这个类中的`Main()`方法为入口。如下:
```bash
csc HelloWorld.cs /main:Songer.CSharp.Basics.NamespaceExample
```

## 编译选项

* /t: 制定要创建的文件类型
* /out：指定生成文件名称
* /r：引用在程序集中未引用的类库
其中，生成的文件类型分为以下几种:

|    选项   |            输出                 |
|-----------|--------------------------------|
|/t:exe     |  控制台应用程序(默认)			  |
|/t:library |  带有清单的类库					|
|/t:module  |  没有清单的类库					|
|/t:winexe  |  Windows应用程序(没有控制台窗口)	 |
01postpublish01110cb95d3c0dc9512e126877406ceb5c014{"cid":3,"title":18,"slug":3,"created":10,"modified":10,"text":3098,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}112KMP字符串匹配11215168700801520068378<!--markdown--># Luogu 3375

> |KMP算法，准确的说是KM算法，遥想很久以前写过一次，后来就再也没有动过了。现在差不多也已经忘记怎么写了，重新学习以下。

> 例题是Luogu上的一道模板题，以前做过一次，只得了70分。这次又做了一遍，结果我已经无力吐槽了。用`gets()`读入字符串0分，自己用`getchar()`手写读入是70分，用`scanf()`读入是100分。。。。。纠结了我一整个下午的问题就这么解决了○|￣|_

<!--more-->

题目来源:[_Luogu_](https://www.luogu.org/problemnew/show/P3375)

考虑字符串`a`(长度$n$),`b`(长度$m$),$m<=n$,传统的字符串匹配算法的时间复杂度是$O(mn)$的(极端情况下),而Kmp的时间复杂度是$O(m+n)$。其关键在于其前缀数组。

我们在使用传统的字符串匹配算法时，极端情况下之所以很慢，是因为我们可能会将两个字符串中的每一个字符都比较一遍。但是在很多情况下，我们知道了字符串`b`后，当我们与字符串`a`匹配失败后，我们可以显然的到向右移动一位甚至好几位之后还是无法匹配的。KMP算法就是通过预处理，算出在当前匹配失败后，`b`向右移动多少位才有可能匹配，从而节省时间。

这样，我们可以通过一个数组`f[i]`来记录右移后第几个字符能够到达`i`的位置。在匹配过程中，代码如下：
```C++
int j = 0;
for (int i = 0; i<n; i++)
{
    while (j && a[i]!=b[j])	
    	j = f[j];
    if (a[i]==b[j])	
    	j++;
    if (j==m)
    {
    	printf("%d",i-m+1);
    	break;   
    }
}
```

而整个算法中，最为神(xuan)奇(xue)的就是失配函数`f[]`的构造，其实也就是一个`b`数组对自己进行匹配的过程:
```C++
for (int i = 0; i<m; i++)
{
	int j = f[i];
    while (j && b[i]!=b[j])
    	j = f[j];
    f[i+1] = b[i]==b[j]?1:0;
}
```

> 注意：上面我们求的`f[i]`满足的条件为$b[f[i]-1] == b[i-1]$而非$b[f[i]] == b[i]$，而下列代码中的`f[i]`由于题目要求，满足的条件为$b[f[i]-1] == b[i]$.

代码:
```C++
#include <cstdio>
#include <cstring>

#define MAXN 1000100

char a[MAXN],b[MAXN];
int f[MAXN];
int n,m;
/*
void GetString(char* s,int& n)
{
	char c = getchar();
	while ((c<'A'||c>'Z') && (c<'a'||c>'z'))
		c = getchar();
	n = 0;
	while ((c>='A'&&c<='Z')||(c>='a'&&c<='z'))
	{
		s[n++] = c;
		c = getchar();
	}

	return;
}
*/
void getFail()
{
	f[0] = 0;
	//f[1] = 0;
	for (int i = 1; i<m; i++)
	{	
		int j = f[i-1];
		while (j && b[i]!=b[j])	j = f[j-1];
		f[i] = b[i]==b[j]?j+1:0;
	}

	return;
}

void find()
{
	int j = 0;
	for (int i = 0; i<n; i++)
	{
		while (a[i]!=b[j] && j) j = f[j-1];
		if (a[i]==b[j])	j++;
		if (j==m)
			printf("%d\n",i-m+2);
	}
}

int main()
{
	//GetString(a,n);
	//GetString(b,m);

	scanf("%s",a);
	scanf("%s",b);

	//gets(a);
	n = strlen(a);
	//gets(b);
	m = strlen(b);

	getFail();

	find();

	for (int i = 0; i<m; i++)
		printf("%d ",f[i]);
}
```01postpublish01110ac1d51971b86346637c2232a2401a8cc{"cid":3,"title":14,"slug":3,"created":10,"modified":10,"text":5297,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}116Haskell基础211615172173001517652048<!--markdown--># 类型，类型类

> |没想到就写一个类型类，就写了这么多。。。。

<!--more-->

参考书籍:[_Learn you a Haskell_](http://learnyouahaskell.com/)

## 常见类型
大多数与C中相似，但是开头字母必须大写，包含以下类型：
```
Int, Integer, Float, Double, Bool, Char
```
其中，Int在64位系统下为64位。而Integer则是高精度整型，无穷大。

在Haskell中，元组也算一种特殊的类型，其类型取决于其中的项的数目和种类。理论上项的数目可以无限多，但实际最多62个。

## 类型变量
当我们想要写一个取出列表第一个元素的函数，并且可以同时应用于多种不同类型的列表时，我们会怎么做呢？在C++中，我们会用模板(Template)，而在Haskell中，我们就要用到类型变量了。

比如，我们上述的函数类型便如下：
```Haskell
head :: [a] -> a
```
这里的`a`，就是一个类型变量了。在这里，`a`可以是任何类型，只需保证所有的`a`是同一种类型便可以了。我们还可以使用其他的变量名，不过一般都会使用`a,b,c...`。

比如，`fst`可以取出一个序对中的第一个元素，其类型如下：
```Haskell
fst :: (a,b) -> a
```

## 类型类入门
类型类(typeclass)是定义行为的接口。如果一个类型是某类型类的示例(instance)，那它必实现了该类型类所描述的行为。

定义念完了，但还是不太明白。那我们可以举一个例子如下：

首先，我们都知道在Haskell中，`==`为一个函数，那么，他的类型是什么呢：
```Haskell
(==) :: (Eq a) => a -> a -> Bool
```
在这里，我们接触了一个新的符号`=>`，它的左侧叫做**类型约束(type constraint)**，表示下面的`a`类型属于`Eq`这种类型类。它指明了下面的`a`类型支持比较操作。通俗的说类型类便是"类型的类型",虽然不是很准确。

下面，是各种常见的类型类。

### Eq
前面已经提到了，Eq类型类用于判断相等性的类型，要求它的示例必须实现`==`和`\=`两个函数。在类型约束中用`Eq`进行约束，就能确保约束的类型能够进行比较操作。
### Ord
用于可以比较大小的类型。除了函数以外，我们目前所谈到的所有类型都是`Ord`的实例。
### Show
`Show`类型类的实例为可以表示为字符串的类型。到目前为止，我们常用的类型中除函数外都为`Show`类型类的示例。能够操作`Show`类型类的实例的函数中，最常用的是`show`。功能是将该实例转为字符串:
```Haskell
--此处为交互模式
ghci> show 3
"3"
ghci> show 5.334
"5.334"
```
### Read
`Read`可以是为`Show`的反例。同样，除函数外我们提到的所有类型均为`Read`的实例。它可以将字符串类型转为`Read`的某个实例类型。
```Haskell
ghci> read "True" || False
True
ghci> read "8.2" + 3.8
12.0
```
但是，当我们在写`Read "4"`这样的语句时，`Read`将会不知道`4`该被转化为哪种类型，所以此时我们便应这样写:
```Haskell
ghci> read "4" :: Int
4
ghci> read "[1,2,3,4]" :: [Float]
[1.0,2.0,3.0,4.0]
```
不过，当我们像这样写时:

```Haskell
gchi> read "4" + 5
9
ghci> read "[1,2,3,4]" ++ [3]
[1,2,3,4,3]
```
因为Haskell可以根据后面判断，所以不需标注。
### Enum
`Enum`的实例类型都是由连续顺序的--他们的值都是可以枚举的。其主要特点在于支持`succ`和`pred`函数，分别为**后继(successer)**和**前缀(predecesor)**。包含的类型主要有`()`,`Bool`,`Char`,`Ordering`,`Int`,`Integer`,`Float`和`Double`。
```Haskell
ghci> ['a'..'e']
"abcde"
ghci> [LT .. GT]	
[LT,EQ,GT]
--Ordering类型，只包括LT,EQ,GT三种值，分别代表小于，等于，大于。
ghci> succ 'B'
'C'
```
### Bounded
`Bounded`类型类的类型实例都有一个上限和下限，分别可以用`maxBound`和`minBound`来取得。
```Haskell
ghci> minBound :: Int
-2147483648
ghci> maxBound :: Char
'\1114111'
```
`minBound`和`maxBound`两个函数都很有趣，类型为`(Bounded a) => a`，他们都是**多态常量(polymorphic constant)**。
### Num
`Num`是一个表示数值的类型类，它的实例都具有数的特征。比如，一个数的类型:
```Haskell
20 :: (Num t) => t
```
所有的数都是多态常量，它可以具有任何`Num`类型类中的实例类型的特征，如`Int`,`Integer`,`Float`,`Double`.
```Haskell
ghci> 20 :: Int
20
ghci> 20 :: Float
20.0
```
在这里，我们可以检查一下运算符的类型:
```Haskell
(*) :: (Num a) => a -> a -> a
```
### Floating
`Floating`只包含两种类型`Float`和`Double`。需要用到`Floating`类型类的函数一般都是需要用到浮点数来进行某种计算的，如`sin`,`cos`和`sqrt`。
### Integeral
`Integeral`仅包含`Int`,`Integer`。与其相关的一个函数很有用，叫`fromIntegeral`。其类型如下:
```Haskell
fromIntegeral :: (integeral a, Num b) => a -> b
```
这个函数能够取一个整数，返回一个更为通用的`Num`类型类的实例，因为Haskell中浮点型与整型不能直接相加，所以此函数用处很大。01postpublish0111007721000c039efd86b2e63dd32fb64eb{"cid":3,"title":21,"slug":3,"created":10,"modified":10,"text":3533,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}121用栈解析表达式12115179866341517986705<!--markdown-->> 既然已经写了，那就放上来吧。。。写的真的是臃肿，我自己都看不下去了。。。。

<!--more-->

## 解析

这里并没有解析。

## 代码
```C++
#include <cstdio>   

struct NumStack			//存储数字的栈
{
	int x[10010];
	int n;
	NumStack()			//初始化函数
	{
		n = 0;
	}
	int pop()			//取数
	{
		return x[n--];
	}
	int push(int a)		//放入数字
	{
		x[++n] = a;
	}
}num;

struct SymStack
{
	char x[10010];
	int n;
	SymStack()			//初始化
	{
		n = 0;
	}
	char pop()			//取出符号
	{
		return x[n--];
	}
	void push(char a)		//放入符号
	{
		x[++n] = a;
	}
	bool empty()			//检测是否为空
	{
		return n==0;
	}
}sym;

bool Digit(char c)			//检查是否是数字
{
	if (c<='9'&&c>='0')
		return true;
	else return false;
}

void Calculate()			//计算括号内的数(只有加法和减法)
{
	int r = num.pop();				//取出第一个数(从右向左)
	int symr = sym.pop();			//取出它的符号
	if (symr=='(')					//如果括号内只有一个数就退出
	{
		num.push(r);
		return;
	}
	//printf("[%d]\n",r);
	while(1)
	{
		int l = num.pop();			//取出下一个数
		int syml = sym.pop();		//取出它的符号
		if (symr=='-')				//检测是否是负数(减号)
			r = -r;
		if (syml=='-')
			l = -l;
		r = l + r;

		if (syml=='(')				//检测是否到达左括号
		{
			num.push(r);			//到达左括号后把括号内表达式的值放回到栈中
			return;
		}

		//printf("[%d]\n",r);			debug用(输出每一步计算的值)
	}
}

int main()
{
	char c = getchar();
	bool flag = true;
	char cal = 0;

	sym.push('(');
	num.push(0);

	while (c!='\n')
	{
		if (Digit(c))		//如果是数字
		{
			int x = 0;
			while (Digit(c))
			{
				x = x*10 + c - '0';
				c = getchar();
			}						//把该数字的所有位读出来，放在x中
			num.push(x);
			flag = false;			//表明刚刚读了一个数字

			if (cal=='*'||cal=='/')		//如果上一个符号是*或者/，直接运算(因为其优先级很高)
			{
				int r = num.pop();
				int l = num.pop();
				if (cal=='*')
					num.push(l*r);
				else num.push(l/r);
				cal = 0;
			}
		}else
		{
			if (flag && c!='(')				//如果两个符号相连，说明该表达式非法
			{
				printf("Error 1 !!\n");
				return 0;
			}

			if (cal && c=='(')				//如果在括号前有乘除，先记录下来，计算完括号内的值后再计算
			{
				cal ++;
			}

			if (c=='*' || c=='/')			//如果当前符号是*或/
			{
				cal = c;
			}else{

				if (c!='+' && c!='-' && c!='(' && c!=')')		//如果符号不正确
				{
					printf("Error 2!! Get unexpected '%c'\n",c);
					return 0;
				}
	
				if (c==')')				//如果是右括号，计算当前括号内的值
				{
					Calculate();
					if (cal=='*'+1 || cal=='/'+1)		//如果括号前是*或/
					{
						cal -= 1;
						int r = num.pop();
						int l = num.pop();
						if (cal=='*')
							num.push(l*r);
						else num.push(l/r);
						cal = 0;
					}
				}
				else sym.push(c);
			}
			
			if (c!=')')
				flag = true;			//表明刚刚读了一个符号
			c = getchar();
		}
		/*
		int t = num.pop();
		printf("%d\n",t);
		num.push(t);
		*/
	}
	Calculate();

	if (!sym.empty())		//如果符号栈为空，说明括号未完全匹配，表达式不合法
	{
		printf("Error 3 !!");
		return 0;
	}
	printf("%d",num.pop());			//输出最后的值
}
```
01postpublish01110bbd98a7b77bbd8b00dce3de5915a2bb8{"cid":3,"title":14,"slug":3,"created":10,"modified":10,"text":4753,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}120Haskell基础312015178258201517825905<!--markdown--># 语法(模式匹配，哨卫)

> |几天不写Blog了，先写个Haskell凑个数。估计再写两次就赶上现在学的进度了。

<!--more-->
参考书籍: [_Learn you a haskell_](http://learnyouahaskell.com/)

## 模式匹配
### 定义
**模式匹配(pattern matching)**通过检查数据的特殊结构来检查是否匹配，并按模式从中解析出数据。

在Haskell中，函数经常要用到模式匹配，并且可以匹配一切数据类型。譬如，我们有一个检查传进的数是否是7的函数:
```Haskell
lucky :: Int -> String
lucky 7 = "LUCKY NUMBER SEVEN!"
lucky x = "Sorry, you're out of luck, pal!"
```
在调用`lucky()`时，函数会将传入的参数从上到下进行匹配，一旦有匹配，对应的函数体就会被调用。其功能其实类似于if-else语句。

如果我们在模式中给出一个小写字母，那这就是一个**万能模式(catchall pattern)**。他总能匹配输入的参数，并可以在后面调用。

这里还有一个斐波那契数列的例子:
```Haskell
factorial :: Int -> String
factorial 0 = 1
factorial n = n * factorial (n - 1)
```

这里，我们使用了递归来实现，并通过模式匹配来处理了边界值。后面我们会知道，这在Haskell中是十分常见的一种用法。

另外，模式匹配的最后一定要加入一个万能模式，即该函数必须能够处理所有情况，否则调用时用非常规值会发生错误。

### 元组的模式匹配
元组同样可以使用模式匹配。譬如下面的计算二维向量和的函数:
```Haskell
--不对元组内部进行模式匹配
addVectors :: (Double, Double) -> (Double, Double) -> (Double, Double)
addVectors a b = (fst a + fst b, snd a + snd b)
--对元组进行模式匹配
addVectors :: (Double, Double) -> (Double, Double) -> (Double, Double)
addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)
```

### 占位符
在模式匹配时我们有可能只需要考虑其中的某些值，对于其他值不予考虑。这种情况一般发生在使用元组时。比如我们想要看元组的第一个数是否为7:
```Haskell
--我们固然可以使用万能匹配，如这样
lucky :: (Int, Int) -> String
lucky (7, y) = "Lucky for you!"
lcuky (x, y) = "You are not lucky!"
--但是我们也可以用占位符，像这样
lucky :: (Int, Int) -> String
lucky (7, _) = "Lucky for you!"
lucky (_, _) = "You are not lucky!"
```
使用占位符表示我们不关心它的内容，更常见的如取出序对的第一个数:
```Haskell
first :: (a,b,c) -> x
first (x, _, _) = x
```

### 列表和列表推导式的模式匹配

在列表推导式中也可以使用模式匹配:
```Haskell
ghci> let xs = [(1,3), (4,3), (2,4), (5,3), (5,6), (3,1)]
ghci> [a+b | (a,b) <- xs]
[4, 7, 6, 8, 11, 4]
```
我们可以使用`[]`来匹配空列表，也可以配合`:`来匹配非空列表(在Haskell中`[1, 2, 3]`就是`1:2:3:[]`的语法糖)。比如我们可以写一个`head`函数:
```Haskell
head :: [a] -> a
head [] = error "Can't call head on an empty list, dummy!"
head (x:_) = x
```
注意，当我们匹配列表时，对所有元素个数不同的列表都要进行匹配，譬如，我们若创建一个如下列表就会发生错误:
```
badAdd :: (Num a) => [a] -> a
badAdd (x:y:z:[]) = x + y + z
```

### As模式
**as模式(as-pattern)**允许我们按模式把一个值分割成多个项，同时保留对整体的引用。要使用as模式，只要将一个名字和`@`置于普通模式的前面即可。

比如我们有一个取出第一个字符的函数定义如下:
```Haskell
firstletter :: String -> String
firstletter "" = ”Empty string, whoops!"
firstletter all@(x:xs) = "The first letter of " ++ all ++ "is " ++ [x]
```
使用时效果如下:
```Haskell
ghci> firstletter "Songer"
"The first letter of Songer is S"
```

## 哨卫
模式用来检查参数的结构是否匹配，**哨卫(guard)**则用来检查参数的性质是否为真。其亦与if语句相似，但是可读性更高。

我们这里先看一个用到哨卫的函数,根据你的分数按照A,B,C,D进行打分:
```Haskell
judge :: Int -> String
judge score
	| score<60 = "You got a D, fool!"
    | score<75 = "You got a C!"
    | score<85 = "You got a B,not bad!"
    | score<=100 = "Congratulation, you got an A!"
    | otherwise = "Error score!"
```

哨卫跟在竖线(|)的右边，一个哨卫就是一个布尔表达式，如果计算为`True`，则选择对应的函数体，否则计算下一个函数体。每条哨卫语句至少缩进一个空格。

与模式匹配一样，在最后一般要加上一个万能的情况以提升鲁棒性。01postpublish0111085ba0d6802a1025bb6ef4ddc1d2bf5d3{"cid":3,"title":5,"slug":3,"created":10,"modified":10,"text":4075,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}122Tanks12215179952001518944765<!--markdown--># Codeforeces Edu 37 D

> |这题真的是一点思路也没有，好不容易看懂了题解写完了，结果发现理解出了偏差（；´д｀）ゞ

<!--more-->

题目来源: [_Codeforces_](http://codeforces.com/contest/920/problem/D)

## 题解
### 思路
在计算怎么转移之前，我们需要先判断是否能够转移出水的体积为`V`的水桶。

那么，首先我们可以得出，对于$ sum = \sum^n_{i=1}{v[i]} $，若$sum<V$则不可能。

然后我们判断什么时候可以转移。我们可以发现当$ V\%k == 0$时，我们永远可以得到一个水的体积为`V`的水桶。

而当`V`不是`k`的整数倍时，`V`中$V\%k$这一部分肯定能够从其它桶凑出。只有此时能够得到一个体积为`V`的水桶。

然后我们便需要算出是否有几个水桶水量的和能够与`V`同余。这里我们需要用到简单的动态规划(但我还是把它忘了。。。)。使用`dp[i][j]`记录到第`i`个数是否能取到同余`k`为`j`的值。

最后只要输出移动方法就行了。因为改题目非固定答案，所以我们可以"套模板",即使用麻烦但是能够达成效果的方法进行移动。

我们可以使用一个`flag[i][j]`来记录在到达位置`i`且`%k==j`时是否取了`i`这个位置的数。

然后我们把所有取了的数移到一个位置`x`，没有取的移到一个位置`y`,再用`y`把`x`中的水加至体积为`V`便可以了。
### 结论

#### 判断

1. $sum < V$时: NO
2. $sum\%k==0$时: YES
3. $ \exists S$使得$ \sum _ {i \in S}{v[i]} \equiv V(\ mod\ k)$: YES
4. Otherwise: NO

> ($S$为取出的数的下标的集合)
> 
> 第2中情况其实可以直接被第三种情况包括，只要初始从`dp[0][0] = true`开始即可。

#### DP
我们使用`dp[i][j]`来表示到第`i`个数时能否有取法`S`使得$\sum_{ i \in S}{v[i]} \equiv V (\ mod\ k)$。那么转移方程如下:

$ dp[i][j] = dp[i-1][j]\ || \ dp[i-1][Mod(j-v[i],k)] $

其中或运算符左边的是不取当前数值的情况，右边是取当前数值的情况。

> 这里使用自己写的`Mod()`函数是为了防止`CPP`的`%`算出负值。
> 
> 在`f[i][Mod(j-v[i],k)]`为`True`时`flag[i][j]`为`True`

## 代码
```C++
#include <cstdio>
#include <cstring>

bool dp[5010][5010];
bool flag[5010][5010];
int v[5010];

int Mod(int a,int b)
{
	while (a<0)
		a += b;

	return a%b;
}

int main()
{
	memset(dp,false,sizeof(dp));
	memset(flag,false,sizeof(flag));

	int n,k,V,sum = 0;
	scanf("%d%d%d",&n,&k,&V);

	for (int i =1; i<=n; i++)
	{
		scanf("%d",&v[i]);
		sum += v[i];
	}

	if (sum<V)				//sum<V时输出NO
	{
		printf("NO\n");
		return 0;
	}

	dp[0][0] = true;			//初始值
	for (int i = 1; i<=n; i++)
		for (int j = 0; j<k; j++)
		{
			if (dp[i-1][j])				//当前数值不取的情况
				dp[i][j] = true;
			else if (dp[i-1][Mod(j-v[i],k)])		//取当前数值的情况
			{
				dp[i][j] = true;
				flag[i][j] = true;
			}
		}
	/*
	for (int i = 1; i<=n; i++)
	{
		for (int j = 0; j<k; j++)
			printf("%d ",dp[i][j]);
		printf("\n");
	}
	*/
	if (dp[n][V%k])
	{
		printf("YES\n");

		int t1=0,t2=0;	//分别代表取了的数和没取的数转移到的位置

		int j = V%k,i=n;
		while(i>0)
		{
			if (v[i]==0)
			{
				i--;
				continue;
			}
			if (flag[i][j])
			{
				j = Mod(j-v[i],k);
				if (!t1)
					t1 = i;
				else{
					printf("%d %d %d\n",(v[i]+k-1)/k,i,t1);
					v[t1] += v[i];
					v[i] = 0;
				}
			}else{
				if (!t2)
					t2 = i;
				else{
					printf("%d %d %d\n",(v[i]+k-1)/k,i,t2);
					v[t2] += v[i];
					v[i] = 0;
				}
			}
			i--;
		}

		if (V%k==0 && V!=0)
		{
			if (t2!=1)	t1=1;
			else t1 = 2;
			printf("%d %d %d\n",V/k,t2,t1);
		}
		else if (t1 && V!=v[t1])
		{
			if (!t2)
			{
				if (t1==1)	t2=2;
				else t2 = 1;
			}
			if (v[t1]<V)
				printf("%d %d %d\n",(V-v[t1])/k,t2,t1);
			else printf("%d %d %d\n",(v[t1]-V)/k,t1,t2);
		}

	}else printf("NO");
}
```01postpublish01110d3e1554c51b5280869caceec6160068b{"cid":3,"title":6,"slug":6,"created":10,"modified":10,"text":15,"order":1,"authorId":1,"template":15,"type":4,"status":6,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}136searchsearch15181810201518181102<!--markdown-->21page-search.phppagehidden0111008b50ac13d95082ddc12ba4830a49d6a{"cid":3,"title":8,"slug":8,"created":10,"modified":10,"text":15,"order":1,"authorId":1,"template":16,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}137ArchivesArchives15181811771518181177<!--markdown-->31page-archive.phppagepublish0111014901980230ed73df82cfa4fe5554770{"cid":3,"title":11,"slug":3,"created":10,"modified":10,"text":2780,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}138C#基础--313815182425201518407806<!--markdown--># 控制台I/O，注释，预处理器指令

<!--more-->

参考书籍: 《C#高级编程》

## 控制台I/O

c#中控制台的输入与输出通过`Console`类的几个静态方法实现。

若想要从控制台窗口中读取一行文本，可以使用`Console.ReadLine()`方法，它会从控制台窗口中读入一个输入流(在用户按回车时截止)，并返回输入的字符串。写入常用的有两个方法:`Console.Write()`和`Console.WriteLine()`，后者会在输出结束后加入一个换行符。

另外，`Console.WriteLine`还支持和C中的`printf()`一样的格式化输出。使用格式化输出时，在字符串中用`{`+数字+`}`表示参数，其中数字是从`0`开始的索引。例如下:
```CS
int i = 10;
int j = 20;
Console.WriteLine("{0} plus {1} equals {2}", i, j, i + j);
```
若想要制定宽度，则使用`{`索引`,`宽度`}`的形式。其中宽度为正值表示右对齐，负值表示左对齐。

## 注释
### 内部注释

用法与C和CPP相同，不再赘述。

### XML文档

这是C#中一个比较特别的内容:根据注释自动创建XML格式的文档说明。这些注释必须都是单行注释，而且需以`///`而非`//`开头。在这些注释里面，可以写上包含类型和类型成员的说明。支持的标记与具体写法不再赘述。

此时若想要生成XML文档，则需要在编译时加上`/doc:`选项，并且在后面写上生成的文件名。

## 预处理器指令

> 其实这部分与C和CPP中类似，但是因为我也不常用，所以还是需要写一下。

### \#define和#undef

\#define可以定义一个"变量",而#undef则是删除一个"变量"。如果该"变量"不存在,#undef没有任何意义，#define亦是如此。

### \#if,#elif,#else和#endif

这些指令告诉编译器是否编译某个代码块，通常通过某个变量是否存在来判定，并且支持常用的逻辑运算符如`!=`,`!`,`==`...

### \#warning和#error

当编译器遇到#warning指令时，会显示#warning指令之后的文本，然后继续编译。

而遇到#error指令是，则会显示#error指令只够的文本并停止编译。

通常使用这两个语句结合#if语句来检查是否在编译时是否做错了什么。

### \#region和#endregion

这两个语句可以把一段代码标记为有一个特定名称的块，并不影响编译过程。主要作用是可以通过被编译器识别然后从而令代码在屏幕中更好的布局。

### \#line

\#line用来改变编译器在警告和错误信息中显示的文件名和行号信息，一般并不常用。

#### \#pragma

\#pragma可以一直或还原指定的编译警告(并不明白有什么用(￣▽￣)")。01postpublish01110ecd98ce16132814ffa87e6cb5fad5476{"cid":3,"title":20,"slug":3,"created":10,"modified":10,"text":2027,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}143Robot Vacuum Cleaner14315189445201518944749<!--markdown--># CF 461 D

> 作为D题来说是比较水的了，但是最后因为最后答案用int存不开，所以在比赛时并没有A掉。

<!--more-->

## 题解

题目要求给出指定个由`s`和`h`组成的字符串，怎样将这些字符串排列可以使得`sh`对最多。一个`sh`对存在当且仅当`s`的下标在`h`前。最后只需输出`sh`对的数目即可。

因此，我们可以发现最终的`ans`的求解可以分为两部分:

1. 当`s`和`h`在同一个字符串内时，无论字符串如何排列，其构成的`sh`对的数目不变，所以我们只需在读入时处理出来这些数值即可。

2. 当`s`和`h`不再同一个字符串内时。对于两个字符串`Str1`和`Str2`,其之间产生的`sh`对的数目为$Str1.s \times Str2.h $或$ Str2.s \times Str1.h $(`.s`为字符串中`s`的数目,`.h`亦然)。这样，我们可以通过比较这两个数值的大小来确定`Str1`与`Str2`的顺序。而对于更多数目的字符串，同理。所以我们只需要对所有的字符串按照$ \frac{Str1.s}{Str1.h} $的降序排列即可。

## 代码
```C++
#include <cstdio>
#include <iostream>
#include <algorithm>

char s[100100];

struct Cnt
{
	int s;			//分别代表该字符串中有多少个s和h
	int h;

	const bool operator < (const Cnt& tmp)const{
		return (long long)s*tmp.h > (long long)tmp.s*h;
	}
}cnt[100100];

int main()
{
	long long ans = 0;

	int n;
	scanf("%d",&n);
	for (int j = 0; j<n; j++)
	{
		std::cin >> s;

		cnt[j].s = 0;			//初始化为0
		cnt[j].h = 0;

		for (int i = 0; s[i]!='\0'; i++)
			if (s[i]=='h')
			{
				ans += cnt[j].s;	//h会与该字符串中前面的所有s配对，所以出现h是答案会加cnt[j].s
				cnt[j].h++;
			}else if (s[i]=='s'){
				cnt[j].s++;
			}
	}

	std::sort(cnt,cnt+n);			//排序，令s/h比较大的排在前面

	long long t = 0;
	for (int i = 0; i<n; i++)
	{
		ans += t*cnt[i].h;
		t += cnt[i].s;

	}

	std::cout << ans;
}
```01postpublish01110820a20f93eac874659080347735532f5{"cid":3,"title":14,"slug":3,"created":10,"modified":10,"text":1702,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}158Haskell基础515815204756601520475743<!--markdown--># 递归

> 因为递归本身也很熟悉了，所以不再细讲，主要列几个Haskell中应用递归的函数样例。注意，由于Haskell中用递归来实现循环的功能，所以有些递归看着有些别扭，需要适应。

<!--more-->
参考书籍: [_Learn you a haskell_](http://learnyouahaskell.com/)

## 求数列中最大值
```Haskell
maximum' :: (Ord a) => [a] -> a
maximum' [] = error "maximum of empty list"
maximum' [x] = x
maximum' (x:xs) = max x (maximum' xs)
```

## replicate
> `replicate`取一个整数`x`和一个量`y`，返回一个包含`x`个`y`的列表。

```Haskell
replicate' :: Int -> a -> [a]
replicate' n x
	| n <= 0	= []
    | otherwise = x:replicate' (n-1) x
```

## take
> `take x`可以从列表中取出前`x`个元素，形成另一个列表

```Haskell
take' :: (Num i, Ord i) => i -> [a] -> [a]
take' n _
	| n <= 0 = []
take' _ []	 = []
take' n (x:xs) = x : take' (n-1) xs
```

## reverse
> `reserve`函数取一个列表作为参数，返回反转的列表。

```Haskell
reserve' :: [a] => [a]
reverse' [] = []
reverse' (x:xs) = reverse' xs ++ [x]
```

## zip
> `zip`可以取两个列表为参数，将其中的每个数捆绑在一起，形成一个二元组的列表

```Haskell
zip' :: [a] -> [b] -> [(a,b)]
zip' _ [] = []
zip' [] _ = []
zip' (x:xs) (y:ys) = (x,y) : zip' xs ys
```

## qsort
> 使用递归的方法，我们可以很容易的构造出`qsort`函数--快速排序。

```Haskell
qsort :: (Ord a) => [a] -> [a]
qsort [] = []
qsort (x:xs) = left ++ [x] ++ right
	where left  = qsort [a | a <- xs, a <= x]
    	  right = qsort [a | a <- xs, a > x]
```01postpublish011109613e3d0f50d260600489c75d150ba53{"cid":3,"title":11,"slug":3,"created":10,"modified":10,"text":3387,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}145C#基础--414515196915201520496961<!--markdown--># 数据成员，函数成员

<!--more-->
参考书籍: 《C#高级编程》

## 数据成员

类中可以定义数据成员。默认的情况下，该成员为实例成员，除非使用`static`显式声明。

## 函数成员

### 方法
在C#术语中，函数成员除方法外仍包括类或结构中的一些非数据成员，如索引器，运算符，构造函数和析构函数等，甚至还有属性。所以方法与函数应严格区分。因定义与调用等与CPP相同，所以不再赘述。
#### ref参数
正常情况下，C#中值类型传递的参数为值传递，若是想要使用应用传递，则需在函数定义时的变量前加上`ref`关键字，并且在调用时也许加上，例子如下：
```CS
//定义
static void Inc(ref int x)
{
	x += 1;
    return;
}
----------
//调用
int a = 10;
Inc(ref a);
```
#### out参数
因为在C#中，所有的参数在使用前必须初始化，而当我们想要在函数中传递出一个值时，我们若是使用`ref`来修饰则需要在调用函数前加入一段不必要的初始化，比如：
```
static void Sum(int a,int b,ref int ans)
{
	ans = a + b;
    return;
}
```
当我们调用上面的函数时，因为调用了`ans`参数，所以编译器会要求初始化，但是这段初始化并无意义。所以，C#中加入了`out`修饰符，使得传入的参数可以不初始化，并且始用引用传递。定义与调用方法与`ref`相同。

#### 命名参数

参数需要按照定义的顺序传递给方法。但是也可以使用以下方式：
```CS
static void Minus(int a, int b, out int ans)
{
	ans = a - b;
    return;
}

int x = 10, y = 2;

//以下两个写法等价
Minus(x,y);
Minus(b: y, a: x);
```
### 属性

**属性(property)**的概念是：它是一个方法或一对方法，在客户端代码看来，它(们)是一个字段。

在属性中包含了`get`和`set`访问器。它们都不能包含任何参数。并且`get`必须返回一个类型与属性相同的值，`set`中包含一个名为`value`类型与属性相同的变量。例如下面这个例子包含一个属性`Age`，它设置了一个字段`age`。在这个例子中,`age`是`Age`的后备变量：
```CS
private int age;

public int Age
{
	get
    {
    	return age;
    }
    set
    {
    	age = value;
    }
}
```

#### 只读或只写
只需只写入`set`或`get`函数即可。
#### 属性的访问修饰符
C#允许给属性的`get`和`set`访问其设置不同的访问修饰符，但是必须有一个具备属性的访问级别。
#### 自动实现的属性
如果属性的`set`和`get`访问器中没有任何逻辑，就可以使用自动实现的属性。如之前的代码如下：
```CS
public int Age {get; set; }
```
此时也不需要声明`age`，编译器会自动创建`private`修饰的`age`变量。另外，以下写法亦合法：
```CS
public int Age {get; private ste;}
```
## 构造函数
声明构造函数就是声明一个和类同名的方法类型。
```CS
public class MyClass
{
	public MyClass
    {
    	//Code here
	}
}
```
在构建类时，系统会自动生成一个无参构造函数。构造函数像普通函数一样支持函数重构，但是自己构建完构造函数之后编译器便不会自动生成无参的构造函数了。01postpublish011100a939b4783d72f3527e6409b70d243b7{"cid":3,"title":29,"slug":3,"created":10,"modified":10,"text":1884,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}150消防局的设立[HNOI 2003]15015200634001549800735<!--markdown--># Luogu 2279

> 本来Luogu给的标签是动态规划的，结果我动态规划好长时间都没有做出来。看了一下题解，发现都是贪心。。。。贪心的写法还是比较简单的。

<!--more-->

题目来源: [_Luogu_](https://www.luogu.org/problemnew/show/P2279)

## 题解

我们可以先对每个根节点分析：当我们把一个消防局放在根节点上时，它能够覆盖他的父节点、他的兄弟和他的祖父节点。而当我们把该消防局放在根节点的祖父节点上时，我们可以发现消防局同样可以覆盖这些节点，并且还能覆盖其他的节点。也就是说，这个题目是有局部最优解的，而且很明显的，因为该节点并不会影响其他节点的位置，所以没有后效性。因此我们可以使用贪心算法。

## 代码
```C++
#include <cstdio>
#include <cstring>
#include <queue>

using namespace std;

int fa[1010];
int son[1010][1010];
bool flag[1010];

struct Point{
	int x,depth;
	
	Point(int x,int depth):x(x),depth(depth)	{}

	const bool operator <(const Point& tmp)const{
		return depth<tmp.depth;
	}
};

priority_queue<Point> q;

void dfs(int x,int depth)
{
	q.push(Point(x,depth));
	for (int i = 1; i<=son[x][0]; i++)
		dfs(son[x][i],depth+1);
	return;
}

void fill(int x,int dis)
{
	flag[x] = false;
	if (dis==0)
		return;

	if (x!=1)
		fill(fa[x],dis-1);
	for (int i = 1; i<=son[x][0]; i++)
		fill(son[x][i],dis-1);
	return;
}

int main()
{
	memset(flag,true,sizeof(flag));
	int n;
	scanf("%d",&n);

	for (int i = 2; i<=n; i++)
	{
		scanf("%d",&fa[i]);
		son[ fa[i] ][ ++ son[ fa[i] ][0] ] = i;
	}

	dfs(1,1);

	int ans = 0;
	while (!q.empty())
	{
		Point p = q.top(); q.pop();
		if (flag[p.x])
		{
			ans++;
			fill(fa[fa[p.x]],2);
		}
	}

	printf("%d",ans);
}
```01postpublish0111025f0e2fa043dc7f7e3fd9966cab00369{"cid":3,"title":14,"slug":3,"created":10,"modified":10,"text":3392,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}161Haskell基础616115209447401520944817<!--markdown--># 柯里函数，高阶函数举例

> |\ 最近比较忙，好长时间不写博客了，先写一个Haskell凑个数

<!--more-->

参考书籍: [_Learn you a haskell_](http://learnyouahaskell.com/)

## 柯里函数

本质上，Haskell的所有函数都只有一个参数，我们所见过的所有多参数的函数都是**柯里函数**。柯里函数不会一次性取完所有参数，而是在每次调用时只娶一个参数，并返回一个一元函数来取下一个参数，以此类推。比如`max`函数，我们常如下使用:
```Haskell
ghci> max 4 5
```
此时其实是先将`4`传入`max`函数，组成一个一元函数，然后再传入`5`，也就是说，上面的式子其实为`(max 4) 5`。

那么，这么做的意义何在呢？有了柯里函数，我们便可以以部分参数调用一个函数来得到一个**部分应用(partial application)**。比如我们拥有一个将三数想乘的函数:
```Haskell
multiplyThree :: Int -> Int -> Int -> Int
--类型也可以写成如下形式
multiplyThree :: Int -> (Int -> (Int -> Int))

--我们可以定义一个函数如下
multiplyTwoWithNine = multiplyThree 9

--然后我们便可以如下使用
multiplyTwoWithNine 3 5
```

### 截断

通过截断，我们也能够对中缀函数进行部分应用。将一个参数放在中缀函数的一侧，并在外面用括号括起，便可以截断这个中缀函数，得到一个一元函数。如下:
```Haskell
divideByTen :: (floating a) => a -> a
divideByTen = (/10)
```
唯一需要注意的是(-4)，虽然我们可能认为它是`-`运算符的截断，但是为了方便起见，Haskell会把它认为是负4，所以我们应该使用(substract 4)。

## 高阶函数举例
高阶函数指的是可以将函数作为传入参数和返回值的函数，很明显，Haskell中的函数都为高阶函数。现在，我们写一个函数，他能够取一个函数，并针对某个值应用两次:
```Haskell
applyTwice :: (a -> a) -> a -> a
applyTwice f x = f (f x)
```
注意，我们在这里`applyTwice`的声明中用到了括号，这表明我们传入的是一个`(a -> a)`类型(即一元函数)而非两个`a`类型。否则我们调用`applyTwice f x`时编译器会认为我们想要传入的是两个`a`类型的常量，返回了一个`a -> a`类型的函数。

借助部分应用与高阶函数，我们可以轻松实现以下函数:
```Haskell
ghci> applyTwice ("HAHA " ++) "HEY"
"HAHA HAHA HEY"
ghci> applyTwice (multThree 2 2) 9
144
```
### 实现zipWith

为了举几个常用的高阶函数的例子，我们来是新一下在Haskell中常用的一个高阶函数`zipWith`。它取一个二元函数和两个列表作为参数，对这两个列表中对应的元素调用该二元函数，最终返回一个列表。
```Haskell
zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith' _ [] _ = []
zipWith' _ _ [] = []
wipWith' f (x:xs) (y:ys) = f x y : zipWith' xs ys
```

### 实现flip

接下来实现标准库中的另一个函数`flip`。`flip`函数去一个函数作为参数，返回一个效果相同的函数。两个函数不同的地方在于函数的前两个参数的位置发生了颠倒。
```Haskell
flip' :: (a -> b -> c) -> (b -> a -> c)
flip' f = g
	where g x y = f y x
--或者使用如下写法
flip' g y x = f x y
```
01postpublish011100218a2e19656608dc0c9b23e78882b64{"cid":3,"title":14,"slug":3,"created":10,"modified":10,"text":5165,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}148Haskell基础414815198883201520475735<!--markdown--># where,let,case

<!--more-->
参考书籍: [_Learn you a haskell_](http://learnyouahaskell.com/)

## where

### 用法

在编程时，我们希望避免重复计算同一个值，但我们也都知道，在Haskell中并不存在变量，那我们一般怎么存储呢？`where`便是我们常用的关键字。比如，我们现在实现一个计算语数英三科分数之和并判断等级的函数:
```Haskell
judge :: Int -> String
judge chinese math english
    | score<180 = "You got a D, foolish!"
    | score<225 = "You got a C!"
    | score<255 = "You got a B,not bad!"
    | score<=300 = "Congratulation, you got an A!"
    | otherwise = "Error score!"
	where score = chinese + math + english
```
也就是说，我们可以将`where`关键字放在哨位后面，并在后面提前将算出来的数赋值给另一个常量，这样便可以避免重复计算了。另外，`where`后可以写多个表达式，只需让它们在同一列就好了，如下:
```Haskell
judge :: Int -> String
judge chinese math english
    | score<bad = "You got a D, foolish!"
    | score<fine = "You got a C!"
    | score<good = "You got a B,not bad!"
    | score<=great = "Congratulation, you got an A!"
    | otherwise = "Error score!"
	where score = chinese + math + english
    	  great = 300
          good = 255
          fine = 225
          bad = 180
```

### 作用域

函数的`where`部分中定义的名字只对本函数可见，因此不需担心其污染其他函数的命名空间。但是，在模式匹配时`where`部分中定义的名字只在当前模式中可用，在函数的其他模式中不可用。

### where中的模式匹配

在`where`中，我们也可以使用模式匹配来绑定，如之前的内容:
```Haskell
......
	...
	where score = chinese + math + english
    	  (great, good, fine, bad) = (300, 255, 225, 180)
```
再比如，我们实现一个简单的函数，来告诉我们名字的首字母:
```Haskell
initials :: String -> String -> String
initials firstname lastname = [f] ++ "." ++ [l] ++ "."
	where (f:_) = firstname
    	  (l:_) = lastname
```

### where中的函数

在`where`部分中，我们也可以定义函数，譬如我们定义一个函数，它可以取一个由三科成绩的元组组成的列表，并返回总分:
```
judge :: [(Int,Int,Int)] -> [Int]
judge xs = [ add a b c | (a,b,c) <- xs]
	where add a b c = a + b + c
```

## let

### 用法
`let`和`where`很相似。`where`允许我们在函数底部绑定变量，而`let`则允许在任何地方定义局部变量。其用法为`let <bindings> in <expressions>`，`let`中绑定的名字仅对`in`中可见。例如:
```Haskell
average :: Int -> Int -> Int -> Int
average x y z =
	let sum = x + y + z
    in	sum/3
```
其看上去与`where`差不多，但是`let`本身是一个表达式，意味着其有返回值，因此它可以实现以下操作:
```Haskell
ghci> 4 * (let a = 9 in a + 1) + 2
42
```
以下是几个常见用法:
```Haskell
---在局部作用域中定义函数
ghci> [let square x = x * x in (square 5, square 3, square 2)]
[(25, 9, 4)]
---当一行需要绑定多个名字是，用;进行分开
ghci> [let a = 100; b = 200; c = 300 in a*b*c, let foo="Hey "; bar = "there!" in foo ++ bar)
(6000000, "Hey there!")
---结合模式匹配从元组中取出数值
ghci> (let (a, b, c) = (1, 2, 3) in a + b + c) * 100
600
```

### 列表推导式中的let

还是之前计算总成绩的函数，使用`let`写法如下:
```Haskell
judge :: [(Int, Int, Int)] -> [Int]
judge xs = [ sum | (a, b, c) <- xs, let sum = a + b + c]
```

### ghci中的let

直接在ghci中定义函数和常量是，let的in部分可以省略。如果省略，名字的定义将会在整个绘画过程中可见。

## case

### 用法

Haskell中的`case`与其他语言中的类似，能够取一个变量，根据不同的值选择代码块执行。在Haskell中，这与模式匹配类似，实际上，模式匹配本质上便是`case`的语法糖。例如，以下两段代码是完全等价的:
```Haskell
head' :: [a] -> a
head' [] = error "No head for empty lists!"
head' (x:_) = x
---
head' :: [a] -> a
head' xs = case xs of [] -> error "No head for empty lists"
					  (x:_) -> x
```
`case`表达式的结构如下:
```Haskell
case expression of pattern -> result
				   pattern -> result
                   pattern -> result
                   ...
```
此外,`case`的使用十分灵活，可以在任何地方使用。比如，可以在表达式中套用它，来执行模式匹配，其与直接使用模式匹配是等价的。
```Haskell
describeList :: [a] -> String
describeList ls = "The list is " ++ case ls of [] -> "empty."
											   [x] -> "a singleton list."
                                               xs -> "a longer list."
                                               
---

describeList :: [a] -> String
describeList ls = "The list is " ++ what ls
	where what [] = "empty."
    	  what [x] = "a singleton list."
          what xs = "a longer list."
```01postpublish011100b4fdf7c05702d843345bf18d45a8a8d{"cid":3,"title":12,"slug":3,"created":10,"modified":10,"text":2665,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}154垃圾陷阱15415200681221520068136<!--markdown--># Luogu 1156

> 这题还算是比较简单，看着便有些思路。感觉和背包问题比较像。

<!--more-->

题目来源: [_Luogu_](https://www.luogu.org/problemnew/show/P1156)

## 题解

由题目可得，我们想要到达的最终状态是高度为0，而这个过程中我们需要确保生命值大于0。也就是说，这道题目中存在的分支是吃掉垃圾(增加生命值)还是堆垃圾(增加高度)。而类比于背包问题，我们使用`dp[i][j]=k`来存储状态。其中`i`,`j`,`k`分别为高度，当前为第几个垃圾，生命值。

明显可以看出，在同一高度时生命值越高越好。所以，我们便可以大致得出以下的状态转移方程:

$ dp[i][j] = Max(\ dp[i][j] + f[j],\ dp[i-h[j]][j]) $

> 在这里，我们假设`t[j]`,`f[j]`,`h[j]`分别为垃圾的放入时间，所加生命值，高度。

注意，上述方程中分别代表吃垃圾和堆垃圾两种选择，而这两种选择必须是基于原本奶牛是存活的状态下才能执行，所以对于左右的两个式子，必须分别要求$dp[i][j] \geq t[j]$和$dp[i-h[j]][j] \geq t[j]$才能成立。

因为该方程与背包较为相似，所以我们也能发现该数组可以改为只包含高度的一位数组，最后在循环体内只要令高度的循环从高到低就好了。

## 代码
```C++
#include <cstdio>
#include <algorithm>
#include <cstring>

int dp[110];			//采用类似背包的优化方法，优化为一位数组

struct Garbage 			//存储有关垃圾的数据
{
	int t,f,h;

	const bool operator <(const Garbage& tmp)const{
		return t<tmp.t;			//按照t(时间)排序
	}
}garbage[110];

int main()
{
	memset(dp, 0, sizeof(0));
	int d,g;
	scanf("%d%d", &d, &g);

	for (int i=1; i<=g; i++)
		scanf("%d%d%d", &garbage[i].t, &garbage[i].f, &garbage[i].h);

	std::sort(garbage,garbage+1+g);

	dp[0] = 10;
	for (int i = 1; i<=g; i++)
	{
		for (int j = d; j>=0; j--)
		{
			if ( dp[j] >= garbage[i].t )		//首先如果本来能够到达该高度，则吃下该垃圾
				dp[j] += garbage[i].f;
			if ( j - garbage[i].h >= 0 && dp[ j - garbage[i].h ] >= garbage[i].t )		//比较吃垃圾与堆放垃圾谁剩余生命值最大
				dp[j] = std::max(dp[j], dp[ j - garbage[i].h ]);
		}
		
		if (dp[d]>0)			//如果到达了高度d，则立刻退出
		{
			printf("%d",garbage[i].t);
			return 0;
		}
	}

	//能够运行到这里说明奶牛出不来，然后直接模拟就好了
	int last = 10;
	for (int i = 1; i<=g; i++)
		if ( garbage[i].t <= last )
			last += garbage[i].f;

	printf("%d",last);
	return 0;
}
```01postpublish0111047035002f5b4951e98326df88ee104ef{"cid":3,"title":18,"slug":3,"created":10,"modified":10,"text":869,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}160大一下第三周16015209310301520931041<!--markdown-->
# 2018 3 13

<!--more-->

又是难得一遇的日记时间了(笑)。最近的事情比较多，也没有来得及更博客。因为申请加了威软实验室，结果要做一个五子棋的程序。而且大一年度项目还没有头绪，时间却已经过去一半多了。ACM的课程也算是开了，不过现在人数谜一般的多。。。

不过最近这样的生活才让我真正有了大学的感觉。。。上个学期实在是太~颓废了，最后考的工数成绩也是惨不忍睹。不过即使现在蛮忙的，我还是买了一个xbox手柄。毕竟买了之后还是很开心的，就当是激励自己以下吧。

不过最近学的前后端知识相对偏多，或许这段时间忙完了之后我就能对博客进行一个比较大的改动了，看一下能不能自己做一个主题或者插件什么的。01postprivate0111048e40670ae1bafd97a7eff0814ed7f26{"cid":3,"title":11,"slug":3,"created":10,"modified":10,"text":7957,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}165井字棋AI16515210385201521038603<!--markdown-->> 这是C++大作业中的额外作业，本来没打算做的，结果实验室的纳新试题是做一个五子棋的AI，所以就抱着练练手的目的做了一下这题，结果还挺麻烦的。

<!--more-->

## 刚开始的想法

最初，看到要写这么一个AI，我就立刻涌现出了一个想法: 对棋盘中的每个点根据不同情况赋值，最后按照值的大小来选择该下在哪里，赋值规则如下:

> * 下完此步后立刻胜利	+ 8 分
> * 敌人若下此步则立刻胜利 + 7 分 
> * 中心 + 5 分
> * 四角 + 3 分
> * 四边 + 1 分
>
> 其他： 该棋子旁每多一个己方棋子，则 + 1 分

因为该策略可以说是凭直觉确定的，所以不出意外的，并不能确保AI能够胜利或者平局。比如，下面这种特殊情况:
```
X--      X--      X--      X-O      X-O      X-O      X-O
---  =>  -O-  =>  -O-  =>  -O-  =>  -O-  =>  -O-  =>  XO-  	
---      ---      --X      --X      X-X      XOX      XOX
```

不过对于大多数情况，这个简单的"AI"还是能够应付的，而且代码也较为简短，所以我这里AI的核心代码贴在下面(完整的):
```C++
void TicTacToe::makeAutoMove()                  //robot
{
    int value[3][3] = {{3,1,3},{1,5,1},{3,1,3}};            //set default value of each point
    const int xp[] = {0,0,1,-1};
    const int yp[] = {1,-1,0,0};

    int mx,my,max = 0;

    for (int i = 0; i<3; i++)
        for (int j = 0; j<3; j++)
        {
            for (int k = 0; k<4; k++)
                if (check(i+xp[k],j+yp[k]))
                    value[i][j]++;                  //if there are a out token nearby, value++

            char c = board[i][j];
            board[i][j] = 'X';                  //pretend this point is a 'X'
            if (getWinner() == 'X')             //check could 'X' win
                value[i][j] = 7;

            board[i][j] = 'O';                  //the same as above
            if (getWinner() == 'O')
                value[i][j] = 8;

            board[i][j] = c;                    //set it back

            if (board[i][j]!='-')               //if we couldn't place a token here
                value[i][j] = 0;        

            if (value[i][j] > max)
            {
                max = value[i][j];
                mx = i;
                my = j;
            }
        }

    makeMove(mx,my);                        //put an 'O'
}
```

## 深入分析

那么，我们该怎么写这个AI程序呢？很明显，井字棋作为一个博弈游戏，我们应该通过一个估价函数来决定下一步的策略。而这个估价函数得出的值不应像上面的算法一样直接由当前棋盘决定，而是由其后续状态决定。也就是说，其实对于这一题，我们应该用极大极小值的方法将后续状态的值传递给前一状态。

### 极大极小值

#### 介绍
关于极大极小值，我们在这里阐述一下。很明显，当我们(AI)执子时，AI一定要选择最好的策略，而对于玩家执子时，我们要假设他会选择(对我们而言)最差的策略。因此，当我们想要更新当前的棋盘的价值时，若下一步是AI来下，那么我们完全可以让当前的价值等于后续状态的价值中的最大值，玩家下时则相反，我们应取最小的值。

#### 弊端
不过，对于以上的方法，其实存在一定的弊端，这个程序中也没有解决:在价值传递时会遗失一部分数据。若玩家足够聪明，这遗失的数据并无影响。但是，若玩家可能犯错的话，遗失的数据可能会令AI失去胜利的机会而变成平局。举个例子，在AI选择时，在AI看来胜利概率高的棋局和概率低的棋局是等价的，因此可能不会选择相对更佳的那个。

### 优化

若是我们使用搜索的方法获取下一步策略的价值，每走一步都需要$O(3^9)$的时间，虽然不是特别多，但是其中有大量的重复计算，而很明显的，$3^9 < 20000 $，也就是说，我们可以用预处理的方法将各个状态的棋盘的价值存储起来，从而大幅加快速度(雾。。。。

> PS：这个优化其实并不是特别必要，只是当时估错时间了，认为它很重要。。。。

#### hash

首先，我们要使用一个简单的hash函数来将棋盘的状态转化为整数，这个非常简单，代码如下:
```C++
int TicTacToe::trans()          //using hash to trans the board to a value
{
    int ans = 0;
    for (int i = 0; i<3; i++)
        for (int j = 0; j<3; j++)
        {
            ans *= 3;
            if (board[i][j] == 'X')
                ans += 1;
            else if (board[i][j] == 'O')
                ans += 2;
        }
    return ans;
}
```

#### 预处理

我们要预处理出价值，但是每个状态的价值与其下一价值有关。因此，我们应该按照棋子从多到少枚举棋盘，然后计算价值。

首先，按照棋子从多到少枚举:
```C++
void TicTacToe::robotInit()
{
    for(int i = 0; i<9; i++)
    {
        printf("[*]finished %.2f%%\n", (double)(i+1)*100/9 );
        int nx = (10 - i) /2;
        int no = ( 9 - i) /2;
        dfs(0,0,nx,no,i);
    }
}
```

#### 生成棋盘

枚举棋子数时，我们使用`dfs()`函数来生成棋盘并更新价值。其传入的参数分别为`x`坐标,`y`坐标，可下的`X`棋子数量，可下的`O`棋子数量，空格数量。

我们分别枚举`X`,`O`和`-`(代表空)，然后判断是否可以下这种棋子，递归调用，直到棋盘满为止。其中，判断条件如下:
> $nx>0$: `X`可下
> 
> $no>0$: `O`可下
>
> $x+y+nx+no<9: `-`可下

> PS:这里的`x`与`y`都是$0~2$

到达最终状态时，判断当前棋盘是否能得出结局，若可以，直接按赢+100分，输-100分，平0分赋值，若不是，则采用最大最小值的方法依照其后续状态更改他的价值。

代码写的很乱，如下:
```C++

void TicTacToe::dfs(int x,int y,int nx,int no,int blank)        //get all the possible board, and get their value
{

    if (y>2)
    {
        x ++;
        y = 0;
    }

    if (x>2)
    {
        if (getWinner()!='-')
        {
            char m = getWinner();

            if (m == 'O')
                value[trans()] = 100;
            else if (m == 'X')
                value[trans()] = -100;
            else if (m == 'V')
                value[trans()] = 0;
            else if (m == '-')
                printf("Error!"); 
        }
        else
        {
            int v = trans();
            value[v] = INF;

            for (int i = 0; i<3; i++)
                for (int j = 0; j<3; j++)
                    if (board[i][j]=='-')
                    {

                        if (blank%2)
                            board[i][j] = 'X';
                        else board[i][j] = 'O';
                        
                        if (value[v] == INF)
                        {
                            value[v] = value[trans()];
                        }
                        else if (blank%2==1)
                            value[v] = std::min(value[trans()],value[v]);           //enemy will choose the step which has the lowest value
                        else value[v] = std::max(value[trans()],value[v]);          //AI will choose the step which has the highest value

                        board[i][j] = '-';
                    }
        }

        return;
    }

    if (nx>0)
    {
        board[x][y] = 'X';
        dfs(x,y+1,nx-1,no,blank);
    }
    if (no>0)
    {
        board[x][y] = 'O';
        dfs(x,y+1,nx,no-1,blank);
    }
    if ( x*3+y + nx + no < 9)
    {
        board[x][y] = '-';
        dfs(x,y+1,nx,no,blank);
    }

    return;
}
```
01postpublish21110f1aa7a13249be97a0cd26ececf739e2c{"cid":3,"title":27,"slug":3,"created":10,"modified":10,"text":1789,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}167冬马和纱的博弈游戏16715238803001524988281<!--markdown--># HITwh OJ 41

<!--more-->

题目来源: [_HITwh OJ_](http://10.245.130.74:81/problem/41/)

## 思路

首先，我们知道，该题目的最终答案与$\%3$后的数值有关，所以我们可以得知，对于读入的每一个数，我们对其$\%3$后不影响其数值。

此外，我们可以明显的得出，$\%3$后相同的数值具有相同的属性，所以我们总共只有三种数值$0,1,2$。

### 冬马和纱的角度

那么，我们从冬马和纱的角度来思考问题。我们假设当前的差$\%3$为$0$，那么此时无论小木曽雪菜选什么，冬马和纱都选择和她一样的，从而使差一直为$0$。因此，若小木曽雪菜先开始，且可以$1,2$的个数都是偶数，冬马和纱一定能胜利。

而若是冬马和纱先开始时，我们发现，若是有$\%3=0$的数，则我们可以通过先选择$0$从而使问题变成如上的问题。若是没有的话，我们假设随便选择一个数$x(x\in {1,2})$，然后继续按照上述方案行事的话，若原来$1,2$的个数都为偶数的话，最后一定会剩下一个最开始我们选择的数，并且轮到小木曽雪菜选择，从而使差便为$0$。

因此，答案很显然了:

\[ Ans = \left\{ \begin{aligned} &Touma Kazusa  &,\ &num[1]\%2==0 && num[2]\%2==0	\\ &Ogiso Setsuna &,\ &otherwise \end{aligned} \right.\]

## 代码

```C++
#include <cstdio>

int a[300];

int main()
{
	int T;
	scanf("%d",&T);
	while (T--)
	{
		int n,f;
		scanf("%d%d",&n,&f);

		int num[3];
		num[0] = num[1] = num[2] = 0;

		for (int i = 1; i<=n; i++)
		{
			scanf("%d",&a[i]);
			num[a[i]%3]++;
		}
		if (num[1]%2==0 && num[2]%2==0)
			printf("Touma Kazusa\n");
		else printf("Ogiso Setsuna\n");
	}
}
```01postpublish01110d8ce9ed86c80bee9f33a99393d554e34{"cid":3,"title":21,"slug":3,"created":10,"modified":10,"text":1627,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}170世界线修复计划17015238813801528889720<!--markdown--># HITwh OJ 43

<!--more-->

题目来源: [_HITwh OJ_](http://10.245.130.74:81/problem/43/)

## 思路

其实总体而言，是一个比较水的题目。题目要求将一个树分割为两个子树，并且两个子树的各点权值之和的差最小。

很明显，我们可以在建树过程中直接记录以每一个节点为根节点的子树的权值和，然后再枚举一边，找到和所有节点的总权值的一半最为接近的即可。

## 代码

```C++
#include <cstdio>
#include <iostream>

struct Edge
{
	int from,to,next;
	Edge(int from=0,int to=0,int next=0):from(from),to(to),next(next)	{}
}e[500000];

int f[300000];
long long cnt[300000];
int h[300000];
bool flag[300000];

int build(int x)
{
	flag[x] = true;
	cnt[x] = h[x];

	int v = f[x];
	while (v)
	{
		if (!flag[e[v].to])
			cnt[x] += build(e[v].to);

		v = e[v].next;
	}

	return cnt[x];
}

long long Abs(long long x)
{
	return x>0?x:-x;
}

int main()
{
	int T;
	scanf("%d",&T);

	while (T--)
	{
		int n;
		scanf("%d",&n);

		for (int i = 1; i<=n; i++)
		{
			f[i] = 0;
			flag[i] = false;
		}

		for (int i = 1; i<n; i++)
		{
			int x,y;
			scanf("%d%d",&x,&y);
			e[2*i-1] = Edge(x,y,f[x]);
			f[x] = 2*i - 1;
			e[2*i] = Edge(y,x,f[y]);
			f[y] = 2*i;
		}

		long long sum = 0;
		for (int i = 1; i<=n; i++)
		{
			scanf("%d",&h[i]);
			sum += h[i];
		}

		build(1);

		long long ans = sum;
		for (int i = 1; i<=n; i++)
			if ( Abs(sum-2*cnt[i]) < ans)
				ans = Abs(sum-2*cnt[i]);

		std::cout << ans << std::endl;
	}
}
```

01postpublish01110e34fae9143ad27978cf070e9d3fad514{"cid":3,"title":9,"slug":3,"created":10,"modified":10,"text":3041,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}173Fireworks17315249878401528889709<!--markdown--># ACM SD 2017 C

> 好像是除了签到题外最水的一题 ，做题时思路还算是清晰，但是第一次做时想错了。

<!--more-->

题目来源: [_sdibt_](http://acm.sdibt.edu.cn/JudgeOnline/problem.php?id=3265)

## 分析

题目给出了`n`个点，然后每秒钟每个点会分裂为两个点，分别移动到其左边和右边。即对于第`t`秒时存在一个点的位置为`x`，那么在`t+1`秒时便存在两个由其分裂出来的点在`x-1,x+1`。由此，我们可以得出对于一个点衍生出的所有的点的位置分布图，大致如下：
```
					1
                  1 0 1
                1 0 2 0 1
              1 0 3 0 3 0 1
            1 0 4 0 6 0 4 0 1
            	 ......
```

由此，我们可以看出其存在的规律--将其中的`0`全部去掉之后，其分布便为一个杨辉三角，即下图：
```
					1
                   1 1
                  1 2 1
                 1 3 3 1
                1 4 6 4 1
                 ......
```

而题目要求给出了`n`个点的初始位置和各自的数量之后，能够计算得出在`T`秒之后在位置`w`处的点的总数。

因此，我们可以对于每一个初始的点与`w`之间进行判断，得出由此点衍生出的图中`w`是否为`0`，若不为`0`则将根据坐标，将其化为一个求组合数的问题。

## 结论

\[[ Ans = \sum_{i=1}^n cnt(i) \]]


$$ cnt(i) = \left\{
\begin{aligned}
&0  &,  abs(w-x) > T	\\
&0  &,  odd(w-x-T)		\\
&C(n,m) &,even(w-x-T)  
\end{aligned}
\right.$$

\[[ (n=T,m=abs(w-x+t)/2) \]]

## 代码
```C++
#include <cstdio>

#define MOD 1000000007

long long a[100001];

struct FireWork
{
	int num,x;

	FireWork(int x=0,int num=1):x(x),num(num)	{}
}fire[100100];

long long abs(long long x)
{
	return x>0?x:-x;
}

void exgcd(long long a,long long b,long long &x,long long &y){
    if (b==0){
        x=1,y=0;
        return;
    }
    exgcd(b,a%b,y,x);
    y-=a/b*x;
}

long long getInverse(long long x,long long y){
    long long res,tmp;
    exgcd(x,y,res,tmp);
    return (res+y)%y;
}

long long C(long long n,long long m,long long p){//C(n,m)%p 
    
    long long tmp1=getInverse(a[m],p);
    tmp1=a[n]*tmp1%p;
    long long tmp2=getInverse(a[n-m],p);
    return tmp1*tmp2%p;
}

long long cnt(int x,int w,int t)
{
	long long dis = abs(x-w);

	if (dis > t)
		return 0;
	if ( (t-dis)%2 == 1)
		return 0;

	dis = dis/2;
	dis += (t+1)/2;
	dis = t - dis;

	//printf("!%lld %d %lld\n",dis,t,C(dis,t,MOD));

	return C(t,dis,MOD);
}

int main()
{
	int n,t,w;

	a[0] = 1;
	for (int i = 1; i<=100000; i++)
		a[i] = a[i-1]*i % MOD;

	while (scanf("%d%d%d",&n,&t,&w)!=EOF)
	{
		for (int i = 0; i<n; i++)
		{
			int x,y;
			scanf("%d%d",&x,&y);
			fire[i] = FireWork(x,y);
		}

		long long ans = 0;
		for (int i = 0; i<n; i++)
			{
				ans += fire[i].num*cnt(fire[i].x,w,t);
				ans %= MOD;
			}

		printf("%lld\n",ans%MOD);

	}
}
```01postpublish011106402fbda06884f18c5b99731c6f6d757{"cid":3,"title":14,"slug":3,"created":10,"modified":10,"text":2313,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}172Haskell基础717215249859201528889715<!--markdown--># map与filter函数

> 快两个月没有更Haskell了，最近也一直没有学。现在劳动节放假，趁有时间更一些。

<!--more-->

参考书籍: [_Learn you a Haskell_](http://learnyouahaskell.com/)

## map

`map`取一个函数和一个列表作为参数，它会将这个函数应用到这个列表中的每个元素，产生一个新的列表。下面为它的定义:
```Haskell
map :: (a -> b) -> [a] -> [b]
map _ [] = []
map f (x:xs) = f x : map f xs
```

以下为它的几个用法举例:
```Haskell
ghci> map (+3) [1,5,3,1,6]
[4,8,6,4,9]
ghci> map (++ "!") ("BIFF","BANG","POW"]
["BIFF!","BANG!","POW!"]
ghci> map (replicate 3) [3..6]
[[3,3,3],[4,4,4],[5,5,5],[6,6,6]]
ghci> map fst [(1,2),(3,5),(6,3),(2,6),(2,5)]
[1,3,6,2,2]
```

## filter
`filter`函数取一个谓词(preddicate)和一个列表，返回有列表中所有符合该条件的元素组成的列表(谓词指的是返回布尔值的函数)。其实现大致如下:
```Haskell
filter :: (a -> Bool) -> [a] -> [a]
filter _ [] = []
filter p (x:xs)
	| p x       = x : filter p xs
    | otherwise = filter p xs 
```

下面是一些相关的示例:
```Haskell
ghci> filter even [1..10]
[2,4,6,8,10]
ghci> let notNull x = not (null x) in filter notNull [[1,2,3],[],[3,4,5],[2,2],[],[],[]]
[[1,2,3],[3,4,5],[2,2]]
ghci> filter ('elem' ['a'..'z']) "u LaUgH aT mE BeCaUsE I aM diFfeRent"
"uagameasadifeent"
```

此外，我们还可以使用`filter`实现之前的快速排序:
```Haskell
quicksort :: (Ord a) => [a] -> [a]
quicksort [] = []
quicksort (x:xs) =
	let smallerOrEqual = filter (<= x) xs
        larger = filter (> x) xs
    in quicksort smallerOrEqual ++ [x] ++ quicksort larger
```

## takeWhile

`takeWhile`函数取一个谓词和一个列表作为参数，然后从头开始遍历列表，然后一旦遇到不符合条件的元素，它就会停止执行，并返回结果列表。其实现大致如下:
```Haskell
takeWhile :: (a -> Bool) -> [a] -> [a]
takeWhile _ [] = []
takeWhile f (x:xs)
	| f x       = f x : takeWhile f xs
    | otherwise = []
```

其示例用法:
```Haskell
ghci> takeWhile (/=' ')"elephants know how to party"
"elephants"
ghci> sum (takeWhile (<10000) (filter odd (map (^2) [1..] )))
166650
```01postpublish011103fbeadaa24c29231c1556c7424ed3d1a{"cid":3,"title":37,"slug":3,"created":10,"modified":10,"text":1647,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}183记在2018年山东省ACM省赛之后18315257041311525704161<!--markdown--># 2018 5 7

<!--more-->

真的是突然之间迎来了ACM的省赛。一次校赛后突然要求我找两个人组队，然后我在见都没见过的前提下钦定(雾)了两个看起来还熟悉的人做了队友，然后隔了18天就迎来了山东省的省赛。

这次比赛，emmm，怎么说呢，发挥的不算理想。比赛前的热身赛时抱着队友的大腿拿到了28名，当时感觉已经稳了。。。目标定为了“保银冲金”，emmmmm。然后，第二天就螺旋爆炸。。。。

比赛刚开始时，因为安排的还可以，我们队很快就发现了C题是水题，然后很快就A掉了。之后队友又思考了一番，A掉了A题。此时，我们发现了F题通过率较高，然后便开始钻研F题。。。。。期间队友给我讲了一下nimm博弈(雾，然后我现学现卖的把G题给A了出来。这时候比赛已经两个小时了。然后，，，我们开始杠F题。。。。然后，，，就没有然后了。。。。。

比赛后发现F题没有数据，交了就能过(excuse me?!)然而我交了一发WA了。。。。。心态十分爆炸，感觉已经要打铁了。结果因为手速还算凑合，以65名的成绩拿到了银牌。。。。。感觉。。人生的大起大落不过如此。。。。。。

作为队长（应该是吧），说实话，这次比赛中我的心态还是太不稳定了，最后一个小时心态十分爆炸。。。简直什么都想不下去。果然还是要调整一下。而且这次比赛可以看出我们队的知识面还是普遍太窄了，还是需要找时间多学习一下新的内容。01postpublish01110148e352496752414fa3800cc0a2bba45{"cid":3,"title":18,"slug":3,"created":10,"modified":10,"text":1405,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}185Find The Multiple 18515287718001528889699<!--markdown--># POJ 1426

> | 最近一个多月没有更新过博客了。。。虽然上个月做题的题量还不算太少，但是都没有写博客。最近这两周考试有比较多，而我又比较懒，所以一直耽搁下来了。今天可能会把以前做过的题目整理一下，多发几个博客。题目难度可能不一，因为最近做的难题不是很多。

<!--more-->

题目来源： [_vjudge_](https://vjudge.net/contest/231087#problem/E) | [POJ](http://poj.org/problem?id=1426)

## 分析

这个题目其实可以算是个水题了，要求输入一个数，然后算出其最小的只包含0和1的倍数。其实就是一个暴力搜索的题目，只要搜索的时候只搜索包含0，1的数的情况便可。

## 代码

```C++
#include <cstdio>
#include <algorithm>
#include <iostream>

unsigned long long ans;

unsigned long long find(unsigned long long x,int n,int depth)
{
	if (depth>19)
		return 0;

	if (x%n==0)
	{
		//if (x<10000000)
		//	std::cout << "!" << x << " " << x%n << std::endl; 
		return x;
	}

	unsigned long long ans1 = find(x*10,n,depth+1);
	if (ans1)
		return ans1;
	unsigned long long ans2 = find(x*10+1,n,depth+1);
	if (ans2)
		return ans2;
	return 0;
}

int main()
{
	int n;
	scanf("%d",&n);
	while (n!=0)
	{		
		std::cout << find(1,n,0) << std::endl;

		scanf("%d",&n);
	}
}
```


01postpublish011101fad7eb9069ae13a5c2fd46413bc1ac1{"cid":3,"title":10,"slug":3,"created":10,"modified":10,"text":1653,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}187Prime Path18715287725201528889690<!--markdown--># POJ 3126

> | 这道题也可以算是道水题吧。搜索加上求素数，这里用的是线性筛。

<!--more-->

题目来源: [_vjudge_](https://vjudge.net/contest/231087#problem/F) | [POJ](http://poj.org/problem?id=3126)

## 分析

题目要求很简单，给定一个起点和终点，要求用最短的步数到达。每改变一个数算作一步，并且在改变后要求仍然为素数。所以先算出所有素数，然后进行暴力BFS即可。

## 代码

```C++
#include <iostream>
#include <queue>
#include <cstring>

using namespace std;

bool prime[10100];
int dist[10100];
int n;

void Prime()
{
	for (int i = 1; i<=10000; i++)
		prime[i] = true;

	prime[1] = false;
	prime[2] = prime[3] = true;
	for (int i = 2; i<=100; i++)
		if (prime[i])
		{
			int j = i*i;
			while (j<=10000)
			{
				prime[j] = false;
				j += i;
			}
		}
	return;
}

queue<int> q;
int main()
{
	Prime();

	cin >> n;
	for (int k = 1; k<=n; k++)
	{
		memset(dist,0,sizeof(dist));

		int x,y;
		cin >> x >> y;
		
		q = queue<int>();
		dist[x] = 1;
		q.push(x);
		while (!q.empty())
		{
			int v = q.front();	q.pop();
			//printf("!%d %d\n",v,dist[v]);

			if (v==y)
				break;

			int t = 1;
			for (int i = 0; i<4; i++)
			{
				for (int j = 0; j<=9; j++)
				{
					int z;
					if (t==1)
						z = v/(t*10)*(t*10) + t*j;
					else z = v/(t*10)*(t*10) + t*j + v%t;
					
					if (dist[z]==0 && prime[z] && z>=1000)
					{
						dist[z] = dist[v] + 1;
						q.push(z);
					}
				}

				t *= 10;
			}
		}
	
		cout << dist[y]-1 << endl;
	}
}
```
01postpublish01110b9d4d63766abea1a0d5def144289fe2a{"cid":3,"title":15,"slug":3,"created":10,"modified":10,"text":5762,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}188字符串匹配18815288011401528898093<!--markdown--># Code[VS] 1404

> | 本来以为是一个标准的KMP模板题，结果写着写着才发现这道题的重点在别处。用到了KMP算法，但是最重要的还是考验思维能力。

<!--more-->

题目来源: [_code\[VS\]_](http://codevs.cn/problem/1404/)

## 分析

> 注意：正确的算法请直接跳转到后面的**进一步分析**，此处为TLE代码分析。

题目要求对于给定的`x`，输出字符串`b`在字符串`a`中匹配长度恰为`x`的数目。这道题我本来时打算当作KMP的模板题来做，于是我就先写好了KMP算法，然后准备在其基础上更改。

KMP算法写好后，我们首先可以想到的是失配时，此时满足题目的条件。我们可以在KMP匹配时使用一个数组`ans[i]`来记录匹配长度恰为`i`的数量。所以，我们可以将匹配常数更改如下：

```C++
void KMP()
{
	int j = 0;
	for (int i = 0; i<a.length(); i++)
	{
		while (j && a[i]!=b[j])
		{
			ans[j] ++;
			j = fail[j];
		}

		if (a[i]==b[j])
			j++;
	}
}
```

我们进一步思考，会发现$j==0$时会无法执行`ans[j]++`操作，所以可以在`if`语句前加上一句

```C++
if (a[i]!=b[0])
	ans[0]++;
```

此外，我们发现并不是所有的恰好长度的匹配都会被我们发现，譬如当我们匹配`ababcc`(字符串`a`)和`ababc`(字符串`b`)时，我们应该能够匹配到`a`串的第`3,4`个字符与`b`串的前两个字符，然后`ans[2]++`。但是实际上因为`ababcc`的前五个字符都与`b`串匹配，所以我们无法通过失配函数回到`b`串只走了两个字符的情况。所以我们还可以加上一下代码来匹配所有长度：

```C++
int k = j;
while (k)
{
    if (b[k]!=a[i])
        ans[k]++;
    k = fail[k];
}
```

最后，我们发现匹配结束时需要特殊处理，否则可能会漏掉两个字符串最后一个字符相同的情况。所以说在KMP匹配的`for`循环后需要加上如下几句：

```C++
while (j)
{
    ans[j]++;
    j = fail[j];
}
```

完成了以上几步后，代码便大致完成了，然而，由于多嵌套了一个while循环，所以最后T了两组数据，代码如下。

## 80分代码（TLE）

```C++
#include <iostream>
#include <string>

using namespace std;

int ans[200100];
int fail[200100];
int cnt[200100];
string a,b;

void pre()
{
    for (int i = 1; i<b.length(); i++)
    {
        int j = fail[i];
        while (j && b[i]!=b[j])
            j = fail[j];
        fail[i+1] = b[i]==b[j]?j+1:0;
    }
}

void KMP()
{
    int j = 0;
    for (int i = 0; i<a.length(); i++)
    {
        if (j==b.length())
        {
            ans[j]++;
            j = fail[j];
        }

        while (j && a[i]!=b[j])
        {
            ans[j] ++;
            j = fail[j];
        }
        
        int k = j;
        while (k)
        {
            if (b[k]!=a[i])
                ans[k]++;
            k = fail[k];
        }
        
        if (a[i]!=b[0])
            ans[0]++;

        if (a[i]==b[j])
            j++;
    }
    while (j)
    {
        ans[j]++;
        j = fail[j];
    }
}

int main()
{
    ios::sync_with_stdio(false);

    int n,m,k;
    cin >> n >> m >> k;

    cin >> a;
    cin >> b;

    pre();

    KMP();

    while (k--)
    {
        int x;
        cin >> x;
        cout << ans[x] << endl;
    }
}
```

## 进一步分析

很明显，之前的算法由于需要嵌套循环，时间复杂度为`O(nm)`,无论如何优化也是不行的。所以，我们应该换一个思路。

我们可以想到，对于一个可以匹配的长度为`k`的串，它存在两种情况：其最长便只能匹配`k`;其还可以向后匹配。而我们想求出的是第一种情况，但是直接求解显然非常复杂。但是如果我们有两种情况的数量总和呢？我们能不能很简单的算出第一种情况呢？

很明显，假设`num[]`存储了能匹配长度`k`的情况的数量，`ans[]`为能且恰好匹配了长度`k`的情况的数量,那么其一定满足下面的公式：

\[[ ans_i = num_i - num_{i+1} \]]

得到了上面的公式，我们便能够把能够匹配长度为`k`的情况一股脑地加载一起就好了，譬如，在KMP函数中，代码如下：

```C++
int j = 0;
for (int i = 0; i<a.length(); i++)
{
	while (j && a[i]!=b[j])
		j = fail[j];

	if (a[i]==b[j])
		j++;
	ans[j] ++;
}
```

而很明显上面并不是全部的情况。譬如我们之前举的`ababcc`与`ababc`的例子。很明显，当我们考虑的是所有大于`k`的情况是，我们可以令所有的$num_{fail_i} = num_{fail_i} + num_i$。所以在主函数里，KMP函数执行后，加入如下代码：

```C++
for (int i = 0; i<b.length(); i++)
	ans[i] -= ans[i+1];
```

最后，代码便大致完成了，最终AC代码如下：

## AC代码

```C++

#include <iostream>
#include <string>

using namespace std;

int ans[200100];
int fail[200100];
bool flag[200100];
string a,b;

void pre()
{
	for (int i = 1; i<b.length(); i++)
	{
		int j = fail[i];
		while (j && b[i]!=b[j])
			j = fail[j];
		fail[i+1] = b[i]==b[j]?j+1:0;
	}
}

void KMP()
{
	int j = 0;
	for (int i = 0; i<a.length(); i++)
	{
		while (j && a[i]!=b[j])
			j = fail[j];

		if (a[i]==b[j])
			j++;
		ans[j] ++;
	}
}

int main()
{
	int n,m,k;
	cin >> n >> m >> k;

	cin >> a;
	cin >> b;

	pre();

	KMP();

	for (int i = b.length(); i>0; i--)
		ans[fail[i]] += ans[i];

	for (int i = 0; i<b.length(); i++)
		ans[i] -= ans[i+1];

	while (k--)
	{
		int x;
		cin >> x;
		cout << ans[x] << endl;
	}
}

```01postpublish011108410bd960e3be651e96cb0fd5179dee4{"cid":3,"title":14,"slug":3,"created":10,"modified":10,"text":6932,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}190Haskell基础819015288966601529833461<!--markdown--># lambda与折叠

> | 一个已经一个半月没有更过的系列。。。。折叠比较难以理解，需要多花时间来学习一下，这篇博客的篇幅应该也会比较长。

<!--more-->

参考书籍: [_Learn you a Haskell_](http://learnyouahaskell.com/)

# lambda

lambda在Haskell中就是指一次性的佚名函数。当我们想使用一个函数但是不想再去定义它时可以使用lambda。在Haskell中，如果襄阳声明一个lambda，就写一个`\`。之所以用这个符号，是因为它长得比较像$\lambda$（然而我觉得并不像。。。）。具体用例如下：

<pre><code class="language-haskell" >
biggerThanFive :: Int
biggerThanFive xs = length (filter (\x -> even x) xs) 
</code></pre>

上面的式子计算出了1到100中偶数的个数。lambda表达式看上去十分好用，以至于经常被滥用，很多情况下的lambda表达式都是没有必要的，比如下面两个式子便是等价的:
```Haskell
addThree :: [Int] -> [Int]
addThree xs = map (+3) xs

addThree :: [Int] -> [Int]
ad Three xs = map (\x -> x + 3) xs
```

和普通函数一样,lambda也可以取多个参数：

```Haskell
ghci> zipWith (\(a,b) -> a + b) [(1,2),(3,5),(6,3),(2,6),(2,5)]
[3,8,9,8,7]
```

此外，还有一个同时运用了lambda和柯里化的较为有趣的例子：

```
sumThree :: Int -> Int -> Int -> Int
sumThree x y z = x + y + z

sumThree :: Int -> Int -> Int -> Int 
sumThree = \x -> \y -> \z -> x + y + z
```

上面的两个函数的作用时相同的。只不过第二个并不易理解。

# 折叠

折叠应该算是到现在为止比较难的部分了(起码我是这么认为的)，其实主要是学会区分和使用左折叠和右折叠。折叠会取一个二元函数，一个初始值和一个列表。它会依次将二元函数从左到右或从右到左应用到列表上，并且上一个的返回值为下一次二元运算的一个参数。

## foldl-左折叠

左折叠，显而易见，就是从列表的左端开始执行"折叠"操作。闲话不多说，我们先来举一个最简单的例子-求和：

```Haskell
sum' :: (Num a) => [a] -> a
sum' xs = foldl (\acc x -> acc + x) 0 xs
```

在进行左折叠时，譬如计算`sum' [3,5,2,6]`，即`foldl (\acc x -> acc + x) 0 [3,5,2,6]`,其步骤大概为先计算`0+3`，得出`3`，再计算`3+5`，得出`8`，然后计算`8+2`，得出`10`，最后计算`10+6`，算出`16`，得到最终答案。

当然，上面的函数如果我们使用函数柯里化的方式而非lambda函数的话，写法会更加简单:
```Haskell
sum' :: (Num a) => [a] -> a
sum' = foldl (+) 0
```

## foldr-右折叠

右折叠，顾名思义，从右边开始折叠。需要注意的是，右折叠的**二元函数内的参数**位置和左折叠是相反的。折叠的初始值可以为任何类型，比如，我们可以自己实现`map`函数，初始值为`map`所要操作的列表，写法如下：

```Haskell
map' :: (a -> b) -> [a] -> [b]
map' f xs = foldr (\x acc -> f x : acc) [] xs
```

如果我们运行`map' (+3) [1,2,3]`,即`foldr (\x acc -> f x : acc) [] xs`时，程序会首先将执行`f 3 : []`,得到`[6]`,然后执行`f 2 : [6]`,得到`[5,6]`，最后是`f 1 :[5,6]`，得到`[4,5,6]`。当然，我们也可以使用左折叠来实现`map'`函数：

```Haskell
map' :: (a -> b) -> [a] -> [b];
map' f xs = foldl (\acc x -> acc ++ [f x]) [] xs
```

但是，使用左折叠时用到的`++`操作远比`:`要慢，所以需要生成列表时，我们一般会使用右折叠。此外，两个折叠有一个非常重要的区别：左折叠无法处理无限列表，而右折叠可以。这个我们在之后会深入讨论。

## foldl1与foldr1

当我们想要使用折叠而又没有初始值时该怎么办呢？这时候就要拿出我们的`foldl1`和`foldr1`函数了。这两个函数与常规的折叠函数的唯一区别是没有初始值，而是取列表最左(右)边的元素作为初始值。在很多时候这会非常有用，比如我们要实现一个`maximum'`函数：
```Haskell
maximum' :: (Ord a) => [a] -> a
maximum = foldl1 max
```

此时的`maximum'`函数会取列表最左边的元素作为初始值，然后一次向右进行折叠操作，以此比较出最大值。

`foldl1`和`foldr1`需要注意的是传入的列表不能够为空列表，应该至少包含一个元素，否则会发生运行时错误。

## 一些折叠的例子

为了继续熟悉折叠的用法，我们来用折叠实现几个标准库函数：
```Haskell
reverse' :: [a] -> a
reverse' = foldl (\acc x -> x : acc) []
```

这里我们使用左折叠，从左边开始取数，然后从左边放入答案的列表中，实现反转功能。而若是我们使用`filp`，可以将上面的函数简化成这样：
```Haskell
reverse'= fold (flip (:)) []
```

我们可以实现`product'`函数：
```Haskell
product' :: (Num a) => [a] -> a
product' = foldl (*) 1
```
或者写成这样
```Haskell
product' = foldl1 (*)
```

还有较为复杂的`filter'`函数：
```Haskell
filter' :: (a -> Bool) -> [a] -> [b]
filter' p = foldr (\x acc -> if p x then x : acc else acc) []
```

此外，我们还可以用折叠来实现`last'`函数，这是比较巧妙地用法：
```Haskell
last' :: [a] -> a
last' = foldl1 (\_ x -> x)
```

### 关于折叠的运行步骤

我们很容易理解，左折叠和右折叠分别为从左侧和右侧开始。但是若是将这过程直接拆分为一个表达式会是什么样子呢？还是以`sum'`函数为例，假如进行`sum' [3,5,6,8]`操作，那么，左折叠和右折叠的运行步骤应该为什么样子呢？

* 左折叠：

```Haskell
(((0 + 3) + 5) + 6) + 8
```

* 右折叠:

```Haskell
3 + (5 + (6 + (8 + 0)))
```

## 无限列表的折叠

之前我们也已经讲过了，只有右折叠能够实现无限列表的操作。这看上去有悖于直觉。因为我们可能会认为左折叠是从左面开始的，所以能过先计算左边的元素，然后因为Haskell的惰性，满足条件时直接退出。

但是，我们可以来看一下之前提到的折叠的运行步骤。当我们将左折叠和右折叠分别拆分时，发现两种折叠都为括号内的项数为无限多。而左折叠的括号在左侧，右折叠在右侧。也就是说，右折叠拆分后，无限多的项被放到了右边，因此我们可以从左边开始依次进行处理，然后根据情况依赖于Haskell的惰性，退出这个无限长的式子。

比如，我们运行下面的式子:

```Haskell
ghci> foldr && True (repeat False)
False
```

这个式子拆分完后是:

```Haskell
True && (False && (False && (False && ...)))
```

也就是说，我们完全可以从左到右依次运行，算出结果为`False`。01postpublish01110c5b8a21f8378d9647cdc3ab5a5f22ce9{"cid":3,"title":26,"slug":3,"created":10,"modified":10,"text":9196,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}192 [学习笔记]AC自动机19215294018601543921708<!--markdown-->> 这么长时间，总该学点新东西。打算新开这么一个"系列"，放一些新学的算法和数据结构。毕竟大学已经一年了，却没有在算法上继续扩宽自己的知识面，比赛时明显能感到自己知识广度的不足。

<!--more-->

## 介绍

**AC自动机**，全称是**Aho-Corasick automaton**，于1975年产生于贝尔实验室，是著名的多模式匹配算法。其主要是**Trie (字典树)** 和**KMP**算法的结合，能够找出在一个母串中多个子串的出现次数。

与KMP算法相同，其对时间的加速主要取决于失配函数。但是由于我们要实现多模式匹配，所以这里的匹配函数要针对一个Trie 树构建而非一个数组。由于每次匹配失败后我们不会重新匹配，而是根据失配函数进行跳跃，所以可以在极端情况下节省大量的时间。

## 流程及原理

AC自动机的实现流程可以分为几步：Trie树的构建；失配函数的生成；进行匹配。与KMP算法一样，失配函数的生成是其中最核心也是最困难的部分。

### Trie树的构建

首先，我们假设我们有一个母串`"ourshers"`,然后我们需要匹配子串`"our","ours","he"，
"him","she","hers"`在其中出现的总次数。因为很明显，这几个子串并没有一个公共的首字母，而我们需要将所有的串放入到一个树中，所以我们要将root节点设为空，然后在root节点的线面连接每一个单词的首字母作为子节点。最后我们生成的Trie树应该如下图所示：

![Trie树](https://oi-songer.github.io/In%20Blog/AC%E8%87%AA%E5%8A%A8%E6%9C%BA-1.png)

其中，用正方形圈起来的是单词的结尾。

### 失配函数的生成

在实现AC自动机的失配函数之前，可以先回顾一下KMP算法的失配函数。假如失配函数是`f[]`,字符数组`a[]`是我们想要生成失配函数的母串，那么代码如下：

```C++
for (int i= 0; i<m; i++)
{
	int j = f[i];
    while (j && a[i]!=a[j])
    	j = f[j];
    f[i+1] = a[i]==a[j]? j+1 : 0;
}
```

我们通过不断地将当前点根据失配函数向前回溯，找到可以相同的点，来构造出下一个点的失配函数。注意，这里的失配函数满足的是$a[i-1]==a[f[i]-1]$,即失配函数会从无法匹配的字符直接跳向需要进行下一步匹配的字符。

那么，现在我们便来考虑AC自动机的失配函数。其思想和KMP类似，只不过这次我们需要用BFS来实现。在这里，我们将构建一个结构体，包含`word(char),fail(node*),son(node*[]),next(Node*),isWrod(bool)`三个成员变量(`word`主要用来debug，实际不一定用到)。

代码如下：
```C++
queue<Node*> q;
root->fail = NULL;
while(!q.empty())
{
	Node* v = q.front();
    q.pop();
	
    for (int i = 0; i<26; i++)
	{
    	Node *&c = v->c[i];
        
    	if (!c)    continue;
        
    	Node *u = v->fail; 
    	while ( u!=root && !u->c[i] )
        	u = u->fail;
            
    	c->fail = v!=root && u && u->c[i]? u->c[i] : root;
    	c->next = c->fail-isWord ? c->fail : c->fail->next;
        
    	q.push(c);
	}
}

```

这样的话，我们就能够得到失配函数`fail`。注意，这里的fail满足的条件是`t->word==t->fail->word`。`isWord`记录当前是否为词尾。而`next`的作用是记录最近的为词尾的当前节点的失配节点。

在完成了处理之后，我们便能够得到一个如下图的情况：

![Fail-Trie](https://oi-songer.github.io/In%20Blog/AC%E8%87%AA%E5%8A%A8%E6%9C%BA-2.png)

### 模式匹配

匹配时整体思路与构建失配函数类似。我们假设母串为`s`(string类型)。所以代码如下：

```C++
Node *v = root;
for (int i = 0; i<s.length(); i++)
{
	char ch = s[i];
	while ( v!=root && !v->c[ch-‘a’])
    	v = v->fail;
	v = v->c[ch-‘a’]? V->c[ch-‘a’] : root;

	Node* t;
	if (v->isWord)
        t = v;
    else t = v->next;
        while (t)
        {
            ans ++;
            t = t->next;
        }
}

```

我们首先找到当前节点是否可以继续走下去。若是不可以，则回溯`fail`指针，找到第一个可以匹配的点。然后我们再判断该点是否为词尾，并且通过`next`指针判断其是否为其他单词的词尾。

这样，我们便完成了匹配部分。此时AC自动机的大部分功能便已经实现了。

## 例题

### Luogu 3808

题目来源: [Luogu](https://www.luogu.org/problemnew/show/P3808)

```C++
#include <iostream>
#include <string>
#include <vector>
#include <queue>

using namespace std;

struct Node
{
	char word;		//record the word
	int cnt;		//record if this word is the end of some word, and how many is it
	Node *fail;
	Node *next;
	Node *son[26];

	Node(char word=' '):word(word)
	{
		fail = NULL;
		next = NULL;
		cnt = 0;

		for (int i = 0; i<26; i++)
			son[i] = NULL;
	}
};

struct Trie
{
	Node *root;

	Trie(vector<string> s){
		root = new Node();

		for (int i = 0; i<s.size(); i++)
			build(s[i]);
	}

	void build(const string &s)
	{
		int i = 0;
		Node *p = root;

		while (i!=s.length())
		{
			if (p->son[s[i]-'a']==NULL)
				p->son[s[i]-'a'] = new Node(s[i]);

			p = p->son[s[i]-'a'];
			i++;
		}

		p->cnt ++;

		return;
	}

	void makeFail()
	{
		queue<Node*> q;
		q.push(root);
		while (!q.empty())
		{
			Node *v = q.front();
			q.pop();

			for (int i = 0; i<26; i++)
			{
				Node *&c = v->son[i];

				if (!c)	continue;

				Node *u = v->fail;
				while ( u && !u->son[i] )
					u = u->fail;

				c->fail = (v!=root && u && u->son[i])? u->son[i] : root;
				c->next = c->fail->cnt ? c->fail : c->fail->next;

				q.push(c);
			}

		}

		return;
	}

	int pair(string m)
	{	
		int ans = 0;

		Node *v = root;
		for (int i = 0; i<m.length(); i++)
		{
			const char &ch = m[i];

			while ( v!=root && !v->son[ch-'a'] )
				v = v->fail;

			v = v->son[ch-'a']? v->son[ch-'a'] : root;

			Node *t = v;
			while (t)
			{
				//	cout <<"* " << i << " " << t << " " << t->word << " " << t->cnt << endl;
				ans += t->cnt;
				t->cnt = 0;
				t = t->next;
			}
		}

		return ans;
	}

};

int n;
vector<string> s;
string m;

int main()
{
	cin >> n;
	for (int i = 0; i<n; i++)
	{
		string t;
		cin >> t;
		s.push_back(t);
	}
	cin >> m;

	Trie* t = new Trie(s);

	t->makeFail();

	int ans = t->pair(m);

	cout << ans;
}
```

### Luogu 3796

题目来源: [Luogu](https://www.luogu.org/problemnew/show/P3796)

```C++
#include <iostream>
#include <string>
#include <vector>
#include <queue>
#include <cstring>

using namespace std;

int ans[200];

struct Node
{
	char word;		//record the word
	int cnt;		//record if this word is the end of some word, and how many is it
	Node *fail;
	Node *next;
	Node *son[26];

	vector<int> words; 		//record whose end this node is.

	Node(Node *p,char word=' '):fail(p),word(word)
	{
		next = NULL;
		cnt = 0;

		for (int i = 0; i<26; i++)
			son[i] = NULL;
	}

	~Node()
	{
		for (int i = 0; i<26; i++)
			if (son[i])
				delete son[i];
	}
};

struct Trie
{
	Node *root;

	Trie(vector<string> s){
		root = new Node(NULL);
		root->fail = root;

		for (int i = 0; i<s.size(); i++)
			build(s[i],i);
	}

	~Trie()
	{
		delete root;
	}

	void build(const string &s,const int &x)
	{
		int i = 0;
		Node *p = root;

		while (i!=s.length())
		{
			if (p->son[s[i]-'a']==NULL)
				p->son[s[i]-'a'] = new Node(root,s[i]);

			p = p->son[s[i]-'a'];
			i++;
		}

		p->cnt ++;
		p->words.push_back(x);

		return;
	}

	void makeFail()
	{
		queue<Node*> q;
		q.push(root);
		while (!q.empty())
		{
			Node *v = q.front();
			q.pop();

			for (int i = 0; i<26; i++)
			{
				Node *&c = v->son[i];

				if (!c)	continue;

				Node *u = v->fail;
				while ( u!=root && !u->son[i] )
				{
					u = u->fail;
				}

				c->fail = (v!=root && u->son[i])? u->son[i] : root;
				c->next = c->fail->cnt ? c->fail : c->fail->next;

				q.push(c);

			}
		}

		return;
	}

	void pair(string m)
	{
		Node *v = root;
		for (int i = 0; i<m.length(); i++)
		{
			const char &ch = m[i];

			while ( v!=root && !v->son[ch-'a'] )
				v = v->fail;

			v = v->son[ch-'a']? v->son[ch-'a'] : root;

			Node *t = v;
			while (t)
			{
				if (t->cnt)
				{
					for (int i = 0; i<t->words.size(); i++)
						ans[t->words[i]] ++ ;
				}
				t = t->next;
			}
		}

		return;
	}

};

int n;
vector<string> s;
string m;

int main()
{
	while (cin >> n && n)
	{
		memset(ans,0,sizeof(ans));
		s.clear();

		for (int i = 0; i<n; i++)
		{
			string t;
			cin >> t;
			s.push_back(t);
		}
		cin >> m;
	
		Trie* t = new Trie(s);

		t->makeFail();

		t->pair(m);

		int maxn = 0;
		for (int i = 0; i<n; i++)
			maxn = max(maxn,ans[i]);

		cout << maxn << endl;

		for (int i = 0; i<n; i++)
			if (maxn==ans[i])
				cout << s[i] << endl;

		delete t;
	}

	return 0;
}
```
01postpublish01110acbc0c2c01a741e7536e7bda1e17995e{"cid":3,"title":17,"slug":3,"created":10,"modified":10,"text":2766,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}201Tree Constructing20115307763401530776518<!--markdown-->## CF 494 E

> | 这次是div3的题目，本身没有涉及到什么复杂的算法，可以说就是一道模拟题。不过细节还是很多的，需要注意。比赛时因为漏掉了一个细节结果比赛后被hack了，否则这次div3能排到一百多名(〒▽〒)。。。。

<!--more-->

## 题解

题目要求给定顶点数`n`,直径`d`,和最大度数`k`，是否有这样的数存在。存在的话输出这棵树的所有边。

首先，这里的`n`和`d`都是必须正好满足的，而`k`则是要求树最大度数小于等于`k`即可。所以，在这里，我们应该先从`d`入手。

很明显，我们可以首先尝试构建一个最长边，它总共包含`d+1`个点。所以，若$ n \le d $，就可以直接输出`"NO"`。

而当我们构建最长边时，若$d+1==1$，则必须满足$k\ge0$；若$ d+1==2$，则必须满足$k\ge1$;若$d+1\ge3$,则必须满足$ k \ge 2 $。所以若以上条件不满，我们也可以输出`"NO"`。

在最长边构建完成之后，我们便可以开始构建其他的边了。很明显，其他的边都是由最长边上的点为根节点延伸出来的，也就是说，其他的边集构成了一个根节点为最长边上的点的若干个子树。所以说，我们在最长边上一直生成子树，就能够形成一个满足最终条件的树。

当然，也存在不满足条件的情况。若我们已经构建了所有满足情况的子树之后，结点数还是小于`n`的话，说明无法构建，此时应该输出`"NO"`。

还有，我们该如何生成一个符合条件的子树呢？我们可以使用一个递归的建树函数，分别传入该点的序号，该点剩余的度数和该点向下还能够建树的深度。这样的话当深度为`0`是直接返回，从而使我们生成的子树不会令最长边变长。

## 代码

```C++

#include <iostream>

using namespace std;

int n,d,k;
int cur;

int ans[400100][2];
int num = 0;

void build(int x,int t,int kk)
{
	if (t==0)
		return;

	if (cur>n)
		return;

	for (int i = 0; i<kk; i++)
	{
		ans[num][0] = x;
		ans[num][1] = cur;
		cur ++;
		num ++;

		if (cur > n)
			return;

		build(cur-1,t-1,k-1);

		if (cur > n)
			return;
	}
}

int main()
{

	cin >> n >> d >> k;
	d++;

	if (n < d || (d>2 && k==1) )
	{
		cout << "NO";
		return 0;
	}
	for (int i = 1; i<d; i++)
	{
		ans[num][0] = i;
		ans[num][1] = i+1;
		num++;
	}
	cur = d+1;

	for (int i = 1; i<=d; i++)
		build(i,min(i-1,d-i),k-2);

	//cout << "! " << num << endl;
	if (num!=n-1)
		cout << "NO" << endl;
	else{
		cout << "YES" << endl;
		for (int i = 0; i<num; i++)
			cout << ans[i][0] << " " << ans[i][1] << endl;
	}
}

```
01postpublish011109f30bf3b906c59368e9ed1b2930ea6e2{"cid":3,"title":21,"slug":3,"created":10,"modified":10,"text":1021,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}194大一下第十七周19415298293001529829359<!--markdown--># 2018 6 24

<!--more-->

最近总算是忙完了大部分的期末考试，只剩了英语一科，打算开始认真学些东西。结果在我看codeforces最近的比赛的时候，我发现了一个叫`Microsoft Quantum Summer 2018 Q# Coding Contest`的比赛。之前就听说了过Q#语言，但是没有专门去了解过。上网一查，突然感到十分有趣。毕竟我这个人嘛，总是喜欢一些非常前(zhuang)沿(bi)的东西，而对于这种高(xuan)端(xue)的量子计算更是十分有兴趣。所以mark在这里，希望自己能够认真学习一下，而不是半途而废。

此外，最近一个同学来找我希望我假如网络技术研究所(应该是叫这个名字吧？)。虽然我挺有兴趣的，但是感觉或许会没有时间，抑或是自己太懒。最近我还是去看一看吧，毕竟，时间，只要愿意，总还是会有的。

总之，今天闲来无事，更一篇好久没更过的Diary，希望自己能够认真学习下去。01postprivate011102df223bb36207f427386ea3925f04f8a{"cid":3,"title":20,"slug":3,"created":10,"modified":10,"text":2803,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}214Doing Homework again21415334792201533479288<!--markdown--># hdu 1789

<!--more-->

题目来源: [_HDU_](http://acm.hdu.edu.cn/showproblem.php?pid=1789)

## 分析

这道题是一道很简单的模拟题(大概)，其难点主要在于是否能够发现正确的模拟策略。而模拟本身十分简单。

题目要求怎么安排做作业才能使最后的惩罚最小。对于这道题，我们加入从前向后模拟的话，我们发现我们需要考虑两个因素:deadline和惩罚。我们既想要尽早地完成deadline较进的作业，又想要在无法避免的情况下优先完成惩罚较大的作业。此时我们会发现，想要根据这两个因素找到最合适的方案及其困难。

因此，我们便需要换一种思维了。首先，很明显，一项作业只需在deadline前完成即可，时间前后并不影响。那么，我们为什么不考虑从后向前跑呢？在从后向前跑时，我们会维护一个时间戳，表明当前的时间，然后将deadline在当前时间之后的作业加入堆中。而在这个堆中，我们只需要考虑惩罚大小这一个属性即可。而时间戳则会从后向前依次移动，并在每个时间点完成一项作业，即从大根堆中取出一个元素。

很明显，在这种算法下，我们在当前时间完成的每项作业都是目前最重要的，并且不需要考虑时间因素，因为我们是从后向前运行，所以只要还有时间，就一定能完成当前作业，否则会剩下惩罚最小的作业。

## 代码

```C++
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

struct Node
{
    int val,time;

    const bool operator < (const Node& tmp)const{
        return time > tmp.time || (time==tmp.time && val > tmp.val);
    }

}node[1010];

priority_queue<int> q;

int main()
{
    int T;
    cin >> T;

    while (T--)
    {
        q = priority_queue<int> ();

        int n;
        cin >> n;

        for (int i = 1; i<=n; i++)
            cin >> node[i].time;
        for (int i = 1; i<=n; i++)
            cin >> node[i].val;

        sort(node+1,node+1+n);

        int t = node[1].time;
        for (int i = 1; i<=n; i++)
        {
            q.push(node[i].val);

            while (!q.empty())
                if (t >= node[i].time && t>0)
                {
                    t--;
                    q.pop();
                }else break;

            t = node[i].time - 1;
        }
        while (t!=0)
        {
            if (q.empty())
                break;

            q.pop();
            t--;
        }

        long long ans = 0;
        while (!q.empty())
        {
            ans += q.top();
            q.pop();
        }

        cout << ans << endl;
    }
}
```01postpublish011101b2d3143941666a470991ea246bbae54{"cid":3,"title":26,"slug":3,"created":10,"modified":10,"text":10119,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}204[学习笔记]树链剖分20415313102801543921730<!--markdown-->> 树链剖分。。。对这个名字还有点印象，记得好像是要分为轻链重链什么的，但是有没有写过已经完全忘记了。这次要进行一个树链剖分的专题。

<!--more-->

## 介绍

树链剖分，计算机术语，指一种对树进行划分的算法，它先通过轻重边剖分将树分为多条链，保证每个点属于且只属于一条链，然后再通过数据结构（树状数组、SBT、SPLAY、线段树等）来维护每一条链。

## 原理及流程

### 原理

树链剖分有一个特点，它必须搭配其他数据结构如线段树、树状数组等来使用，而其本身并不是十分复杂。他其实一般只做了一件事--将一个无法使用线段树等数据结构解决的问题转化为可以使用这些数据结构的问题。

树链剖分，正如其名，是对树上的不同的链进行分离。其分离的主要依据**轻链**和**重链**。假设我们使用`num[i]`来存储以节点`i`为根节点的子树的节点数目，如果对于节点`x`,其子节点中`num[]`最大的便为节点`x`的**重儿子**，而连接他们的则为**重边**。其他儿子则为**轻儿子**，边为**轻边**。

当我们将一棵树中的所有边划分为重边和轻边时，我们会发现这棵树可以根据重边分为几个不同的链或点，相互连接的重边便为一条**重链**。而轻边的链则为**轻链**。

有了重链和轻链，这有什么用呢？树链剖分主要用来解决对两个点之间的最短路中的节点进行修改的问题。而树链剖分的思路便是通过重边和轻边重新生成一棵树，令每条重链中的所有元素在编号上连续。这样，当我们在更改最短路上的点时，我们便可以将其分为几条重链上的边，然后通过线段树来进行加速了。

### 步骤

实现树链剖分，我们一般需要两次dfs来建树，然后再用其他数据结构解决问题。当然，当数据规模较大时，我们一般会使用BFS来代替DFS，其原理都是相同的。

以下代码中用到的结构体如下:

```C++
struct Edge
{
	int from,to;
	int next;

	Edge(int from=0,int to=0,int next=0):from(from),to(to),next(next)	{}
};
```

```C++
struct Node
{
	int edge;

	vector<int> son;
	int fa,top,num;
	int id1,id2;
	bool flag;

	Node(int id1):id1(id1)
	{
		edge = 0;
		num = 1;
		flag = false;
	}
};

Node* f[MAXN];
```

#### 第一次DFS

第一次DFS完成的是一些常规的操作:计算每个节点的深度、父节点、子节点和所有后代节点的数量。

```C++
void dfs1(Node* x)
{
	int v = x->edge;

	while (v)
	{
		Node *&t = e[v].to;
		if (!f[t]->flag)
		{
			f[t]->flag = true;
			f[t]->depth = f[x]->depth + 1;
			f[x]->son.push_back(t);
			f[t]->fa = x.id1;

			dfs1(f[t]);

			f[x]->num += f[t]->num;
		}

		v = e[v].next;
	}
}
```

#### 第二次DFS

此时需要算出重边和重儿子，然后在DFS时优先搜索重儿子，然后依序进行编号，这样的话可以令所有的重链中的节点编号连续。此外，我们需要记录每个点所在重链的根节点。

```C++
void dfs2(Node* x,bool heavy)
{
	static cnt = 0;

	if (heavy)
		x->top = x->fa->top;
	x->id2 = ++cnt;

	int max = 0,maxi=0;
	for (int i = 0; i<x->son.size(); i++)
		if (x->son[i]->num > max)
		{
			max = x->son[i]->num;
			maxi = i;
		}

	dfs2(x->son[maxi],true);
	for (int i = 0; i<x->son.size(); i++)
		if (i!=maxi)
			dfs2(x->son[i],false);
}
```

#### 使用

这里我们以对树中两点之间最短路上的点进行修改为例。假设我们想要修改`x`和`y`节点的最短路。那么我们进行以下几个操作:

1. 使 `fx = top[x]`, `fy = top[y]`。
2. 比较`fx`与`fy`的深度，取深度较大的那个，假设为`fx`,然后对`x`到`fx`的范围进行更改。因为其编号连续，所以使用线段树更改速度较快。然后令`x = fa[fx]`。
3. 重复1~2操作，直至`fx == fy`。
4. 对`x`到`y`进行操作。

## 例题

题目来源: [_Luogu_](https://www.luogu.org/problemnew/show/P3384)

```C++
#include <iostream>
#include <queue>

#define MAXN 100100

using namespace std;

int p;

/* 线段树部分 */

struct Segment
{
    int l, r;
    long long val, lazy;

    Segment *sonl, *sonr;

    Segment(int l, int r)
        :l(l), r(r), val(0), lazy(0), sonl(NULL), sonr(NULL)  {}
};

struct SegmentTree
{
    Segment *root;

    ~SegmentTree()
    {
        delete root;
    }

    void Update(Segment *segment)
    {
        segment->val = segment->sonl->val + segment->sonr->val;
		segment->val %= p;
    }

    void PushDown(Segment *segment)
    {
        segment->sonl->lazy += segment->lazy;
        segment->sonl->val += segment->lazy * (segment->sonl->r - segment->sonl->l + 1);
		segment->sonl->lazy %= p;
		segment->sonl->lazy %= p;

        segment->sonr->lazy += segment->lazy;
        segment->sonr->val += segment->lazy * (segment->sonr->r - segment->sonr->l + 1);
		segment->sonr->lazy %= p;
		segment->sonr->lazy %= p;

        segment->lazy = 0;
    }

    void Build(Segment *segment, int a[])
    {
        if (root==NULL)
            root = segment;
        
        if (segment->l==segment->r)
        {
            segment->val = a[segment->l];
			segment->val %= p;
        }else
        {
            int mid = (segment->l + segment->r)/2;
            segment->sonl = new Segment(segment->l, mid);
            segment->sonr = new Segment(mid+1, segment->r);

            Build(segment->sonl, a);
            Build(segment->sonr, a);

            Update(segment);
        }
    }

    void Add(Segment *segment, int l, int r, int val)
    {
        if (segment->l==l && segment->r==r)
        {
            segment->lazy += val;
            segment->val += val * (r - l + 1);
			segment->lazy %= p;
			segment->val %= p;

            return;
        }

        PushDown(segment);

        int mid = (segment->l + segment->r)/2;
        if (r<=mid)
            Add(segment->sonl, l, r, val);
        else if (l>mid)
            Add(segment->sonr, l, r, val);
        else{
            Add(segment->sonl, l, mid, val);
            Add(segment->sonr, mid+1, r, val);
        }
        Update(segment);
        return;
    }

    long long Query(Segment *segment, int l, int r)
    {
        if (segment->l==l && segment->r==r)
        {
            return segment->val;
        }

        PushDown(segment);
        int mid = (segment->l + segment->r)/2;
        if (r<=mid)
            return Query(segment->sonl, l, r);
        else if (l>mid)
            return Query(segment->sonr, l, r);
        else{
            long long ret = 0;
            ret += Query(segment->sonl, l, mid);
			ret %= p;
            ret += Query(segment->sonr, mid+1, r);
			ret %= p;

            return ret;
        }
    }
};

/* 树链剖分部分 */

struct Node
{
	int val;
	struct Edge *edge;
	Node *fa;

	int depth, size;
	int id, endId;
	Node *top;

	Node()
	{
		depth = 0;
		size = 1;
		edge = NULL;
		fa = NULL;
	}

}node[MAXN];

struct Edge
{
	Node *from, *to;
	Edge *next;

	Edge(Node *from=NULL, Node *to=NULL)
		:from(from), to(to), next(from->edge)	{}
};

queue<Node*> q;
void BuildTree(Node *x)
{
	for (Edge *e = x->edge; e; e = e->next)
		if (e && e->to->depth==0)
		{
			e->to->fa = x;
			e->to->depth = x->depth + 1;

			BuildTree(e->to);

			x->size += e->to->size;
		}
	return;
}

int a[MAXN];
int num = 0;
void MakeId(Node *x)
{
	x->id = ++num;
	a[x->id] = x->val;

	int maxn = 0;
	Node *maxi = NULL;

	for (Edge *e = x->edge; e; e = e->next)
		if (e && e->to->fa==x && e->to->size > maxn)
		{
			maxn = e->to->size;
			maxi = e->to;
		}

	if (maxi)
	{
		maxi->top = x->top;
		MakeId(maxi);
	}

	for (Edge *e = x->edge; e; e = e->next)
		if (e && e->to->fa==x && e->to !=maxi)
		{
			e->to->top = e->to;
			MakeId(e->to);
		}
	x->endId = num;

	return;
}

inline void EdgeAdd(Node *x, Node *y, int z, SegmentTree *st)
{
	while (x->top != y->top)
	{
		if (x->top->depth < y->top->depth)
			swap(x, y);

		st->Add(st->root, x->top->id, x->id, z);

		x = x->top->fa;
	}
	
	if (x->depth < y->depth)
		swap(x, y);

	st->Add(st->root, y->id, x->id, z);

	return;
}

inline long long EdgeQuery(Node *x, Node *y, SegmentTree *st)
{
	long long ret = 0;
	while (x->top != y->top)
	{
		if (x->top->depth < y->top->depth)
			swap(x, y);

		ret += st->Query(st->root, x->top->id, x->id);
		ret %= p;

		x = x->top->fa;
	}

	if (x->depth < y->depth)
		swap(x, y);

	ret += st->Query(st->root, y->id, x->id);
	ret %= p;

	return ret;
}

inline void SubtreeAdd(Node *x, int z, SegmentTree *st)
{
	st->Add(st->root, x->id, x->endId, z);
}

inline long long SubtreeQuery(Node *x, SegmentTree *st)
{
	return st->Query(st->root, x->id, x->endId) % p;
}

int main()
{	
	int n, m, r;
	cin >> n >> m >> r >> p;

	for (int i = 1; i<=n; i++)
	{
		node[i].id = i;
		cin >> node[i].val;
	}

	for (int i = 1; i<n; i++)
	{
		int x, y;
		cin >> x >> y;

		node[x].edge = new Edge(&node[x], &node[y]);
		node[y].edge = new Edge(&node[y], &node[x]);
	}

	num = 0;
	node[r].depth = 1;
	node[r].top = &node[r];
	BuildTree(&node[r]);
	MakeId(&node[r]);

	SegmentTree *segmentTree = new SegmentTree();
	segmentTree->Build(new Segment(1, n), a);

	for (int i = 1; i<=m; i++)
	{
		int opera;
		cin >> opera;

		int x, y, z;
		switch(opera)
		{
			case 1: cin >> x >> y >> z;
					EdgeAdd(&node[x], &node[y], z, segmentTree);
				break;

			case 2: cin >> x >> y;
					cout << EdgeQuery(&node[x], &node[y], segmentTree) << endl;
				break;

			case 3: cin>> x >> y;
					SubtreeAdd(&node[x], y, segmentTree);
				break;

			case 4: cin >> x;
					cout << SubtreeQuery(&node[x], segmentTree) << endl;
				break;
		}
	}
}
```
01postpublish0111035e884ae273f08f7fe8ba9b55477d40e{"cid":3,"title":14,"slug":3,"created":10,"modified":10,"text":2882,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}203Haskell基础920315307828201531310832<!--markdown--># 扫描，\$ 和函数组合

<!--more-->

参考书籍: [_Learn you a Haskell_](http://learnyouahaskell.com/)

# 扫描

扫描，即指`scanl`和`scanr`函数。其与`foldl`和`foldr`类似，但是会将整个操作过程返回的所有值记录在一个列表中。比如：

```Haskell
ghci> scanl (+) 0 [3,5,2,1]
[0,3,8,10,11]
ghci> scanr (+) 0 [3,5,2,1]
[11,8,3,1,0]
ghci> scanl1 (\acc x -> if x>acc then x else acc) [3,4,5,3,7,9,2,1]
[3,4,5,5,7,9,9,9]
ghci> scanl (flip (:)) [3,2,1]
[[],[3],[2,3],[1,2,3]]
```
其中，`scanl`中最后的结果为列表的最后一个元素，`scanr`中为第一个元素。它可以用来跟踪折叠的执行过程。

# \$

`$`函数，也被称为**函数应用符(function application operator)**。他的定义如下：

```Haskell
($) :: (a -> b) -> a -> b
f $ x = f x
```

看上去这个符号似乎没有任何意义。但是实际上因为`$`拥有最低的优先级，并且它是右结合的(一般的函数是左结合的)，所以可以起到替代括号的作用。像下面的几种写法就是等价的:

```Haskell
sqrt (3 + 5)
sqrt $ 3 + 5

sum ( filter (> 10) (map (*2) [2..10] ))
sum $ filter (> 10) $ map (*2) [2..10]

```

`$`是右结合的，所以`f $ g $ x`和`f $ ( g $ x )`等价。因此，我们可以省去很多在最后的括号。

除了减少括号外，`$`还能够将函数应用转为函数，这就允许我们映射一个函数应用到一组函数组成的列表:

```Haskell
ghci> map ($ 3) [(4+), (10*), (^2)]
[7.0, 30.0, 9.0]
```

# 函数组合

## 定义

在数学中，**函数组合(function composition)**是这样定义的:$ (f \cdot g) (x) = f (g (x)) $。而在Haskell中的函数组合也与之类似，其符号为`.`。定义为：
```Haskell
(.) :: (b -> c) -> (a -> b) -> a -> c
f . g = \x -> f ( g x )
```

在进行函数组合时，我们要确保函数`g`的返回值与`f`的参数类型相同。其使用很简单，我们可以用其将几个函数生成一个新函数:

```
map (\x -> 3*x+1)
等价于
map ((+1) . (*3))
```


## 带有多个参数的函数组合

对于带有多个参数的函数，当我们想要使用函数组合时，我们可以通过部分应用来时所有函数只剩下一个参数，然后再使用。如下面的几个式子便是等价的:

```Haskell
sum (replicate 5 (max 6.7 8.9))
(sum . replicate 5) (max 6.7 8.9)
sum . replicate 5 $ max 6.7 8.9
```

## Point-Free 风格

函数组合的另一用途便是定义**Point-Free风格**，也称为Pointless风格。通过去掉函数定义中重复的变量，让代码更加简洁和易读。比如下面的代码:

```Haskell
sum' xs = foldl (+) 0 xs
改为
sum' = foldl (+) 0

fn x = ceiling (negate (tan (cos (max 50 x))))
改为
fn = ceiling . negate . tan . cos . max 50
```01postpublish0111045b55f2d3a0d3488b6cfc7628276611a{"cid":3,"title":20,"slug":3,"created":10,"modified":10,"text":2490,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}208食物链 [NOI 2005]20815330093601533009481<!--markdown-->## 带权并查集

> 这题目以前做过，但是好像没做对，今天正好学了带权并查集，才算是恍然大悟。

<!--more-->

题目来源: [_Luogu_](https://www.luogu.org/problemnew/show/P2024)

## 分析

在这道题中，我们总共有三种动物，我们可以分别把他们标号为`0,1,2`,然后在这里，我们规定`2`吃`1`,`1`吃`0`,`0`吃`2`。

然后，作为一道带权并查集的题目，这道题肯定是以并查集为主。其与常规的并查集的不同之处是在操作时多加入一个对权值的判断或者更改操作。我们假设`fa[]`为记录的"父节点",`f[]`为其与"父节点"的权值差。

首先，我们来看插入操作。在这里，插入操作分为两种:两种动物为同一物种或捕食关系。我们以较为简单的同一物种为例。在此情况下，我们先判断这两个动物是否在同一集合内——find(x)==find(y)? 若是的话，则直接比较其相对根节点的权值即可，不同的话则是假命题。而当其不在一个集合中时，我们则需要先做一次合并操作，然后再更新一次`f[]`即可。代码如下：
```c++
int fx = find(x), fy = find(y);
if (fx==fy)
{
	if ( f[x]!=f[y] )
		cnt ++;
}else{
	fa[fx] = fy;
	f[fx] = (f[y] - f[x] + 3) % 3;
}
```

`find()`操作也类似，代码如下:
```C++
int find(int x)
{
	int fx = fa[x];

	if (fa[x]!=x)
	{
		fa[x] = find(fa[x]);
		f[x] = ( f[x] + f[fx] ) % 3;
		return fa[x];
	}

	return x;
}
```

## 代码

```C++
#include <iostream>

using namespace std;

int fa[50010];
int f[50010];

int find(int x)
{
	int fx = fa[x];

	if (fa[x]!=x)
	{
		fa[x] = find(fa[x]);
		f[x] = ( f[x] + f[fx] ) % 3;
		return fa[x];
	}

	return x;
}

int main()
{
	int n,T;
	cin >> n >> T;

	for (int i = 1; i<=n; i++)
	{
		fa[i] = i;
		f[i] = 0;
	}

	int cnt = 0;
	while (T--)
	{
		int q,x,y;
		cin >> q >> x >> y;

		if ( (q==2 && x==y) || (x>n || y>n))
		{
			cnt ++;
			continue;
		}

		if (q==1)
		{
			int fx = find(x), fy = find(y);
			if (fx==fy)
			{
				if ( f[x]!=f[y] )
					cnt ++;
			}else{
				fa[fx] = fy;
				f[fx] = (f[y] - f[x] + 3) % 3;
			}

		}else if (q==2)
		{
			int fx = find(x), fy = find(y);
			if (fx==fy)
			{
				if ( (f[y]-f[x]+3)%3 != 1 )
					cnt ++;
			}else{
				fa[fx] = fy;
				f[fx] = ( f[y] - f[x] - 1 + 3) % 3;
			}
		}

	}

	cout << cnt << endl;
}
```01postpublish0111092495a126bb45484bd4911ecff18fccb{"cid":3,"title":15,"slug":3,"created":10,"modified":10,"text":2563,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}207Haskell基础1020715313125941531312594<!--markdown--># 模块

> | 这一部分的话，按照书上的进度，应该是包括模块的使用方法、常用模块的介绍和模块的构建。这里我们先跳过常用模块的介绍，先来讲一下怎么调用模块和构造模块。

<!--more-->

参考书籍: [_Learn you a Haskell_](http://learnyouahaskell.com/)

# 导入模块

在Haskell中，导入模块的语法是`import ModuleName`,必须放置在所有的函数定义之前。我们以`Date.List`这个模块为例，假设我们要导入该模块并使用模块中的一个函数来定义一个新的函数:

```Haskell
import Data.List

numUniques :: (Eq a) => [a] -> Int
numUniques = length . nub
```

其中,`nub`是一个包含在`Data.List`模块中的函数，它能去除一个列表中的重复元素。就这样，我们快速的写出了一个计算列表中不重复元素个数的函数。

在使用GHCi时，我们一个可以导入模块只要使用如下语法即可:
```Haskell
ghci> :m + Data.List
```

并且我们可以一次性导入多个:

```Haskell
ghci> :m + Data.List Data.Map Data.Set
```

我们亦可以单独导入模块中的某几个函数，写法如下:

```Haskell
import Data.List (nub, sort)
```

我们也可以特别的指出不导入哪个函数:

```Haskell
import Data.List hiding (nub)
```

此外，为了防止函数重名，Haskell提供了两种解决方案。一种是使用`qualified`关键字进行导入，这样导入模块中的函数必须加上模块名的前缀才能调用，如下:

```Haskell
import qualified Data.Map

mapFilter = Data.Map.filter
```

而当我们认为原模块名太长不方便使用时，我们也可以使用别名的方法，如下:

```Haskell
import qualified Data.Map as M

mapFilter = M.filter
```
# 构造模块

在Haskell中，模块要遵循一个特定的结构，大致如下:

```Haskell
module [ModuleName]
{	[FunctionName1]
,	[FunctionName2]
,	......
} where

\\ function definitions here
```

其中，我们可以在一个模块的`where`语句后面导入其他模块。我们也可以定义名字不包含在大括号中的函数，但是这些函数只能在当前文件中被调用，而无法被导入该模块的代码调用。

在模块完成后，保存为正常代码的`.hs`格式，名字必须与模块名相同，然后再同一目录下进行调用便可以了。而当模块名中包含`.`时，比如名字为`Songer.Haskell`,该模块则应该处于`.\Songer\`目录下的`Haskell.hs`中。01postpublish011102dd6cb4e77a1695203ca5e9389f9c1e7{"cid":3,"title":12,"slug":3,"created":10,"modified":10,"text":2839,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}211Wash[贪心]21115333523931533352393<!--markdown-->
# hdu 6000

> | 集训时的一道题，做的时候靠蒙找到了最优情况，实际上是可以严格的证明的。

<!--more-->

## 题解

较为复杂的贪心算法，其难度也主要是集中在选择其贪心策略的问题上，或者说是对贪心策略正确性的证明上。所以我们集中来看这道题的贪心策略。

题目给出了一个`w[]`数组和一个`d[]`数组，要求其中各取`L`个数，然后令其$ max( w_i + d_j )$。所以我们的目标是找到一种组合情况，使得$w_i+d_j$的最大值最小。

首先，对于从`w[]`和`d[]`数组中取出的`L`个数，我们肯定是要取出最小的`L`个。然后，我们可以粗略的看出，当我们的`w[]`越小时，我们取的`d[]`越大越好。因此，我们可以对`w[]`从小到大排序，`d[]`从大到小排序，然后每个各自相加即可。

我们可以较为严格的证明一下: 假设我们已经按照如上顺序放好。那么，我们对于$ \forall i,j (i < j)$, 其一定满足$ w_i \leq w_j , d_i \geq d_j $，所以当我们调换顺序时，这两个数中的最大值一定会大于等于原来的最大值。并且这两个数的调换不会对其他数造成影响，所以我们明显不能调换，原来的顺序即使最佳情况。

此外，还需要注意的一点: 对于此题，由于洗衣机和干洗机都可以重复使用，所以我们刚开始需要从中取出的`L`个数并不仅仅是排序后取前`L`个，而是需要考虑一个机子使用多次的情况，所以这里最好用优先队列，一个个的取出，然后再将下一次能够使用的时间放入。

## 代码

```C++
#include <cstdio>
#include <algorithm>
#include <queue>

using namespace std;

struct Node
{
	long long x,base;

	Node(long long x,long long base):x(x),base(base)	{}

	const bool operator < (const Node &tmp) const{
		return x > tmp.x;
	}
};

long long t1[1000100],t2[1000100];
priority_queue<Node> q1,q2;

int main()
{
	int T;
	scanf("%d",&T);

	for (int cas = 1; cas<=T; cas++)
	{
		q1 = priority_queue<Node>();
		q2 = priority_queue<Node>();

		int l,n,m;
		scanf("%d%d%d",&l,&n,&m);

		for (int i = 1; i<=n; i++)
		{
			long long x;
			scanf("%lld",&x);

			q1.push(Node(x,x));
		}

		for (int i = 1; i<=m; i++)
		{
			long long x;
			scanf("%lld",&x);

			q2.push(Node(x,x));
		}

		for (int i = 1; i<=l; i++)
		{
			Node t = q1.top();
			q1.pop();

			t1[i] = t.x;
			t.x += t.base;

			q1.push(t);
		}

		for (int i = 1; i<=l; i++)
		{
			Node t = q2.top();
			q2.pop();

			t2[i] = t.x;
			t.x += t.base;

			q2.push(t);
		}

		long long ans = 0;
		for (int i = 1; i<=l; i++)
			ans = max(ans, t1[i] + t2[l-i+1]);

		printf("Case #%d: %lld\n",cas,ans);
	}
}
```01postpublish01110433dceaf88aade171637409d9ab9539f{"cid":3,"title":12,"slug":3,"created":10,"modified":10,"text":1990,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}216Maze[搜索]21615335200201535434506<!--markdown--># Codeforces Problem 377A

> 这题也算是一道比较好写的题目，但是前提是能想出正确的解法。

<!--more-->

题目来源: [_Codeforces_](http://codeforces.com/problemset/problem/377/A)

## 分析

题目要求在给出的棋盘中加入$k$面墙，并且能够使得最后所有空白的块联通。如果我们从墙的角度出发，实际判断该从哪里放墙是十分复杂的。但是如果我们从空白的角度出发，我们会发现我们的目的只是确保空白块联通即可。所以我们可以先将所有的空白块设为`X`（墙），然后从其中某一点开始搜索，生成一个指定大小的联通块即可。

## 代码
```C++
#include <iostream>
#include <queue>

using namespace std;

char a[510][510];

struct Node{
	int x,y;
	Node(int x,int y):x(x),y(y)	{}
};

queue<Node> q;
const int xp[] = {0,0,-1,1};
const int yp[] = {1,-1,0,0};

void bfs(int x,int y,int cnt)
{
	if (cnt==0)
		return;

	q.push(Node(x,y));

	while (!q.empty())
	{
		Node t = q.front();
		q.pop();
		if (a[t.x][t.y]=='.')
			continue;

		a[t.x][t.y] = '.';

		//cout << "[ " << t.x << ", " << t.y << "] in " << cnt << endl;
		cnt --;
		if (cnt==0)
			break;

		for (int i = 0; i<4; i++)
			if (a[t.x+xp[i]][t.y+yp[i]]=='X')
				q.push(Node(t.x+xp[i],t.y+yp[i]));
	}
}

int main()
{
	int n,m,k;
	cin >> n >> m >> k;

	for (int i = 0; i<=n+1; i++)
		for (int j = 0; j<=m+1; j++)
			a[i][j] = '#';

	int cnt = n * m;
	for (int i = 1; i<=n; i++)
		for (int j = 1; j<=m; j++)
		{
			cin >> a[i][j];
			if (a[i][j]=='#')
				cnt --;
			else a[i][j] = 'X';
		}

	bool flag = false;
	for (int i = 1; i<=n; i++)
	{
		for (int j = 1; j<=m; j++)
			if (a[i][j]=='X')
			{
				bfs(i,j,cnt-k);
				flag  = true;
				break;
			}
		if (flag)
			break;
	}

	for (int i = 1; i<=n; i++)
	{
		for (int j = 1; j<=m; j++)
			cout << a[i][j];
		cout << endl;
	}
}
```01postpublish11110bf619608a55d95749146532ed23a53bf{"cid":3,"title":11,"slug":3,"created":10,"modified":10,"text":2002,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}218Balance[DP]21815341224201535096244<!--markdown--># POJ 1837

<!--more-->

题目来源: [_POJ_](http://poj.org/problem?id=1837)

## 分析

题目给出了`C`个"hook",要求将`G`个砝码挂在这些"hook"上，使得最后整个杠杆是平衡的。砝码必须被全部使用，但是"hook"不一定要全部挂有砝码。因为题目给出的数据范围较小，$2 \leq C \leq 20 $,$2 \leq G \leq 20$, "hook"的坐标为$[-15,15]$。并且很明显，这个问题也是一个多段决策问题: `G`个砝码时的答案可以由`G-1`个时推理而来，并且也满足最优子结构和无后效性。所以我们使用动态规划来解决此问题。

那么我们首先就需要来确定DP方程。我们最终需要的答案是方案数, 而影响方案数的变量为砝码数量，平衡点位置。也就是说，我们可以建立一个二维的DP方程。`f[][]`,一维存放砝码数量，一位存放平衡点的位置。在这里，平衡位置指的是$\sum_{(i,j)} w_i \times h_j$,而不是物理上实际的平衡位置。

然后我们便需要确立转移方程。这个是较为显然的，当前砝码数的方案数等于其减去上一个砝码在不同"hook"上的情况的方案数的和(下面`w[]`表示砝码重量，`h[]`表示"hook"位置):

~ f_{i,j} = \\sum_{k=1}^C f_{i-1,j-(w_{i-1}\\times h_k)} ~
然后注意因为平衡位置`j`可能为负数，所以加上一个基数即可。

## 代码

```C++
#include <iostream>

using namespace std;

int f[22][2010];
int h[22], a[22];

int main()
{
	int c,g;
	cin >> c >> g;

	for (int i = 0; i<c; i++)
		cin >> h[i];

	for (int i = 1; i<=g; i++)
		cin >> a[i];

	f[0][1000] = 1;
	for (int i = 1; i<=g; i++)
		for (int j = -1000; j<=1000; j++)
			for (int k = 0; k<c; k++)
			{
				if (j-h[k]*a[i]>=-1000 && j-h[k]*a[i]<=1000)
					f[i][j+1000] += f[i-1][j-h[k]*a[i]+1000];
				//if (f[i][j+1000]>0)
				//	cout << i << " " << j << " " << f[i][j+1000] << endl;
			}

	cout << f[g][1000] << endl;
}
```01postpublish01110791d45baec602a786ac8c080eae12d41{"cid":3,"title":36,"slug":3,"created":10,"modified":10,"text":1685,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}226Efficient Tracking [最小生成树]22615343232401535435089<!--markdown-->## CF Gym 101804E

> 这已经是一周前做的题目了，果然我真是能鸽善鹉。。。。

<!--more-->

题目来源: [_Codeforces_](http://codeforces.com/gym/101804/problem/E)

## 分析

这题是很常规的一道题目，其实总体而言就是求最大生成树。不过在求完之后还需要再搜索一遍，然后以节点1为根节点建树即可。

## 代码

```C++
#include <iostream>
#include <vector>
#include <algorithm>


using namespace std;

struct Edge
{
	int from,to,val;

	Edge(int from=0,int to=0,int val=0):from(from),to(to),val(val)	{}

	const bool operator < (const Edge &tmp)const{
		return val > tmp.val;
	}
}e[1000100];

struct Node
{
	vector<int> e;
}node[1010];

int fa[1010];
int anc[1010];

int find(int x)
{
	return x==fa[x]? x : fa[x] = find(fa[x]);
}

int dfs(int x)
{
	for (int i = 0; i<node[x].e.size(); i++)
		if (anc[node[x].e[i]]==0)
		{
			anc[node[x].e[i]] = x;
			dfs(node[x].e[i]);
		}
}

int main()
{
	int n;
	cin >> n;

	for (int i = 1; i<=n; i++)
		fa[i] = i;

	int num = 0;
	for (int i = 2; i<=n; i++)
		for (int j = 1; j<i; j++)
		{
			int x;
			cin >> x;
			e[++num] = Edge(i,j,x);
		}

	sort(e+1,e+1+num);

	long long ans = 0;
	int cnt = 1;
	for (int i = 1; i<=num; i++)
	{
		int fx = find(e[i].from);
		int fy = find(e[i].to);

		if (fx!=fy)
		{
			fa[fx] = fy;

			node[e[i].from].e.push_back(e[i].to);
			node[e[i].to].e.push_back(e[i].from);
			ans += e[i].val;

			cnt ++;
		}

		if (cnt==n)
			break;
	}

	dfs(1);

	cout << ans << endl;
	for (int i = 2; i<=n; i++)
		cout << anc[i] << endl;
}
```01postpublish01110eb8570f938495e304305a48656d44b84{"cid":3,"title":36,"slug":3,"created":10,"modified":10,"text":7122,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}228[学习笔记]Dinic算法(最大流)22815343450201568623795<!--markdown-->
> PS: 更新于2019-9-16。在代码中添加了之前误删除的`currentEdge`变量，能够大幅度加快代码速度。

<!--more-->

## 算法介绍

其实不仅仅是Dinic算法，所有的最大费用流算法的思想都是类似的。其主要思想都是不停的寻找增广路，然后进行增广直至不可行为止。假设我们有一个如下的图，那么算法思路如下:(图中边上的"$x$/$y$"格式中，$x$指的是残量，$y$指的是以流过的流量)

1. 对于一个图，我们首先尝试寻找图中是否有增广路:
![图1](http://ovi2jbxue.bkt.clouddn.com/InblogDinic%E7%AE%97%E6%B3%95-1.png)
2. 增加增广路的流量，增加的值为该条路中最小的残量，生成新的残量网络；
![图2](http://ovi2jbxue.bkt.clouddn.com/InblogDinic%E7%AE%97%E6%B3%95-2.png)
3. 重复1~2操作；
4. 最终图形如下；
![图3](http://ovi2jbxue.bkt.clouddn.com/InblogDinic%E7%AE%97%E6%B3%95-3.png)

这里有一个比较形象的动图:

![图4](http://ovi2jbxue.bkt.clouddn.com/InblogDinic%E7%AE%97%E6%B3%95-4.gif)

## 实现细节

代码参考于: [_Menci_](https://oi.men.ci/dinic-notes/)

要实现Dinic算法，我们要分为几个部分: `Node`和`Edge`结构体，`makeLevelGraph()`和`findPath()`函数和主函数。

### Node

`Node`结构体内需包含三个变量: 指向第一条边的指针`firstEdge`，指向“当前”边的指针`currentEdge`(用于优化代码速度)和存放`level`的变量。

```C++
struct Node
{
    Edge *currentEdge, *firstEdge;
    int level;

    Node()
    {
        firstEdge = NULL;
    }

}node[MAXN];
```

### Edge

`Edge`中的成员变量则比较多，一对分别指向起点和终点的`Node *`类型的指针，分别记录初始值和流量的`capacity`和`flow`变量，还有分别指向下一条边和反向边的`Edge *`类型的`next`和`reverseEdge`指针。其中，比较巧妙地一点是反向边的建立。建立反向边使得我们可以"反悔"，即通过反向的通过改变来实现反悔的功能。

```C++
struct Edge
{
    Node *from, *to;
    int capacity, flow;
    Edge *next, *reverseEdge;

    Edge(Node *from, Node *to, int capacity):from(from),to(to),capacity(capacity),flow(0),next(from->edge)   {}

    ~Edge()
    {
        delete next;
    }
};
```

### makeLevelGraph()

`makeLevelGraph()`函数的作用是检查图中是否还有增广路存在，然后生成各个点的`level`值，其本身其实就是一个朴素的bfs。代码也很简单，如下:

```C++
bool makeLevelGraph(Node *s, Node *t, int n)
{
    for (int i = 1; i<=n; i++)
    {
        node[i].level = 0;
        node[i].currentEdge = node[i].firstEdge;
    }

    queue<Node *> q;
    q.push(s);
    s->level = 1;

    while (!q.empty())
    {
        Node *v = q.front();
        q.pop();

        for (Edge *e = v->firstEdge; e; e = e->next)
            if (e->flow!=e->capacity && e->to->level==0)
            {
                e->to->level = v->level + 1;
                if (e->to == t)
                    return true;
                else
                    q.push(e->to);
            }
    }

    return false;
}
```

### findPath()

`findPath()`则是一个寻找增广路的过程，在这里使用的是dfs，并在dfs的过程中传递和更行此条增广路的最大流的值。

```C++
int findPath(Node *s, Node *t, int limit = INF)
{
    if (s==t)
        return limit;

    for (Edge *&e = s->currentEdge; e; e = e->next)
        if (e->to->level==s->level+1)
        {
            int flow = findPath(e->to, t, min(limit, e->capacity - e->flow));
            if (flow>0)
            {
                e->flow += flow;
                e->reverseEdge->flow -= flow;
                return flow;
            }
        }

    return 0;
}
```

### 主函数

这部分就是一个不断判断判断能否增广然后进行增广的过程。

```C++
int ans = 0;
while (makeLevelGraph(&node[s], &node[t], n))
{
    int flow;
    while ((flow = findPath(&node[s], &node[t]))>0 )
        ans += flow;
}
```

## 例题

题目来源: [_POJ_](http://poj.org/problem?id=1273)

```C++
#include <iostream>
#include <queue>

#define MAXN 210
#define INF 0x3f3f3f3f

using namespace std;

struct Node;
struct Edge;
int n,m;

struct Node
{
    Edge *firstEdge, *currentEdge;
    int level;

    Node()
    {
        firstEdge = NULL;
    }

}node[MAXN];

struct Edge
{
    Node *from, *to;
    int capacity, flow;
    Edge *next, *reverseEdge;

    Edge(Node *from, Node *to, int capacity):from(from),to(to),capacity(capacity),flow(0),next(from->firstEdge)   {}

    ~Edge()
    {
        delete next;
    }
};

struct Dinic
{
    bool makeLevelGraph(Node *s, Node *t, int n)
    {
        for (int i = 1; i<=n; i++)
        {
            node[i].level = 0;
            node[i].currentEdge = node[i].firstEdge;
        }

        queue<Node *> q;
        q.push(s);
        s->level = 1;

        while (!q.empty())
        {
            Node *v = q.front();
            q.pop();

            for (Edge *e = v->firstEdge; e; e = e->next)
                if (e->flow!=e->capacity && e->to->level==0)
                {
                    e->to->level = v->level + 1;
                    q.push(e->to);
                }
        }

        return t->level!=0;
    }

    int findPath(Node *s, Node *t, int limit = INF)
    {
        if (s==t)
            return limit;

        for (Edge *&e = s->currentEdge; e; e = e->next)
            if (e->to->level==s->level+1)
            {
                int flow = findPath(e->to, t, min(limit, e->capacity - e->flow));
                if (flow>0)
                {
                    e->flow += flow;
                    e->reverseEdge->flow -= flow;
                    return flow;
                }
            }

        return 0;
    }

    int operator()(int s, int t, int n)
    {
        int ans = 0;
        while (makeLevelGraph(&node[s], &node[t], n))
        {
            int flow;
            while ((flow = findPath(&node[s], &node[t]))>0 )
            {
                ans += flow;
                // cout << "? " << flow << endl;
            }
            //cout << "! " << ans << endl;
        }
        return ans;
    }

}dinic;

int main()
{
    while (cin >> m >> n)
    {
        for (int i = 1; i<=n; i++)
        {
            delete node[i].firstEdge;
            node[i] = Node();
        }

        for (int i = 1; i<=m; i++)
        {
            int x,y,z;
            cin >> x >> y >> z;
            node[x].firstEdge = new Edge(&node[x], &node[y], z);
            node[y].firstEdge = new Edge(&node[y], &node[x], 0);

            node[x].firstEdge->reverseEdge = node[y].firstEdge;
            node[y].firstEdge->reverseEdge = node[x].firstEdge;
        }

        int ans = dinic(1, n, n);

        cout << ans << endl;
    }
}
```
01postpublish01110e0c07e3c1deb8e561433eb34f5521ae2{"cid":3,"title":20,"slug":3,"created":10,"modified":10,"text":2250,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}229Holidays [最短路]22915343834801535435112<!--markdown-->## Codeforces Gym 101804H

<!--more-->
题目来源: [_Codeforces_](http://codeforces.com/gym/101804/problem/H)

## 分析

这题给出了一个图，给出`q`次询问，要求每次询问中分为从点1到某点的途经城市数小于某个值的最短路。我们只需要让原来存储距离的`dist[]`变为`dist[][]`即可，一维存放的是目的地，另一维存放的是走了多少个城市。然后，在`SPFA()`运行完时递推地传递一下值，令$dist_{i,j} = min( dist_{i,k} ) , k \in [1,j] $即可。

## 代码

```C++
#include <iostream>
#include <algorithm>
#include <vector>
#include <cstring>
#include <queue>

#define INF 0x3f3f3f3f

using namespace std;

struct Edge
{
	int from,to,val;

	Edge(int from,int to,int val):from(from),to(to),val(val)	{}
};

struct Node
{
	int x,cnt;
	Node(int x=0,int cnt=0):x(x),cnt(cnt)	{}
};

vector<Edge> node[1010];

int dist[1010][1010];
int n,m;

bool flag[1010][1010];
queue<Node> q;
void SPFA()
{
	memset(flag,false,sizeof(flag));
	memset(dist,INF,sizeof(dist));
	q.push(Node(1,0));

	dist[1][0] = 0;

	while (!q.empty())
	{
		Node v = q.front();
		q.pop();

		//cout << "! " << v.x << " " << v.cnt << endl;

		for (int i = 0; i<node[v.x].size(); i++)
		{
			if (dist[ node[v.x][i].to ][ v.cnt+1 ] > dist[v.x][v.cnt] + node[v.x][i].val)
			{
				dist[ node[v.x][i].to ][ v.cnt+1 ] = dist[v.x][v.cnt] + node[v.x][i].val;

				if (!flag[node[v.x][i].to][v.cnt+1] && v.cnt+1<=n)
				{
					flag[ node[v.x][i].to ][v.cnt+1] = true;
					q.push( Node(node[v.x][i].to, v.cnt + 1) );
				}
			}
		}
		flag[v.x][v.cnt] = false;
	}
}

int main()
{
	cin >> n >> m;

	for (int i = 0; i<m; i++)
	{
		int x,y,z;
		cin >> x >> y >> z;

		node[x].push_back(Edge(x,y,z));
		//node[y].push_back(Edge(y,x,z));
	}

	SPFA();

	int q;
	cin >> q;

	for (int i = 1; i<=n; i++)
	{
		for (int j = 1; j<=n; j++)
		{
			dist[i][j] = min(dist[i][j], dist[i][j-1]);
			//cout << dist[i][j] << " ";
		}
		//cout << endl;
	}

	while (q--)
	{
		int x,y;
		cin >> x >> y;
		y++;

		if (dist[x][y]!=INF)
			cout << "=] " << dist[x][y] << endl;
		else cout << "=[" << endl;
	}
}

```01postpublish011101d5016a9752339d6e16904ec0804f493{"cid":3,"title":52,"slug":3,"created":10,"modified":10,"text":9697,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}224[学习笔记]匈牙利算法(最大二分图匹配)22415342618001543921800<!--markdown-->> 尽管欠了一周的博客没有整理，不过我觉得还是先整理一下今天上课的内容吧。。。。这篇博客可能比较长，请善用网页右侧的目录。

<!--more-->

## 算法介绍

### 一些基础概念

**二分图**: 对于图$G$，若其所有顶点可以被分别放置在两个集合$X$和$Y$中，使得对于所有的边满足边所连接的两个顶点分别在这两个集合中，这个图便是二分图。

匈牙利算法解决的是**二分图的最大匹配问题**。若给定一个二分图$G$，$M$边集为$G$的一个子集，且满足$M$中任意两条边不会依附于同一个顶点，则称$M$是图$G$的一个匹配。而包含边数最多的匹配便是二分图的最大匹配。

此外，还有一些其他的基础概念:

1. **未盖点**: 设$M$为图$G$的一个匹配，$V_i$是图$G$的一个顶点，若$V_i$不与边集$M$中任意一条边相关联，则称$V_i$为未盖点;
2. **交错路**: 设$P$为图$G$的一条路，若$P$中任意两条相邻的边一条属于$M$，一条不属于$M$，则称$P$为交错路;
3. **可增广路**: 两个端点都为未盖点的成为可增广路。

### 算法原理

我们还是以较为常用的男女配对问题为例。假设我们有三个男生，三个女生，在他们中间存在着几对暧昧关系(不考虑奇怪的取向(/▽＼))。我们假设有暧昧关系的都可以成为情侣，那么问最多能凑成几对情侣呢？

我们先假设暧昧关系是如下图所示的:

![图1](https://oi-songer.github.io/In%20Blog/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95-1.png)

那么我们便开始配对的过程:

1. 我们首先来看男生1，他同时喜欢女生1，2，3.在这里，我们先假设他选择女生1，然后我们连接男生1与女生1的边。
![图2](https://oi-songer.github.io/In%20Blog/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95-2.png)
2. 然后，我们再来看男生2，他同时喜欢女生1和女生2。我们首先去看女生1，发现她已经和男生1配对了，但是男生1还有其他的选项，所以我们会让男生1换到下一个选择女生2，男生2选择女生1。
![图3](https://oi-songer.github.io/In%20Blog/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95-3.png)
3. 最后，我们来看男生3，他也同时喜欢女生1和女生2。我们先看女生1，她已经和男生2配对了，我们便来看看男生2是否能改动，然后发现可以配对的女生2已经和男生1配对了。这时我们再看男生1，发现其可以选择女生3，所以男生1会和女生3配对，男生2和女生2配对，男生3和女生1配对。
![图4](https://oi-songer.github.io/In%20Blog/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95-4.png)

那么，从图中可以看出，这个过程其实是一个寻找增广路的过程。某个男生还可以和某个没有配对过的女生配对，说明这条交错路的一段为未盖点，而因为另一端的男生一定还没有选择女生，也是未盖点，所以此时就存在一条可增广路，然后更改染色的边即可。

## 实现细节

虽说看上去比较复杂，但是实际上匈牙利算法的代码实现很是简单，其主要分为两部分:

在主函数中，我们枚举每个点，然后尝试配对，调用`find()`函数，返回是否配对成功。`cnt`则用来记录配对成功的数量，即最大匹配时边的数量。

```C++
for (int i = 0; i<n; i++)
{
	memset(flag,false,sizeof(flag));
    if (find(i))
    	cnt ++;
}
```

而在`find()`函数中，我们枚举所有和当前点相连的点，检查其是否走过，然后检查其是否可选。检查其是否可选时分为两种情况: 一种是其未被选择过，另一种是本来配对的点可以选择其他的点，这是我们需要递归调用函数。其中`belong[]`数组记录与之配对的点,我们初始为`-1`。

```C++
bool find(int x)
{
	for (int i = 0; i<edge[x].size(); i++)
    	if ( !flag[ edge[x][i] ] )
        {
        	int v = edge[x][i];
        	flag[v] = true;
            if (belong[v]==-1 || find(belong[v])
            {
            	belong[v] = x;
                return true;
            }
        }
    return false;
}
```

## 例题

### POJ 1274

题目来源: [_POJ_](http://poj.org/problem?id=1274)

这道题算是非常裸的一道题目了，甚至可以直接用临界表:

```C++
#include <iostream>
#include <cstring>

using namespace std;

bool mp[210][210];
bool flag[410];
int belong[210];
int n,m;

bool find(int x)
{
    for (int i = 1; i<=m; i++)
        if (mp[x][i]==true && !flag[i])
        {
            flag[i] = true;
            if (!belong[i] || find(belong[i]))
            {
                belong[i] = x;
                return true;
            }
        }
    return false;
}

int main()
{
    while (cin >> n >> m)
    {
        memset(mp,false,sizeof(mp));
        memset(belong,0,sizeof(belong));

        for (int i = 1; i<=n; i++)
        {
            int x;
            cin >> x;
            for (int j = 1; j<=x; j++)
            {
                int y;
                cin >> y;
                mp[i][y] = true;
            }
        }

        int cnt = 0;
        for (int i = 1; i<=n; i++)
        {
            memset(flag,false,sizeof(flag));   
            if (find(i))
                cnt ++;
        }

        cout << cnt << endl;
    }
}
```

### hdu 3729

题目来源: [_hdu_](http://acm.hdu.edu.cn/showproblem.php?pid=3729)

题目也很简单，就是一个点对应的不再是一堆点，而是一段区间，这时我们直接记下给区间的左端点和右端点即可:

```C++
#include <iostream>
#include <cstring>

using namespace std;

bool flag[100100];
int l[100],r[100];
int belong[100100];
int ans[100];

bool find(int x)
{
    for (int i = l[x]; i<=r[x]; i++)
        if (!flag[i])
        {
            flag[i] = true;
            if (belong[i]==0 || find(belong[i]))
            {
                belong[i] = x;
                return true;
            }
        }
    return false;
}

int main()
{
    int T;
    cin >> T;
    while (T--)
    {
        memset(belong,0,sizeof(belong));

        int n;
        cin >> n;
        for (int i = 1; i<=n; i++)
            cin >> l[i] >> r[i];

        int cnt = 0;
        for (int i = n; i>0; i--)
        {
            memset(flag,false,sizeof(flag));
            if (find(i))
                ans[++cnt] = i;
        }

        cout << cnt << endl;
        for (int i = cnt; i>1; i--)
            cout << ans[i] << " ";
        cout << ans[1] << endl;
    }
}
```

## 引申用法

二分图匹配本身是一个比较固定的问题，但是能够将问题转化为二分图匹配的或者说甚至是等价的问题其实很多，下面会列举几种。

### 最小点覆盖

**最小点覆盖**要求用尽可能少的点来使得图中的每条边都与某个选择的点相关联。点的数量其实即为最大匹配数，以下是证明:

充分性: 假设二分图的最大匹配边集为$M$,我们选择其中每条边的某个定点，并且没有顶点相邻。此时一定是最小点覆盖。因为假设不是，即存在某个边未被覆盖，那么便存在了一条可增广路，与前提条件不符。

必要性: 仍然考虑二分图的最大匹配，我们只考虑最大匹配组成的交错路，明显我们需要至少$|M|$个点来覆盖所有的边，所以最小为$|M|$。

### 最小边覆盖

**最小边覆盖**，与上面类似，存在边集$E$使得图$G$中所有顶点都连在边集$E$中的某条边上，并且边集最小。

假设我们想要选边，为了边数尽可能小，我们肯定会优先选择能够对应两个点的边，即从一个交错路中取边。而最长的交错路便为最大匹配的边集所在的交错路，所以我们可以首先选择最大匹配的边集$M$中的所有边。此时，我们选了$|M|$个边，还剩下$ n - 2\times |M| $个点，而剩下的点都需要一个个的用边去掉，所以最后为$ |M| + n - 2 \times |M| = n - |M| $。即最小边覆盖=点的总数-最大匹配。

### DAG图的最小路径覆盖

用尽量少的不相交简单路径覆盖有向无环(DAG)G的所有顶点，这就是DAG图的**最小路径覆盖**问题。

解决这个问题需要对图做一个转化。我们令所有的点都分为两部分，分别放在集合$X$和$Y$中，然后令所有的边都从集合$X$指向集合$Y$,之后再求最大二分图匹配。而我们要求的最小路径覆盖则为节点总数减去最大匹配数。证明如下:

我们首先假设倘若没有连边，我们边需要从所有的点开始，所以路径数等于点数$n$。而我们每多一条边，我们便可以少走一条路径，而使用最大二分图匹配的方法既保证了我们每个点出度和入度都最大为1，又能算出最多有多少可行的连边，所以最后的答案为$ n - |M| $。

### 二分图的最大独立集

**最大独立集**问题是指在$n$个点的图$G$中选出$m$个点，使这$m$个点两两之间没有边, 然后令$m$最大。

这个问题的数学证明也是较为显然的。我们需要去掉某些点，使得剩下的节点互不连接。而很明显，在最大二分图匹配中，所有的没有连接在$M$边集中的点都互不连接，而我们可以在与$M$边集相连的$2 \times |M|$个点中去掉$|M|$个，使得剩下$|M|$个互不连接，所以最后的答案也是$n-|M|$。
01postpublish0111071f37a791b60a0f9d32b8470af8b5b9d{"cid":3,"title":17,"slug":3,"created":10,"modified":10,"text":1580,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}238Writing Code [DP]23815350959201535435203<!--markdown-->## CF 544 C

> CF的题目编号与比赛编号挺乱的，以后为了统一，博客上一律使用题目编号。之前的都是比赛编号，我有时间(bu)可能会改一下。

<!--more-->

题目来源: [_Codeforces_](http://codeforces.com/problemset/problem/544/C)

## 分析

很明显，这是一个DP。我们可以发现影响方案数的状态有如下三个:
1. 取到哪几个人;
2. 完成的代码行数;
3. bug数量。

所以，我们可以使用一个三位数组来存储方案数。`f[][][]`，第一维存储取到了第几个人，第二维为代码行数，第三位为bug总数，那么状态转移方程如下:

~ f[i][j][k] += f[i-1][j-1][k-a[i]] ~
~ f[i][j][k] += f[i][j-1][k-a[i]] ~

而很明显，我们可以将这个三维数组优化为二维，去掉第一维，最后的方程如下:

~ f[j][k] += f[j-1][k-a[i]] ~

## 代码

```C++
#include <iostream>

using namespace std;

long long f[510][510];
int a[510];

int main()
{
    int n,m,b;
    long long p;
    cin >> n >> m >> b >> p;

    for (int i = 1; i<=n; i++)
        cin >> a[i];

    f[0][0] = 1;
    for (int i = 1; i<=n; i++)
        for (int j = 1; j<=m; j++)
        {
            for (int k = b; k>=0; k--)
                if (k-a[i]>=0)
                {
                    f[j][k] += f[j-1][k-a[i]];
                    f[j][k] %= p;
                }
        }

    long long ans = 0;
    for (int i = 0; i<=b; i++)
    {
        ans += f[m][i];
        ans %= p;
    }
    cout << ans;
}
```01postpublish01110167faa506f7d5c6f676b571ec0e97013{"cid":3,"title":12,"slug":3,"created":10,"modified":10,"text":1020,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}237Oulipo [KMP]23715350941801535435192<!--markdown-->## POJ 3461

<!--more-->

题目来源: [_POJ_](http://poj.org/problem?id=3461)

## 分析

一道裸的KMP，没有什么好说的。

## 代码

```C++
#include <cstdio>
#include <cstring>

#define MAXN 1000100

char a[MAXN],b[MAXN];
int f[MAXN];
int n,m;
int cnt;

void getFail()
{
    f[0] = 0;
    //f[1] = 0;
    for (int i = 1; i<m; i++)
    {    
        int j = f[i-1];
        while (j && b[i]!=b[j])    j = f[j-1];
        f[i] = b[i]==b[j]?j+1:0;
    }

    return;
}

void find()
{
    int j = 0;
    for (int i = 0; i<n; i++)
    {
        while (a[i]!=b[j] && j) j = f[j-1];
        if (a[i]==b[j])    j++;
        if (j==m)
            cnt ++;
    }
}

int main()
{
    int T;
    scanf("%d",&T);
    while (T--)
    {
        cnt = 0;
        
        scanf("%s",b);
        scanf("%s",a);

        n = strlen(a);

        m = strlen(b);

        getFail();

        find();

        printf("%d\n",cnt);
    }
}
```
01postpublish011108bb0f3482b3621463b3d4f4656ce9435{"cid":3,"title":7,"slug":3,"created":10,"modified":10,"text":1840,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}258Sorting25815354228601535435309<!--markdown-->## hdu 6281

<!--more-->

题目来源: [_hdu_](http://acm.hdu.edu.cn/showproblem.php?pid=6281)

## 分析

题目本身是比较简单的，要求输出字典序最小的序列`P`，使其满足下面的式子:

~ \\frac{ a_{p_{i-1}} + b_{p_{i-1}} }{ a_{p_{i-1}} + b_{p_{i-1}} + c_{p_{i-1}} } \\leq \\frac{ a_{p_i} + b_{p_i} }{ a_{p_i} + b_{p_i} + c_{p_i} } ~

我们只需要按照上面的式子对`a,b,c`构成的结构体排序，就可以得到答案。不过这题的问题在于用浮点数会产生浮点误差，而用整数的话则会爆`long long`。所以我们需要化简一下式子:

~ \\begin{aligned} \\frac{c_{p_{i-1}}}{a_{p_{i-1}} + b_{p_{i-1}} + c_{p_{i-1}}} & \\geq \\frac{c_{p_i}}{a_{p_i} + b_{p_i} + c_{p_i}} \\\\	\\frac{c_{p_{i-1}}}{a_{p_{i-1}} + b_{p_{i-1}} } & \\geq \\frac{c_{p_i}}{a_{p_i} + b_{p_i}} \\\\	c_{p_{i-1}} \\times ( a_{p_i} + b_{p_i} ) & \\geq c_{p_i} \\times ( a_{p_{i-1}} + b_{p_{i-1}} )	\\end{aligned} ~

## 代码

```C++
#include <iostream>
#include <algorithm>

using namespace std;

struct Node
{
    long long val[2];
    int id;

    Node(int a,int b,int c,int id):id(id)
    {
        val[0] = (long long)c;
        val[1] = (long long)a+b;
    }

    Node()  {}

    const bool operator < (const Node &tmp)const{
        return (val[0]*tmp.val[1] > tmp.val[0]*val[1]) || (val[0]*tmp.val[1] == tmp.val[0] * val[1] && id < tmp.id);
    }
}node[1010];

int main()
{
    int n;
    while (~scanf("%d",&n))
    {
        for (int i = 1; i<=n; i++)
        {
            int x,y,z;
            cin >> x >> y >> z;

            node[i] = Node(x,y,z,i);
        }

        sort(node+1, node+1+n);

        for (int i = 1; i<n; i++)
            cout << node[i].id << " ";
        cout << node[n].id << endl;
    }
}
```01postpublish011109bef484118714c4392a7037f527bb67f{"cid":3,"title":18,"slug":3,"created":10,"modified":10,"text":1016,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}267Triangle Partition26715354348601535435336<!--markdown-->## hdu 6300

<!--more-->

题目来源: [_hdu_](acm.hdu.edu.cn/showproblem.php?pid=6300)

## 分析

题目给出了$3n$个点，要求用它们组成$n$个互不相交的三角形。并且题目保证了不存在共线的点。所以我们只需要按照$x$坐标排序，然后每三个组成一个三角形即可。

## 代码

```C++
#include <iostream>
#include <algorithm>

using namespace std;

struct Node
{
    int x,y,id;
    
    const bool operator <(const Node &tmp)const{
        return x < tmp.x ;
    }
}node[3010];

int main()
{
    int T;
    cin >> T;

    while (T--)
    {
        int n;
        cin >> n;

        for (int i = 1; i<=3*n; i++)
        {
            cin >> node[i].x >> node[i].y;
            node[i].id = i;
        }

        sort(node+1, node+3*n+1);

        for (int i = 1; i<=n; i++)
        {
            cout << node[i*3-2].id << " " << node[i*3-1].id << " " << node[i*3].id << endl;
        }
    }
}
```01postpublish01110cefb1cb7a2ce63c1bbed60eb9e6e8174{"cid":3,"title":27,"slug":3,"created":10,"modified":10,"text":2164,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}235Cyclic Nacklace [KMP变型]23515350937601535435180<!--markdown-->## hdu 3746

<!--more-->

题目来源: [_hdu_](acm.hdu.edu.cn/showproblem.php?pid=3746)

## 分析

题目给出了一个字符串`s`，要求求出我们最少需补充多少个字符，使得这个字符串内存在循环节(循环节可以总共只有`1`个,即`s`自己)。

首先，我们可以证明，此时的循环节一定是`s`的最小循环节。对于最小循环节`t1`，我们假设最后需要补`x`个。假设我们存在另一个循环节`t2`，使得最后需要补的字符个数为`y`，且`y<x`。因为此时这两个循环节肯定不是互相包含的，那么他们肯定存在一个不等于`t1`和`t2`的公共循环节，此时这个循环节就会是最小循环节，与前提条件不符，说明不存在这样的循环节`t2`。

那么，现在的问题便转化为了求`s`的最小循环节。这里需要一个较为巧妙地方法。我们知道，再求KMP的`fail[]`数组时，我们能够求出其自匹配的最长长度，而此时除了最后几个没有凑够一个循环节的点和第一个循环节内的点，而此时`i-fail[i]`的最大值变为循环节的长度。此外，我们可以发现，我们只需要j计算每个循环节最后一个点的`i-fail[i]`即可。所以最后只需不停执行如下语句即可:
```C++
for (int i = s.length(); i>0; i = f[i])
	ans = max(ans, i-f[i]);
```

## 代码

```C++
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

string s;
int f[100100];

void getFail()
{
    f[0] = 0;

    for (int i = 1; i<s.length(); i++)
    {
        int j = f[i];
        while (j && s[i]!=s[j])
            j = f[j];
        f[i+1] = s[i]==s[j]? j+1 : 0;
    }
}

int main()
{
    int T;
    cin >> T;
    while (T--)
    {
        cin >> s;
        getFail();

        int ans = 1;
        for (int i = s.length(); i>0;)
        {
            int j = f[i];
            ans = max(ans, i-j);
            i = j;
        }

        if (ans==s.length())
            cout << ans << endl;
        else
            cout << (ans - s.length()%ans)%ans << endl;
    }
}

```01postpublish01110f31bb82acc183cf7f47ebac200b46f98{"cid":3,"title":38,"slug":3,"created":10,"modified":10,"text":1919,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}233Heavy Transportation [最短路变型]23315350918401535435151<!--markdown-->## POJ 1797

> 之前电脑的电源适配器坏了，送厂换新，花了几天。因此，这几天我一直在学(hua)习(shui)，博客一直没有更新。本来博客就拖了很久，这一下感觉根本补不上了。。。

<!--more-->

题目来源: [_POJ_](http://poj.org/problem?id=1797)

## 分析

题目给出了一个无向带权图，要求给出一条从`1`到`n`的最小的边权值最大的路。其实这就是一个最短路的简单变形，只需要更改一下判断条件即可，将原来的$dist_j > dist_i + val_{i,j} $换为$ ans_j < min( dist_i, val_{i,j} ) $即可。然后由于这个图较为稠密，所以要用Dijsktra.

## 代码

```C++
#include <cstdio>
#include <cstring>
#include <algorithm>

#define INF 0x3f3f3f3f

using namespace std;

int n,m;
int mp[1010][1010];
bool flag[1010];
int ans[1010];

int dijkstra()
{
    for (int i = 1;i<=n;i++)
    {
        ans[i]=mp[1][i];
        flag[i] = false;
    }
    ans[1]=0;

    for (int i = 1;i<=n;i++)
    {
        int minn = -1, v;
        for (int j = 1; j<=n; j++)
        {
            if (!flag[j] && ans[j] > minn)
            {
                minn = ans[j];
                v = j;
            }
        }
        flag[v] = true;
        for (int j = 1; j<=n; j++)
        {
            if (!flag[j] && ans[j] < min(ans[v],mp[v][j]))
                ans[j] = min(ans[v],mp[v][j]);
        }
    }
    return ans[n];
}

int main()
{
    int T;
    scanf("%d",&T);
   
    for (int cas = 1; cas<=T; cas++)
    {
        memset(mp,0,sizeof(mp));

        scanf("%d%d",&n,&m);

        for (int i = 1; i<=m; i++)
        {
            int x,y,z;
            scanf("%d%d%d",&x,&y,&z);
            mp[x][y] = mp[y][x] = z;
        }

        int an = dijkstra();

        printf("Scenario #%d:\n%d\n\n",cas,an);
    }
}
```
01postpublish01110fe8be8881658e4b5d06743bebf016e69{"cid":3,"title":15,"slug":3,"created":10,"modified":10,"text":3287,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}286Haskell基础1128615367469401536747043<!--markdown-->## 构造自定义类型

> 被树链剖分劝退的我。。。先整理一下Haskell的基础知识整理一下心情。

<!--more-->

参考书籍: [_Learn you a Haskell_](http://learnyouahaskell.com/)

### 定义新的数据类型

**data**是常用的构建新的数据类型的方法。在标准库中，`Bool`类型便是用`data`构造的:
```Haskell
data Bool = False | True
```
在使用`data`是，其结构如下:
```Haskell
data [数据类型名称] = [值构造器(value constructr)]
```
其中，`|`读作“或”，用来分割不同的值。例如，`Int`类型也可以像这样定义(虽然实际并不是):
```Haskell
data Int = -2147483638 | -2147483637 | ... | 2147483637
```

### 值构造器

难道我们构造一个新的数据类型一定要把所有的情况列出来吗？如果我们想要构造一个像C++里的结构体或类该怎么办呢？这时候，我们就需要**值构造器(value constructor)**了。

假设我们想要构造一个圆形(circle)，包含圆心坐标和半径三个变量，那么我们便可以定义如下:

```Haskell
data Circle = Circle Float Float Float
```

这句话什么意思呢？我们使用了一个`Circle`值构造器，传入三个参数，返回一个`Circle`类型的变量。这里的两个`Circle`分别代表数据类型和值构造器，它们的名字可以不同。更有甚者，假如我们想要构造一个`Shape`类型，它既可以是一个四边形，又可以是一个圆形，那么我们便可以这样写:

```Haskell
data Shape = Circle Float Float Float | Rectangle Float Float Float Float
```

这样，我们使用`Circle`或`Rectangle`都可以构造出一个`Shape`类型的值。其实，实际上，值构造器就是一个函数。不过，当我们想对`Shape`类型进行操作时，该怎么办呢？假如我们想要求一个`Shape`的面积，那么可以这么写：

```Haskell
area :: Shape -> Float
area (Circle _ _ r) = pi * r ^ 2
area (Rectangle x1 y1 x2 y2) = (abs $ x2 - x1) * (abs $ y2 - y1)
```

当然，我们也能够在构造函数中使用自己创建的数据类型，譬如，我们可以创建一个`Point`类型，用来构建`Shape`:

```Haskell
data Point = Point Float Float
data Shape = Circle Point Float | Rectangle Point Point
```

这样的话，我们的`area`函数也需要改一下：

```Haskell
area :: Shape -> Float
area (Circle _ r) = pi * r ^ 2
area (Rectangle (Point x1 y1) (Point x2 y2)) = (abs $ x2 - x1) * (abs $ y2 - y1)
```
### 将类型导出到模块中

既然我们可以自定义类型，那么我们肯定可以将它写入到自定义模块中。但是这时候的模块应该怎么写呢？我们知道，函数从模块导出的话，大概可以这么写:
```Haskell
moudle Shape
{ area
, nudge
}where
```

而对于数据类型，我们可以这样写:
```Haskell
moudle Shape
{ Point(Point)
, Shape(Rectangle, Circle)
, area
, nudge
}where
```

我们需要先写数据类型，然后在括号中写导出的构造函数。假如想导出所有的构造函数，我们可以在括号中填入`..`，大概像这样`Shape(..)`。假如我们只写类型名而不写构造函数的话，则不会到处任何构造函数。01postpublish01110bff8da0e6b60a3c9eaaa90a2c4297825{"cid":3,"title":16,"slug":3,"created":10,"modified":10,"text":1356,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}284我的Blog规范28415358553401535855441<!--markdown-->> 感觉自己有些强迫症，最近总是想把所有的东西都整理的整齐一些。。。这个博客也是，如果归类做的不好或者格式不统一就感觉很不爽。。。所以想要规范一下自己博客和代码的相关格式。

<!--more-->

## 博客

1. 关于具体题目的博客，博客标题为题目的名称，若有较为明显的算法，在其后用"[]"进行标注。在博客内容第一行注明其网站与题目编号，然后是可写可不写的概述或随想，之后是题目来源的网址;
2. 对于Codeforces上的题目，题目编号统一使用preblemset中的编号，而不是用比赛编号，防止混淆;
3. 图片目前都放在七牛云的图床上;
4. 变量名统一使用"``"标注，如有公式需求则可以使用Latex。

## Latex

1. 非换行公式用`$ $`进行标注，需换行的标注由于javascript的判断问题，不使用`$$ $$`而是`~ ~`进行标注;
2. 由于markdown转码时会将Latex中的"\\"误以为保留下个字符，所以所有的"\"应该变为两个，即"\\\\"。

## 代码

1. 不使用`<bits/stdc++.h>`;
2. 可以使用`using namespace std;`;
3. 结构体或类名采用Pascal命名法，变量名或函数名采用骆驼命名法;
4. 在数学表达式的符号与数字中间需要加空格;
5. 大括号换行。01postpublish011109e34c5da74bf442c99bb90f406b243cb{"cid":3,"title":18,"slug":3,"created":10,"modified":10,"text":1983,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}250DeBruijin [搜索]25015353315401535435214<!--markdown-->## hdu 2894

<!--more-->

题目来源: [_hdu_](http://acm.hdu.edu.cn/showproblem.php?pid=2894)

## 分析

题目要求，给出一个长度为$k ( 2 \leq k \leq 11) $，我们需要生成一个`0`,`1`组成的最长环形字符串，使得其中任意`k`个连续的子串互不相等。题目要求输出该字符串长度与字符串本身。

我们在求字符串之前，可以先看一下它的长度有什么规律。我们可以证出长度$ m = 2^k $。因为长度为`k`的`01`字符串一共存在$2^k$中情况，而$m=2^k$时它也有$2^k$个子串，所以我们只需要让每一个子串各不相同就好了。

然后我们只需要较为暴力的求出该串即可。我这里使用的时深搜的方法。因为每个字串的下一个相邻的子串只有两种情况，我们搜索一下，看哪一种最后能够将所以子串生成出来即可。

## 代码

```C++
#include <iostream>
#include <cmath>
#include <iomanip>
#include <cstring>

using namespace std;

int dist[100100];
int n,k;

bool dfs(int x)
{
    if (dist[x]==n)
        return true;
    
    for (int i = 0; i<2; i++)
        if (dist[(x*2+i)%n]==0)
        {
            dist[(x*2+i)%n] = dist[x] + 1;
            if (dfs((x*2+i)%n))
                return true;
            dist[(x*2+i)%n] = 0;
        }

    return false;
}

int trans(int x)
{
    int t = n/2;
    return x/t;
}

int main()
{
    while (cin >> k)
    {
        n = pow(2,k);
        cout << pow(2,k) << " ";

        dist[0] = 1;
        memset(dist,0,sizeof(dist));
        
        dfs(0);

        int t = 0;
        cout << trans(t);
        for (int i = 1; i<n; i++)
            for (int j = 0; j<2; j++)
                if (dist[(t*2+j)%n]==dist[t]+1)
                {
                    t = t*2 + j;
                    t %= n;
                    cout << trans(t);
                }
        cout << endl;
    }
}
```01postpublish011103ac4bf7766eeda7c06d70ffc946aad32{"cid":3,"title":35,"slug":3,"created":10,"modified":10,"text":2223,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}251Antenna Placement [最小点覆盖]25115353373001535435241<!--markdown-->## POJ 3020

<!--more-->

题目来源: [_POJ_](http://poj.org/problem?id=3020)

## 分析

题目给出一个$ n \times m $的由`*`和`o`组成的图，要求用一些宽度为`1`，长度为`2`的板子将所有的`*`覆盖。要求求出最少需要多少板子。

我们假设若两个`*`相邻，那么它们之间便有一条边。那么我们可以看到，对于任意一个点，与其相邻的任意两个点之间一定不存在边。所以由此构造出来的图满足二分图的性质。而这个问题明显的转化为了一个二分图的最小点覆盖问题。所以我们直接套用匈牙利算法即可。

## 代码

```C++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

char mp[50][20];
bool flag[50][20];
int belong[50][20][2];
int n,m;

bool inmp(int x,int y)
{
    return x>=0 && x<n && y>=0 && y<m;
}

const int xp[] = {0,0,-1,1};
const int yp[] = {1,-1,0,0};
bool find(int x, int y)
{
    for (int i = 0; i<4; i++)
        if (inmp(x+xp[i],y+yp[i]) && mp[x+xp[i]][y+yp[i]]=='*' && !flag[x+xp[i]][y+yp[i]])
        {
            flag[x+xp[i]][y+yp[i]] = true;
            if (belong[ x+xp[i] ][ y+yp[i] ][0]==-1 || find( belong[ x+xp[i] ][ y+yp[i] ][0], belong[ x+xp[i] ][ y+yp[i] ][1]) )
            {
                belong[ x+xp[i] ][ y+yp[i] ][0] = x;
                belong[ x+xp[i] ][ y+yp[i] ][1] = y;
                return true;
            }
        }
    return false;
}

int main()
{
    int T;
    cin >> T;
    while (T--)
    {
        memset(belong,-1,sizeof(belong));

        cin >> n >> m;

        int num = 0;
        for (int i = 0; i<n; i++)
            for (int j = 0; j<m; j++)
            {
                cin >> mp[i][j];
                if (mp[i][j]=='*')
                    num++;
            }

        int cnt = 0;
        for (int i = 0; i<n; i++)
            for (int j = 0; j<m; j++)
                if (mp[i][j]=='*')
                {
                    memset(flag,false,sizeof(flag));
                    if (find(i,j))
                        cnt ++;
                }

        cout << num - cnt/2 << endl;
    }
}
```01postpublish01110e32a1a3251742dfc3d4043efb9406e3e{"cid":3,"title":33,"slug":3,"created":10,"modified":10,"text":4294,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}256Equivalent Sets [强连通分量]25615354195001535435291<!--markdown-->## hdu 3836

<!--more-->

题目来源: [_hdu_](http://acm.hdu.edu.cn/showproblem.php?pid=3836)

## 分析

题目给出了几个集合，并且给出了几组它们之间的关系，要求至少需要在测定几次它们之间的关系(小于关系)，能够验证出它们是否相等。同时，题目给出可以通过$A < B\ \&\ B < A $的方式来验证它们是否相等。

题目要求测定次数最小，那么什么情况下测量的次数会最小呢？或者说有哪些测量会是不必要的呢？我们假设两个集合之间的小于关系是一条有向边，那么当几个集合成环时，它们一定相等。而此时的边数也一定已经是最小了。

但是整个图最后一定要组成一个环吗?很明显，几个相交的环也能推出其中所有点的相等关系，因为等于关系是可以传递的。那么到底组成几个环最好呢？这该怎么算呢？

我们不妨想一下环的性质是什么呢？所有点的入度和出度都不为$0$。那么我们只要去掉为$0$的点便能成环。理论上，我们最好将入度为$0$的点和出度为$0$的点连在一起，但是有时候它们数目不一样，所以我们需要再将多出来的连接到任意一个点上即可。

不过这样成环后图一定联通吗？假设我们能分别用两条边生成两个不连通的环，那么可以证明我们用这两条边也能生成一整个环，所以一定存在最后的图联通的方案。但是若初始的图中就有一个环，那么就比较麻烦了。此时我们需要用Tarjan来求强连通分量，然后缩点，把其看成一个点即可。

因此，最后的答案是$ max(\sum_1^n in_i, \sum_1^n out_i) $，$in_i$和$out_i$记录的是每个强连通分量的入度和出度。

## 代码

```C++
#include <iostream>
#include <stack>
#include <algorithm>
#include <cstring>

#define MAXN 20010

using namespace std;

struct Edge;

struct Node
{
    Edge *edge;
    int dfn, low, color;
    bool flag;

    Node()
    {
        flag = false;
        dfn = low = color = 0;
        edge = NULL;
    }
}node[MAXN];

struct Edge
{
    Node *from, *to;
    Edge *next;

    ~Edge()
    {
        delete next;
    }

    Edge(Node *from, Node *to):from(from),to(to),next(from->edge)   {}
};

int cnt = 0;

stack<Node *> s;
void Tarjan(Node *x)
{
    static int num = 0;
    x->low = x->dfn = ++num;
    x->flag = true;
    s.push(x);

    for (Edge *e = x->edge; e; e = e->next)
    {
        if (e->to->dfn==0)
        {
            Tarjan(e->to);
            x->low = min(x->low, e->to->low);
        }else if (e->to->flag)
            x->low = min(x->low, e->to->dfn);
    }

    if (x->dfn==x->low)
    {
        x->flag = false;
        x->color = ++cnt;

        while ( !s.empty() && s.top()!=x)
        {
            Node *v = s.top();
            v->color = cnt;
            v->flag= false;
            s.pop();
        }
        if (!s.empty())
            s.pop();
    }
}

int in[MAXN],out[MAXN];

int main()
{
    int n,m;
    while (cin >> n >> m)
    {
        memset(out,0,sizeof(out));
        memset(in,0,sizeof(in));
        for (int i = 1; i<=n; i++)
        {
            delete node[i].edge;
            node[i] = Node();
        }
        cnt = 0;

        for (int i = 1; i<=m; i++)
        {
            int x,y;
            cin >> x >> y;
            node[x].edge = new Edge(&node[x],&node[y]);
        }

        for (int i = 1; i<=n; i++)
            if (node[i].dfn==0)
                Tarjan(&node[i]);

        for (int i = 1; i<=n; i++)
        {
            for (Edge *e = node[i].edge; e; e = e->next)
                if (node[i].color!=e->to->color)
                {
                    out[node[i].color] ++;
                    in[e->to->color] ++;
                }
        }

        int ans[2];
        ans[0] = ans[1] = 0;
        
        for (int i = 1; i<=cnt; i++)
        {
            if (!in[i])
                ans[0]++;
            if (!out[i])
                ans[1]++;
        }
        if (cnt==1)
            cout << 0 << endl;
        else cout << max(ans[0],ans[1]) << endl;
    }
}
```01postpublish01110211b37cc4ba06c8847a22990c193ccc0{"cid":3,"title":39,"slug":3,"created":10,"modified":10,"text":1517,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}255I'm Telling the Truth [二分图匹配]25515354180001535435257<!--markdown-->## hdu 3729

<!--more-->

题目来源: [_hdu_](http://acm.hdu.edu.cn/showproblem.php?pid=3729)

## 分析

这题第一眼看上去或许不太像二分图匹配问题。但是我们仔细研究一下便可以发现，我们可以把学生和分数当作二分图的两个部分，因为分数小于$100000$，所以我们可以直接开一个数组存储它的`belong[]`。然后就二分图匹配，找到匹配的数量，便是我们要的"说真话的学生数量"。

## 代码

```C++
#include <iostream>
#include <cstring>

using namespace std;

bool flag[100100];
int l[100],r[100];
int belong[100100];
int ans[100];

bool find(int x)
{
    for (int i = l[x]; i<=r[x]; i++)
        if (!flag[i])
        {
            flag[i] = true;
            if (belong[i]==0 || find(belong[i]))
            {
                belong[i] = x;
                return true;
            }
        }
    return false;
}

int main()
{
    int T;
    cin >> T;
    while (T--)
    {
        memset(belong,0,sizeof(belong));

        int n;
        cin >> n;
        for (int i = 1; i<=n; i++)
            cin >> l[i] >> r[i];

        int cnt = 0;
        for (int i = n; i>0; i--)
        {
            memset(flag,false,sizeof(flag));
            if (find(i))
                ans[++cnt] = i;
        }

        cout << cnt << endl;
        for (int i = cnt; i>1; i--)
            cout << ans[i] << " ";
        cout << ans[1] << endl;
    }
}
```01postpublish01110728122eadedca4d3c3c2591c37ec8293{"cid":3,"title":30,"slug":3,"created":10,"modified":10,"text":2830,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}276Muddy Fields [二分图匹配]27615354357601535435822<!--markdown-->## POJ 2226

<!--more-->

题目来源: [_POJ_](poj.org/problem?id=2226)

## 分析

给定一个由`*`和`.`组成的二位数组。要求用一些宽为$1$，长度任意的木板来覆盖所有的`*`。求木板数量最少为多少。

第一眼看到这道题，我们便能够想起一个常见的二分图模型: 在二维数组上每一行或每一列覆盖木板，使得所有的特殊点被覆盖。但是这题和这个模型并不完全一样。这道题里的木板只能覆盖在`*`上，而模型中的则是任意位置。

所以，我们需要做一些改动。我们发现，无论怎样，木板还是会分为横向与纵向，并且满足二分图的模型。那么我们只需要令每一个横向的联通块和纵向的联通块为一个节点即可，而不是把一行或者一列当作节点。

所以我们需要预处理出所有的"节点",然后跑一边匈牙利算法即可。

## 代码

```C++
#include <iostream>
#include <cstring>

#define MAXN 3010

using namespace std;

struct Edge;    

struct Node
{
    Edge *edge;
    Node *belong;
    bool flag;
    
    Node()
    {
        belong = NULL;
        edge = NULL;
    }
}node[MAXN];

struct Edge
{
    Node *from, *to;
    Edge *next;

    Edge(Node *from, Node *to):from(from),to(to),next(from->edge)   {}
};

bool find(Node *x)
{
    for (Edge *e = x->edge; e; e = e->next)
        if (!e->to->flag)
        {
            e->to->flag = true;
            if (e->to->belong==NULL || find(e->to->belong))
            {
                e->to->belong = x;
                return true;
            }
        }
    return false;
}

char mp[60][60];
int n,m;

int row[60][60];
int col[60][60];
int rowcnt = 0;
int colcnt = 0;

void makeGraph()
{
    for (int i = 1; i<=n; i++)
        for (int j = 1; j<=m; j++)
        {
            if (mp[i][j]=='.')
                continue;

            if (mp[i][j-1]=='.')
                row[i][j] = ++rowcnt;
            if (mp[i-1][j]=='.')
                col[i][j] = ++colcnt;
            if (mp[i][j-1]=='*')
                row[i][j] = row[i][j-1];
            if (mp[i-1][j]=='*')
                col[i][j] = col[i-1][j];

            node[ row[i][j] ].edge = new Edge(&node[ row[i][j] ], &node[ col[i][j] ]);
        }
}

int main()
{
    memset(mp,'.',sizeof(mp));

    cin >> n >> m;

    for (int i = 1; i<=n; i++)
        for (int j = 1; j<=m; j++)
        {
            char c;
            cin >> mp[i][j];
        }
    
    makeGraph();

    int cnt = 0;
    for (int i = 1; i<=rowcnt; i++)
    {
        for (int j = 1; j<=colcnt; j++)
            node[j].flag = false;

        if (find(&node[i]))
            cnt ++;
    }

    cout << cnt;
}
```01postpublish011105a3e884d1a720c05e2c698782a085ffd{"cid":3,"title":28,"slug":3,"created":10,"modified":10,"text":2655,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}264Checkposts [强连通分量]26415354340801535435324<!--markdown-->## CF 427 C

<!--more-->

题目来源: [_Codeforces_](http://codeforces.com/problemset/problem/427/C)

## 分析

题目要求求出每个强连通分量中价值最小的点，并计数。只需要跑一边Tarjan，然后更新所有强连通分量中的最小值即可。

## 代码

```C++
#include <iostream>
#include <stack>
#include <algorithm>
#include <cstring>
#include <cstdio>

#define MAXN 100100
#define INF 0x3f3f3f3f
#define MOD 1000000007

using namespace std;

struct Edge;

struct Node
{
    Edge *edge;
    int dfn, low, color;
    bool flag;
    int val;

    Node()
    {
        flag = false;
        dfn = low = color = 0;
        edge = NULL;
    }
}node[MAXN];

struct Edge
{
    Node *from, *to;
    Edge *next;

    Edge(Node *from, Node *to):from(from),to(to),next(from->edge)   {}
};

int cnt = 0;

stack<Node *> s;
void Tarjan(Node *x)
{
    static int num = 0;
    x->low = x->dfn = ++num;
    x->flag = true;
    s.push(x);

    for (Edge *e = x->edge; e; e = e->next)
    {
        if (e->to->dfn==0)
        {
            Tarjan(e->to);
            x->low = min(x->low, e->to->low);
        }else if (e->to->flag)
            x->low = min(x->low, e->to->dfn);
    }

    if (x->dfn==x->low)
    {
        x->flag = false;
        x->color = ++cnt;

        while ( !s.empty() && s.top()!=x)
        {
            Node *v = s.top();
            v->color = cnt;
            v->flag= false;
            s.pop();
        }
        if (!s.empty())
            s.pop();
    }
}

int minCost[MAXN];
long long way[MAXN];

int main()
{
    int n,m;
    scanf("%d",&n);

    for (int i = 1; i<=n; i++)
        scanf("%d",&node[i].val);

    scanf("%d",&m);
    for (int i = 1; i<=m; i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);

        node[x].edge = new Edge(&node[x],&node[y]);
    }

    for (int i = 1; i<=n; i++)
        if (node[i].dfn==0)
            Tarjan(&node[i]);

    memset(minCost,INF,sizeof(minCost));

    for (int i = 1; i<=n; i++)
    {
        if (node[i].val < minCost[ node[i].color ])
        {
            minCost[ node[i].color ] = node[i].val;
            way[ node[i].color ] = 1;
        }else if (node[i].val == minCost[ node[i].color ])
        {
            way[ node[i].color ] ++ ;
        }
    }

    long long ans[2];
    ans[0] = 0;
    ans[1] = 1;
    for (int i = 1; i<=cnt; i++)
    {
        ans[0] += minCost[i];
        ans[1] *= way[i];
        ans[1] %= MOD;
    }

    cout << ans[0] << " " << ans[1] << endl;
}
```

01postpublish011104d49a36b45eca09a5c7882b0d7f9707d{"cid":3,"title":42,"slug":3,"created":10,"modified":10,"text":3620,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}278Smallest Minimum Cut [最小割+思维题]27815354392401535439332<!--markdown-->## hdu 6214

<!--more-->

题目来源: [_hdu_](acm.hdu.edu.cn/showproblem.php?pid=6214)

## 分析

题目要求求出边数最小的最小割。很明显，我们在正常求最小割时根本无法得知最小割的边数。所以我们应该想办法把它记录下来。

我们可以把这个信息加入到所有边的`capacity`中。因为边共有`m`个，所以我们的最小割最大为`m`。那么我们可以令$capacity = capacity \times (m+1) + 1$。此时我们算出的最小割，便为"原来的最小割 * (m+1) + 边数"。所以，我们直接$mod (m+1)$就好了。

## 代码

```C++
#include <iostream>
#include <queue>
#include <cstdio>

#define MAXN 1010
#define INF 0x3f3f3f3f

using namespace std;

struct Node;
struct Edge;
int n,m;

struct Node
{
    Edge *firstEdge, *currentEdge;
    int level;

    Node()
    {
        firstEdge = NULL;
    }

}node[MAXN];

struct Edge
{
    Node *from, *to;
    int capacity, flow;
    Edge *next, *reverseEdge;

    Edge(Node *from, Node *to, int capacity):from(from),to(to),capacity(capacity),flow(0),next(from->firstEdge)   {}

    ~Edge()
    {
        delete next;
    }
};

struct Dinic
{
    bool makeLevelGraph(Node *s, Node *t, int n)
    {
        for (int i = 1; i<=n; i++)
        {
            node[i].level = 0;
            node[i].currentEdge = node[i].firstEdge;
        }
        queue<Node *> q;
        q.push(s);
        s->level = 1;

        while (!q.empty())
        {
            Node *v = q.front();
            q.pop();

            for (Edge *e = v->firstEdge; e; e = e->next)
                if (e->flow<e->capacity && e->to->level==0)
                {
                    e->to->level = v->level + 1;
                    if (e->to==t)
                        return true;
                    else q.push(e->to);
                }
        }

        return false;
    }

    int findPath(Node *s, Node *t, int limit = INF)
    {
        if (s==t)
            return limit;

        for (Edge *&e = s->currentEdge; e; e = e->next)
            if (e->to->level==s->level+1 && e->flow < e->capacity)
            {
                int flow = findPath(e->to, t, min(limit, e->capacity - e->flow));
                if (flow>0)
                {
                    e->flow += flow;
                    e->reverseEdge->flow -= flow;
                    return flow;
                }
            }

        return 0;
    }

    int operator()(int s, int t, int n)
    {
        int ans = 0;
        while (makeLevelGraph(&node[s], &node[t], n))
        {
            int flow;
            while ((flow = findPath(&node[s], &node[t]))>0 )
                ans += flow;
        }
        return ans;
    }

}dinic;

int main()
{
    ios::sync_with_stdio(false);

    int T;
    scanf("%d",&T);
    while (T--)
    {
        int s,t;
        scanf("%d%d%d%d",&n,&m,&s,&t);

        for (int i = 1; i<=n; i++)
        {
            delete node[i].firstEdge;
            node[i] = Node();
        }

        for (int i = 1; i<=m; i++)
        {
            int x,y,z;
            scanf("%d%d%d",&x,&y,&z);
            node[x].firstEdge = new Edge(&node[x], &node[y], z*(1+m)+1);
            node[y].firstEdge = new Edge(&node[y], &node[x], 0);

            node[x].firstEdge->reverseEdge = node[y].firstEdge;
            node[y].firstEdge->reverseEdge = node[x].firstEdge;
        }

        int ans = dinic(s, t, n);

        cout << ans%(1+m) << endl;
    }
}
```01postpublish011107478b6a9829f59355172760c120cf44a{"cid":3,"title":28,"slug":3,"created":10,"modified":10,"text":3866,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}280[学习笔记]Manacher算法28015356814001543921838<!--markdown-->## 最长回文子串

> 昨天加上今天一直在调树链剖分，然而不知为何就是一直在RE，暂时先放弃了。。。否则这几天我就不用干别的了(￣▽￣)"。

<!--more-->

## 介绍

**Manacher算法**是一个处理最长回文子串的算法，运用了巧妙地方法，将时间优化为了$O(n)$。

## 原理及流程

对于一个字符串`s`，我们用`p[]`来存储以每个点为中心的最长回文字串的右半部分的长度。

假设我们从左向右枚举处理，那么当我们处理到第$i$个时，所有的$p_j, (j<i)$明显已知。同时，我们假设我们此前记录了一个变量`maxid`，满足$maxid + p_{maxid}$最大。那么，便会如下图所示，存在一个$j$关于$maxid$与$i$对称，因为$maxid$为中心的这个范围都是回文串，所以$p_i$便为$p_j$。

![图1](https://oi-songer.github.io/In%20Blog/Manacher%E7%AE%97%E6%B3%95-1.png)

当然，存在另一种情况，便是$i+p_j \geq maxid + p_{maxid} $，如下图所示。此时的$p_i$只能先赋值为$maxid - i$。但是由于$maxid + p_{maxid}$向右是未知的，所以我们还需要继续向下比较，增加$p_i$，然后验证是否成立，找到最大值，顺便更新一下$maxid$。

![图2](https://oi-songer.github.io/In%20Blog/Manacher%E7%AE%97%E6%B3%95-2.png)

我们可以看到，在第一种情况中，查找$p_i$时一个$O(1)$的操作，而在第二种情况中，查找$P_i$则需要多一个枚举，不过这个枚举明显就是对$maxid + p_maxid$的枚举，总的而言是个$O(n)$的，所以这个算法就是一个$O(n)$的算法。

不过算法到这里还有一个问题，我们一般会用$i-k$与$i+k$来判断是否是回文，但是这样判断不了偶数长度的回文，对于这个问题，manacher算法有一个巧妙地解决方法:在每个字符的中间插入一些字符。这些字符必须是相等的。此外，为了避免判断越界，我们还可以在字符串头与尾加入两个不一样的字符。如下所示:
```plain
原串:     a b c c d e f f e g
处理后: $#a#b#c#c#d#e#f#f#e#g#!
```
此时，我们还能发现一个奇特的性质，所有点的$p_i$便是其真正回文串的长度。到此，manacher算法便完成了。其核心代码如下:

```C++
int maxid = 0, id = 0;
for (int i = 0; i<str.length(); i++)
{
	if ( i < maxid )
    	p[i] = min( p[id*2 - i], maxid-i);
    else
    	p[i] = 0;
      
    while ( str[ i+p[i]+1 ]==str[ i-p[i]-1 ] )
    	p[i] ++;
    if (i+p[i]>maxid)
    {
    	maxid = i+p[i];
        id = i;
    }
}
```

## 例题及代码

题目来源: [_hdu_](http://acm.hdu.edu.cn/showproblem.php?pid=3068)

```C++
#include <iostream>
#include <cstring>
#include <string>
#include <algorithm>

using namespace std;

int p[250000];

int main()
{
    string s;
    while (cin >> s)
    {
        memset(p,0,sizeof(p));

        string str;
        str.append(1, '$');
        str.append(1, '#');
        for (int i = 0; i<s.length(); i++)
        {
            str.append(1, s[i]);
            str.append(1, '#');
        }
        str.append(1, '!');

        int maxid = 0, id = 0;
        for (int i = 0; i<str.length(); i++)
        {
            if ( i < maxid )
                p[i] = min( p[id*2 - i], maxid-i);
            else
                p[i] = 0;
        
            while ( str[ i+p[i]+1 ]==str[ i-p[i]-1 ] )
                p[i] ++;
            if (i+p[i]>maxid)
            {
                maxid = i+p[i];
                id = i;
            }
        }

        int ans = 0;
        for (int i = 0; i<str.length(); i++)
        {
            ans = max(ans, p[i]);
           // cout << str[i] << " " << p[i] << endl;
        }
        cout << ans << endl;
    }
}
```01postpublish011104575985bddcbb57642cabdb5c25808dc{"cid":3,"title":18,"slug":3,"created":10,"modified":10,"text":4495,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}292商务旅行 [LCA]29215399515401542286285<!--markdown-->## Code[VS] 1036

> 这也是一道模板题了，这个博客也还没写过LCA的题目，整理板子时又写了两遍，顺便发上来吧。

<!--more-->

题目来源: [_Code\[VS\]_](http://codevs.cn/problem/1036/)

## 倍增LCA
```C++
#include <iostream>
#include <queue>
#include <algorithm>
#include <cstring>

#define MAXN 500100
#define INF 0x3f3f3f3f

using namespace std;

struct Edge *f[MAXN];
int fa[MAXN][22];
int val[20];
int depth[MAXN];
int n;

struct Edge
{
    int from, to;
    Edge *next;

    Edge(int from = 0, int to = 0):
        from(from), to(to), next(f[from]) {}

    ~Edge()
    {
        delete next;
    }
};

queue<int> q;
void bfs(int s)
{
    memset(depth, INF, sizeof(depth));
    depth[0] = 0;
    depth[s] = 1;
    q.push(s);
    while (!q.empty())
    {
        int tmp = q.front();    q.pop();
        for (Edge *e = f[tmp]; e; e = e->next)
        {
            if (depth[e->to]==INF)
            {
                depth[e->to] = depth[tmp] + 1;
                q.push(e->to);

                fa[e->to][0] = tmp;
            }
        }
    }
}

void init()
{
    val[0] = 1;
    for (int i = 1; i<=20; i++)
    {  
        val[i] = val[i-1] * 2;
    }
    
    for (int j = 1; j<=20; j++)
        for (int i = 1; i<=n; i++)
        {
            fa[i][j] = fa[ fa[i][j-1] ][j-1];
        }
}

int LCA(int x, int y)
{
    int ans = 0;
    if (depth[x] < depth[y])
        swap(x, y);

    for (int i = 20; depth[x]>depth[y]; i--)
        if (depth[ fa[x][i] ] >= depth[y])
        {
            ans += val[i];
            x = fa[x][i];
        }

    if (x==y)
        return ans;

    for (int i = 20; i>=0; i--)
        if (fa[x][i] != fa[y][i])
        {
            x = fa[x][i];
            y = fa[y][i];
            ans += val[i]*2;
        }
    
    ans += 2;
    return ans;
}

int main()
{
    memset(fa, 0, sizeof(fa));
    memset(f, 0, sizeof(f));

    cin >> n;

    for (int i = 1; i<n; i++)
    {
        int x, y;
        cin >> x >> y;

        f[x] = new Edge(x, y);
        f[y] = new Edge(y, x);
    }

    bfs(1);
    init();

    int ans = 0;

    int m;
    cin >> m;
    int x;
    cin >> x;
    for (int i = 1; i<m; i++)
    {
        int y;
        cin >> y;
        ans += LCA(x, y);

        x = y;
    }

    cout << ans << endl;
}
```
## Tarjan LCA

```C++
#include <iostream>
#include <queue>

#define MAXN 30100

using namespace std;

struct Edge *f[MAXN];
struct Edge
{
    int from, to;
    Edge *next, *oppo;
    bool access;

    Edge(int from=0, int to=0)
        :from(from), to(to), next( f[from] ) {access=true;}
};

struct Query
{
    int node;
    Query *next;

    Query(int node = 0, Query *next = NULL)
        :node(node), next(next)   {}
};
Query *query[MAXN];
int depth[MAXN], fa[MAXN];
bool flag[MAXN];
int ans;

queue<int> q;
void bfs(int s)
{
    depth[s] = 1;
    q.push(s);
    while (!q.empty())
    {
        int tmp = q.front();
        q.pop();

        for (Edge *e = f[tmp]; e; e = e->next)
            if (e->access)
            {
                e->oppo->access = false;
                depth[e->to] = depth[tmp] + 1;
                q.push(e->to);
            }
    }
}

int find(int x)
{
    return fa[x]==x? x : fa[x] = find(fa[x]);
}

void Union(int x, int y)
{
    int fy = find(y);
    fa[fy] = x;
}

void Tarjan(int x)
{
    fa[x] = x;
    
    for (Edge *e = f[x]; e; e = e->next)
        if (e->access)
        {
            Tarjan(e->to);
            Union(x, e->to);
        }
    
    flag[x] = true;

    for (Query *q = query[x]; q; q = q->next)
    {
        if (flag[ q->node ])
            ans += depth[x] + depth[ q->node ] - 2 * depth[ find( q->node )];
    }
}

int main()
{
    int n;
    cin >> n;

    for (int i = 1; i<n; i++)
    {
        int x, y;
        cin >> x >> y;
        f[x] = new Edge(x, y);
        f[y] = new Edge(y, x);

        f[x]->oppo = f[y];
        f[y]->oppo = f[x];
    }

    int m;
    cin >> m;
    int x;
    cin >> x;
    for (int i = 1; i<m; i++)
    {
        int y; 
        cin >> y;

        query[x] = new Query(y, query[x]);
        query[y] = new Query(x, query[y]);

        x = y;
    }

    bfs(1);
    Tarjan(1);

    cout << ans << endl;
}
```01postpublish011109db58a298d8bcb6a050f33a8467c5bdb{"cid":3,"title":26,"slug":3,"created":10,"modified":10,"text":11830,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}332[学习笔记]后缀数组33215498004801551139283<!--markdown-->> 时隔数月，终于又来学些新东西了。这次Camp知识点学到的不多，不过倒是知道了许多需要学的知识点。最近可能此主题的Blog比较多。

<!--more-->

## 算法介绍

### 基础知识

在许多题目中，我们经常需要对一个字符串的子串作许多查询操作，而此时后缀树，后缀自动机和后缀数组之类的数据结构就可以大幅度的帮我们节省时间。其中，后缀数组因其实现简单，作用较为丰富且空间占用少广为使用。

**后缀数组(Suffix Array)**实现的功能是对一个字符串的不同后缀子串进行排序。对于长度为$len$的字符串$s$，它的后缀$suffix(i)$为$s[i..len]$。然后，我们通过对这$len$个子串进行排序，得到以下的几个数组：

* `sa[]`：保存了对字符串$s$的所有后缀排序后的结果。`sa[i]`存储了第$i$小的后缀在原串中的起始位置。
* `rank[]`：名次数组。`rank[i]`存储了以$i$为起始位置的后缀子串在`sa[]`中的排名，即`sa[rank[i]] = i`。

此外，我们假设比较的串为`a`,`b`,那么比较操作的定义如下：
1. $a[i]<b[i]$: $a<b$;
2. $a[i]>b[i]$: $a>b$;
3. $a[i]=b[i]$: 比较第$i+1$位。
4. $i > len(b)$: $a>b$;
5. $i > len(a)$: $a<b$。

由此判定条件，我们可以发现由于我们要比较的$len$个串由于长度各不相同，所以不可能相等。

此时，我们便可以想出最简单的后缀数组构造方法：写出所有的后缀字串然后进行一遍排序即可。由于排序操作是$O(n\log n)$的，并且字串的长度最大为$n$，所以时间复杂度为$O(n^2 \log n)$。这个时间明显有些大了，这时我们便需要使用倍增的方法进行构造了。

### 倍增法

当我们对$n$个互不关联的长度为$n$的字符串进行排序时，我们固然需要$O(n^2 \log n)$的时间进行排序。但是，我们这里比较的是后缀子串，所以我们其实可以利用其中的性质。

我们现在假设有一个二维数组`rk[i][j]`，它代表的是以$i$开始的长度为$2^j$的子串在长度为$2^j$的子串中的排名。当$2^j \geq len$时，其实该数组就等于了后缀数组中的`rank[]`。

那么，我们便只需要迭代地更新`rk[][]`数组即可。对于`rk[i][j]`，其代表的是从$i$开始的长度为$2^j$的子串，那么，$rk[i][j-1]$其实就可以作为它的第一关键字，而$rk[i+2^{j-1}][j-1]$则是第二关键字。我们按照这些关键字机型排序即可。

倘若我们排序时使用快速排序，那么该算法的时间复杂度便为$O(n \log ^ 2 n)$。不过倘如该串是一个字符串或者其它取值范围较小的串，那么我们便可以用奇数排序，这样时间复杂度便变为了$O(n \log n)$。

> PS: 除了倍增法，还有速度更快的时间复杂度为$O(n)$的DC3算法，不过编程难度很高，所以一般不使用。此外，还可以使用hash，对所有的后缀子串进行hash然后排序，其也可以实现$O(n \log ^2 n)$的时间复杂度，但是不稳定。

## 实现细节

我们假设是对一个字符串`s[]`进行处理，那么我们在这里便使用基数排序。使用`buc[]`来作基数排序的桶，`a-z`分别映射`1-26`。因为我们是迭代更新，所以`rk[][]`完全可以使用一位数组`rank[]`代替。不过由于`rank[]`是保留字，所以我们使用`rk[]`。

```C++

//先做一边基数排序，算出各自的排名
for (int i = 1; i<=n; i++)
    buc[ s[i] - 'a' + 1 ] ++;
for (int i  = 1; i<MAXNCHAR; i++)
    buc[i] += buc[i-1];

//利用基数排序的答案来更新rank[]数组
for (int i = 1; i<=n; i++)
    rk[i] = buc[ a[i] - 'a' ] + 1;

//枚举不同的长度，需要log(n)次运算
for (int t = 1; t <= n; t *= 2)
{
    //更新第一和第二关键字
    for (int i = 1; i<=n; i++)
    {
        first[i] = rk[i];
        second[i] = i+t>n? 0 : rk[i+t];
    }

    //将buc[]数组清0
    fill(buc, buc+n+1, 0);

    //按照第二关键字进行一次基数排序
    for (int i = 1; i<=n; i++)
        buc[ second[i]] ++;
    for (int i = 1; i<=n; i++)
        buc[i] += buc[i-1];

    //用tmp[]来存储按照第二关键字排序的名次，这里我们得到的结果为从大到小排序
    for (int i = 1; i<=n; i++)
        tmp[ n - --buc[ second[i] ] ] = i;

    //将buc[]清0
    fill(buc, buc+n+1, 0);

    //按照第一关键字进行基数排序
    for (int i = 1; i<=n; i++)
        buc[ first[i] ] ++;
    for (int i = 1; i<=n; i++)
        buc[i] += buc[i-1];

    //按照第二关键字排好序的顺序来用buc[]更新sa[]数组，这样可以确保在first[]相同时，second[]最小的子串能够排在后面
    for (int i = 1,j; i<=n; i++)
    {
        j = tmp[i];
        sa[ buc[first[j]]-- ] = j;
    }

    //一个优化：当前如果没有first[]和second[]相同的子串直接退出，因为此时已经等价于最终答案
    bool flag = true;
    //使用sa[]来更新rk[]数组
    int k = 0;
    for (int i = 1; i<=n; i++)
    {
        int j = sa[i];

        if (!k)
            rk[j] = 1;
        else if (first[j]==first[k] && second[j]==second[k])
        {
            rk[j] = rk[k];
            flag = false;
        }else
            rk[j] = rk[k] + 1;

        k = j;
    }

    if (flag)
        break;
}

```

## 性质

### `height[]`数组

我们定义`height[i]`为$suffix(sa[i])$和$suffix(sa[i-1])$的最长公共前缀长度。很明显，对于一个后缀子串，在`sa[]`数组中离他越近的最长公共前缀越长。

我们可以利用这个性质。我们假设`h[i] = height[ rank[i] ]`。那么此时便会存在一个性质$h[i] \geq h[i-1] - 1$。所以我们便可以利用此性质$O(n)$地计算出`height[]`数组。

```C++
for (int i = 1, k = 0; i <= n; i++)
{
    if (rk[i] == 1) k = 0;
    else
    {
        if (k > 0) k--;
        int j = sa[rk[i] - 1];
        while (i + k <= n && j + k <= n && s[i - 1 + k] == s[j - 1 + k]) 
            k++;
    }
    height[rk[i]] = k;
}
```

### LCP问题

`height[]`数组只是计算出了相邻两个后缀子串地公共前缀。而当我们想要计算任意两个后缀字串的**LCP(Longest Common Prefix)**时该怎么办呢？这时候其实也需要利用`height[]`数组。

对于$LCP(suffix(i), suffix(j))$，其值其实就等于$min( height[i+1], ..., height[j])$，这样，我们只需要维护一个RMQ即可。

## 例题

### Luogu 3809

题目来源：[_luogu_](https://www.luogu.org/problemnew/show/P3809)

```C++
#include <iostream>
#include <algorithm>
#include <string>

#define MAXN 1000100
#define MAXM 62

using namespace std;

int buc[MAXN];
int sa[MAXN];
int rk[MAXN], tmp[MAXN];
int first[MAXN], second[MAXN];
string s;

int trans(char c)
{
    if (c>='0' && c<='9')
        return c - '0' + 1;
    if (c>='A' && c<='Z')
        return c - 'A' + 11;
    if (c>='a' && c<='z')
        return c - 'a' + 37;
    return 0;
}

int main()
{
    ios::sync_with_stdio(false);

    string s;
    cin >> s;

    int n = s.length();

    for (int i = 1; i<=n; i++)
        buc[ trans(s[i-1]) ] ++;
    for (int i = 1; i<=MAXM; i++)
        buc[i] += buc[i-1];

    for (int i = 1; i<=n; i++)
        rk[i] = buc[ trans(s[i-1]) - 1 ] + 1;

    for (int t = 1; t<n; t *= 2)
    {
        for (int i = 1; i<=n; i++)
        {
            first[i] = rk[i];
            second[i] = i+t>n? 0: rk[i+t];
        }

        fill(buc, buc+n+1, 0);
        for (int i = 1; i<=n; i++)
            buc[ second[i] ] ++;
        for (int i = 1; i<=n; i++)
            buc[i] += buc[i-1];
        for (int i = 1; i<=n; i++)
            tmp[ n - --buc[ second[i] ] ] = i;

        fill(buc, buc+n+1, 0);
        for (int i = 1; i<=n; i++)
            buc[ first[i] ] ++;
        for (int i = 1; i<=n; i++)
            buc[i] += buc[i-1];
        for (int i = 1; i<=n; i++)
        {
            int j = tmp[i];
            sa[ buc[first[j]]-- ] = j;
        }

        //不加这个优化就会TLE
        bool flag = true;
        int k = 0;
        for (int i = 1; i<=n; i++)
        {
            int j = sa[i];

            if (!k)
                rk[j] = 1;
            else if (first[j]==first[k] && second[j]==second[k])
            {
                rk[j] = rk[k];
                flag = false;
            }else
                rk[j] = rk[k] + 1;
                // rk[j] = (first[j]==first[k] && second[j]==second[k])?
                    // rk[k] : rk[k] + 1;

            k = j;
        }
        if (flag)
            break;
    }

    for (int i = 1; i<=n; i++)
        cout << sa[i] << (i==n? "\n": " ");

}
```

### POJ 2774

题目来源：[_POJ_](http://poj.org/problem?id=2774)

这题就算是一个LCP问题了，我们只需要将两个字符串合为一个，然后利用`height[]`数组求即可。

```C++
#include <iostream>
#include <algorithm>
#include <string>
#include <cstring>

#define MAXN 200100
#define MAXM 62
#define INF 0x3f3f3f3f

using namespace std;

int buc[MAXN];
int sa[MAXN];
int rk[MAXN], tmp[MAXN];
int first[MAXN], second[MAXN];
int height[MAXN];
string s;

int trans(char c)
{
    if (c>='a' && c<='z')
        return c - 'a' + 1;
    return 28;
}

int main()
{
    ios::sync_with_stdio(false);

    string s;
    cin >> s;
    int slen = s.length();
    s += "$";

    string ss;
    cin >> ss;
    s += ss;

    int n = s.length();

    for (int i = 1; i<=n; i++)
        buc[ trans(s[i-1]) ] ++;
    for (int i = 1; i<=MAXM; i++)
        buc[i] += buc[i-1];

    for (int i = 1; i<=n; i++)
        rk[i] = buc[ trans(s[i-1]) - 1 ] + 1;

    for (int t = 1; t<n; t *= 2)
    {
        for (int i = 1; i<=n; i++)
        {
            first[i] = rk[i];
            second[i] = i+t>n? 0: rk[i+t];
        }

        fill(buc, buc+n+1, 0);
        for (int i = 1; i<=n; i++)
            buc[ second[i] ] ++;
        for (int i = 1; i<=n; i++)
            buc[i] += buc[i-1];
        for (int i = 1; i<=n; i++)
            tmp[ n - --buc[ second[i] ] ] = i;

        fill(buc, buc+n+1, 0);
        for (int i = 1; i<=n; i++)
            buc[ first[i] ] ++;
        for (int i = 1; i<=n; i++)
            buc[i] += buc[i-1];
        for (int i = 1; i<=n; i++)
        {
            int j = tmp[i];
            sa[ buc[first[j]]-- ] = j;
        }

        //不加这个优化就会TLE
        bool flag = true;
        int k = 0;
        for (int i = 1; i<=n; i++)
        {
            int j = sa[i];

            if (!k)
                rk[j] = 1;
            else if (first[j]==first[k] && second[j]==second[k])
            {
                rk[j] = rk[k];
                flag = false;
            }else
                rk[j] = rk[k] + 1;
                // rk[j] = (first[j]==first[k] && second[j]==second[k])?
                    // rk[k] : rk[k] + 1;

            k = j;
        }
        if (flag)
            break;
    }

    memset(height, 0, sizeof(0));

    for (int i = 1, k = 0; i <= n; i++)
    {
        if (rk[i] == 1) k = 0;
        else
        {
            if (k > 0) k--;
            int j = sa[rk[i] - 1];
            while (i + k <= n && j + k <= n && s[i - 1 + k] == s[j - 1 + k]) 
                k++;
        }
        height[rk[i]] = k;
    }

    int ans = 0;
    for (int i = 1; i<=n; i++)
        if((sa[rk[i]]>slen&&sa[rk[i]-1]<slen)||(sa[rk[i]]<slen&&sa[rk[i]-1]>slen))
            ans=max(ans,height[rk[i]]);

    cout << ans << endl;

}
```01postpublish01110645104bff1cc0c28c60a2a8705d0c828{"cid":3,"title":21,"slug":3,"created":10,"modified":10,"text":4009,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}329机器人 [思维题]32915490183801549019399<!--markdown--># Wannafly Day 0 A

> 差不多也就是一个大的思维题，不过确实容易把人绕晕，虽然最后总结起来还算挺简单，特殊情况也不多。

<!--more-->

题目来源：[_comet OJ_](https://zhixincode.com/contest/3/problem/A?problem_id=34)

## 分析

首先，我们看到题目后首先能想到的肯定是重点会在那`m`个特殊点上。因为只有这些地方能够“拐弯”，所以其实我们可以只将这些“点”看作点(`Node`)，其它的都是边的一部分。那么，当我们有一个点必走，并且这个点在某条边上时，很显然等价于这条边的两个顶点(`Node`)必走。那么，这就变成了一个大小$200 \times 2$的图（并且分布呈矩形），在某些点必走时的最短回环。

在此时，在最一般的情况下，最短的回环其实可以画成一个矩形（这里排除了两个特殊情况，等下讨论）。也就是说，我们会在起点先向左走到需要走到的最左边，然后转到b区，之后走到需要走到的最右边，再转到a区，最后回到起点即可。所以最后的答案即为：

~ ans = 2k + 2 \\times (\\max(s, maxn) - \\min(s, minn)) ~

其中，`maxn`表示在最右边的需要走到的`Node`，这里无论a,b区，直接取最大值即可。`minn`同理。

此外，我们还需要考虑一些特殊的情况。比较容易想到的是所有的必走点都在a区，所以我们不需要跳到b区，此时的答案便为：

~ ans = 2 \\times (\\max(s, maxn) - \\min(s, minn)) ~

此外，还有一种需要特殊考虑的情况是起点`s`处于一条边上，并且当所有其它必走点组成一个矩形时，这条边并不在矩形里面，此时，我们可以通过令`s`点成为一个特殊点来解决这个问题。我们可以发现，此时无论必走点在什么位置出现都不会影响答案的正确性，然后直接正常计算即可。

## 代码

```C++
#include <iostream>
#include <algorithm>

#define MAXN 1000100
#define MAXR 100100
#define INF 0x3f3f3f3f

using namespace std;

int sav[MAXR];

struct Node
{
    int pos;
    bool flag, special;
    Node *left, *right;

    Node()
    {
        flag = special = false;
        pos = 0;
        left = right = NULL;
    }
}node[2*MAXN];

int main()
{
    ios::sync_with_stdio(false);

    int n, r, m, k, s;
    cin >> n >> r >> m >> k >> s;

    for (int i = 1; i<=2*n; i++)
        node[i].pos = i;

    for (int i = 1; i<=r; i++)
    {
        int x, y;
        cin >> x >> y;
        sav[i] = x + y * n;
    }

    node[s].special = true;
    node[1].special = node[n+1].special = true;
    node[n].special = node[n+n].special = true;
    for (int i = 1; i<=m; i++)
    {
        int x;
        cin >> x;
        node[x].special = true;
        node[n+x].special = true;
    }

    for (int i = 2; i<=2*n; i++)
        node[i].left = node[i-1].special? &node[i-1]: node[i-1].left;

    for (int i = 2*n-1; i>=1; i--)
        node[i].right = node[i+1].special? &node[i+1]: node[i+1].right;

    node[n+1].left = NULL;
    node[n].right = NULL;

    for (int i = 1; i<=r; i++)
    {
        if(node[ sav[i] ].special)
            node[ sav[i] ].flag = true;
        else
            node[ sav[i] ].left->flag = node[ sav[i] ].right->flag = true;
    }

    int minn[2] = {INF,INF},maxn[2] = {0, 0};
    for (Node *t = &node[1]; t; t = t->right)
    {
        if (t->flag && minn[0]==INF)
            minn[0] = t->pos;
        if (t->flag)
            maxn[0] = t->pos;
    }

    for (Node *t = &node[n+1]; t; t = t->right)
    {
        if (t->flag && minn[1]==INF)
            minn[1] = t->pos;
        if (t->flag)
            maxn[1] = t->pos;
    }

    long long ans = 0;
    if (minn[1]!=INF)
        ans += 2 * k;

    ans += 2*( max(s, max(maxn[0], maxn[1]-n)) - min(s, min(minn[0], minn[1]-n)) );

    cout << ans << endl;
}
```01postpublish011109d99849ac0d1d9a94782983de8a60e6f{"cid":3,"title":27,"slug":3,"created":10,"modified":10,"text":2050,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}297大鱼吃小鱼 [思维题]29715422883881542288402<!--markdown-->
## 51nod 1289

> 近一个月的颓废后的第一篇博客。最近一直在刷51nod，感觉题目质量还比较好，所以在按照难度从下往上刷。这题是个比较水的思维题。

<!--more-->

题目来源: [_51nod_](http://www.51nod.com/Challenge/Problem.html#!#problemId=1289)

## 分析

读完题后，我们首先需要注意到的是"足够长的时间"。这其实意味着最后的存活的鱼一定满足一个状态：所有的鱼可以分为两部分，左半部分向左游，右半部分向右游。

那么，我们可以从这点入手。我们以向左游的鱼为例。显然的，对于第`i`条鱼，它要存活，必须要比它能遇到的所有向右游的鱼大。而哪些鱼是它能遇到的呢？是介于上一条向左游的存活的鱼`j`和这条鱼中间的鱼。因为`j`之前的向右的鱼一定都被`j`或其它鱼吃掉了，否则`j`不会存活。

所以我们只需要动态的维护一个最大值`maxn`。对于向左游的鱼，我们从左向右遍历，若当前的鱼比`maxn`大且向右游，则更新`maxn`；若当前的鱼比`maxn`大且向左游，则令`maxn=0`，且这条鱼可以存活。然后对于向右的鱼同理，只不过数组要从右向左遍历。

## 代码

```C++
#include <iostream>
#include <algorithm>

#define MAXN 100100

using namespace std;

int a[MAXN], b[MAXN];

int main()
{
    int n;
    cin >> n;

    for (int i = 1; i<=n; i++)
        cin >> a[i] >> b[i];

    int ans = 0;
    int maxn = 0;
    for (int i = 1; i<=n; i++)
        if (a[i]>maxn)
        {
            if (b[i]==0)
            {
                ans ++;
                maxn = 0;
            }else 
                maxn = a[i];
        }

    maxn = 0;

    for (int i = n; i>=1; i--)
        if (a[i]>maxn)
        {
            if (b[i]==1)
            {
                ans ++;
                maxn = 0;
            }else maxn = a[i];
        }

    cout << ans << endl;

    return 0;
}
```01postpublish01110e30d355f5be6a29ba0364195ffc7f617{"cid":3,"title":21,"slug":3,"created":10,"modified":10,"text":1160,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}298大二上第十三周29815435911401543591256<!--markdown-->## 2018 11 30 周五

<!--more-->

又是好久没有写过Diary了(真的是很久啊。。。半年)。今天班聚回来，闲来无事，突然想写些东西。

最近算是吧今年分的比赛比完了。CCPC拿了个铜牌，ICPC则是一银一铜。最近则是要跟着陈永强学长去打EC final。不过最近最令我开心的还是CF上了1700，算是一个里程碑吧（笑），虽然只是用了两次比赛就从1500蹦到了1700.

但是，最近怎么说呢？ACM的训练几乎没怎么做，实验室也是快一个学期没去过了。因为今年已经拿了一个银牌，所以如果明年真的还想打的话肯定是要冲着金牌去了，所以必须要认真起来。毕竟我这个人实在是太懒了。。。不过其实每日能写写Diary的话或许是个不错的激励自己学习的手段。不过这又绕回来了，我能坚持每天或几天一篇吗（苦笑）。

不过无论如何，明天一定是要早起了。明天上午实验室有例会，下午则要和学长一起训练。希望自己能认真训练，不辜负学长的期望吧，也不要辜负自己的期望。

01postprivate011108c482d7b0079d0f5b09e3ff72bc1a3e5{"cid":3,"title":21,"slug":3,"created":10,"modified":10,"text":1644,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}301关于图床的更改30115439214991543921520<!--markdown-->
<!--more-->
本来我一直用的七牛的免费图床，但是最近这段时间，不知道为什么，感觉越来越难用。于是本着多动(zhe)手(teng)的精神，决定把图床迁到github上，用github自带的htpp访问功能来搭建图床。

其实虽然这么说，实施起来非常简单。因为最近养成了文件归类的好(qiang)习(po)惯(zheng)。所以七牛上的所有图片在我本机中都存在一个文件夹里。所以需要做的就是将其push到github即可。

在此之前，需要在github上建立一个项目，名字必须是`username`+".github.io"。然后用`git clone`将其clone下来。

然后，因为我其实并没有怎么用过gitbub，只有之前上传过一次作业做的五子棋AI，所以正常的push步骤都忘得差不多了。所以这里要复习一下。

git其实将文件分成了三个部分：一是实际上的工作目录，第二个是缓冲区，第三个则是head，即最终提交的结果。(参考于[git - 简易指南](http://www.bootcss.com/p/git-guide/))

所以，我们的第一步是将文件加入缓冲区：

```git
git add *
```

然后，我们将其正式提交。提交时需要对提交内容进行说明：

```git
git commit -m "提交信息"
```

这样，我们就将文件提交的本地的HEAD中了。但是我们的目的是将其上传到github中，所以，我们需要将当前的改动推送到远程仓库：

```git
git push orgin master
```

这样，我们就成功将本地的文件push上去了。这时候，我们用oi-songer.github.io\文件名 便可以访问图片了。01postpublish01110a74054678345cf7fcc112a762253d070{"cid":3,"title":19,"slug":3,"created":10,"modified":10,"text":2967,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}300Origami [思维题]30015439167391543916739<!--markdown-->
## Nowcoder 字节跳动冬令营网络赛 B

> 一道思维题，结果成了这次网络赛我唯一做出来的一道题。。。不过这次比赛抽奖抽中了三个T-shirt，emmmm，RP++。

<!--more-->

## 分析

题目给出了长度为$n$，分为$n$段的一个纸带，并且从左到右按顺序每段都标有一个编号。要求对这个纸带进行多次折叠，使得纸带只有一段。此时，纸带从上向下读，可以得到一个$n$的排列。现在题目给出一个排列，问是否可以折叠出该排列。

很明显，这个题目应该从折叠的性质入手。刚开始的时候我认为可以将排列分为两部分进行还原，但发现不可行。后来认为是和逆序对有关，但是也很快就推翻了自己的想法。那么究竟该从何处着手呢？

我们不妨从“纸带”本身来考虑。一个标了数字的折叠的纸带，其与一串排列最大的不同是什么？不同的数字之间有纸带相连。也就是说，$i$永远会与$i-1$和$i+1$相连。那么，我们可以将所有的数连起来，若是不同的连线之间有重叠的话，则肯定折不出当前的情况。

那么我们如何实现这种“连线”和“交叉”的判断呢？首先，我们可以将需要连的线分为左右两部分。很明显，小的奇数到大的偶数的连线为一部分，而小的偶数到大的奇数的连线会是另一部分。所以，我们对这两个部分分开考虑即可。

那么，我们的问题便变成了判断几条线之间是否有交叉的问题了。实际上，它还可以被简化成括号表达式是否合法的问题-即括号（连线）之间只能包含，不能交叉。如此，我们便可以用**栈**来实现这个功能了。譬如，连线的两个数互为左右括号，若是他们在栈中相邻，则可取出消去。若是栈最后有数无法消去（除去那些本来就没有和其他点连线的数），则当前排列不能由纸带折叠而出。

## 代码

```C++
#include <iostream>
#include <algorithm>
#include <stack>

using namespace std;

stack<int> s1, s2;

int main()
{
    int T;
    cin >> T;

    while (T--)
    {
        while (!s1.empty())
            s1.pop();
        while (!s2.empty())
            s2.pop();

        int n;
        cin >> n;

        for (int i = 1; i<=n; i++)
        {
            int x;
            cin >> x;


            if ( !s1.empty() && max(s1.top(), x) % 2 == 0 && abs(s1.top()-x)==1 )
                s1.pop();
            else if ( !(n%2==1 && x==n) )
                s1.push(x);
            
            if ( !s2.empty() && (s2.top() ^ x) == 1)
                s2.pop();
            else if ( !(x==1 || (n%2==0 && n==x)))
                s2.push(x);

        }

        if (s1.size()!=0 || s2.size()!=0)
            cout << "No" << endl;
        else cout << "Yes" << endl;
    }
}
```01postpublish01110a324e62f2934545f46a5c9943f16757f{"cid":3,"title":28,"slug":3,"created":10,"modified":10,"text":19371,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}289[学习笔记]Splay平衡树28915398319601543921897<!--markdown-->> 这个代码拖得也是够久了。。一个月之前Treap写炸了之后就写了份Splay的代码，但总是毛病众多，结果直到今天才算是调出来。

<!--more-->

## 算法介绍

**伸展树(Splay Tree)**，也叫**分裂树**，是一种能自我平衡的二叉查找树，它能在均摊$O(\log n)$的时间内完成基于伸展树的插入、查找、修改和删除操作。Splay的格局，是和别处不同的(雾。Splay的目的并不是维持树的平衡，而是将上次访问的数放在最近的地方，方便下次访问。经过数学论证，可以得出其均摊时间复杂度仍为$O(\log n)$。

首先，因为Splay仍然是一棵平衡树，所以很显然会用常见的`rotate()`——旋转操作。翻转操作一般分为左旋转和右旋转，其作用是在满足二叉查找树的性质的前提下，将某个节点于其父节点进行“位置的交换”，具体效果分别如下:

![旋转操作](https://oi-songer.github.io/In%20Blog/Splay%E5%B9%B3%E8%A1%A1%E6%A0%91-1.png)

因此，Splay树中最为核心的便是`Splay()`——伸展操作。其作用是将一个节点上移到根节点，方便下次进行访问。`Splay()`具体进行的操作需要根据情况而定，可分为以下三类：

> 假设我们操作的是`node`节点。此外，我们定义一个`relation()`函数，返回该节点是其父亲的左儿子还是右儿子。

1. node节点的父亲节点就是根节点: `rotate(node);`； ![splay操作1](https://oi-songer.github.io/In%20Blog/Splay%E5%B9%B3%E8%A1%A1%E6%A0%91-2.png)
1. `node->relation() == node->fa->relation()`: `rotate(x->fa); rotate(x);`; ![splay操作2](https://oi-songer.github.io/In%20Blog/Splay%E5%B9%B3%E8%A1%A1%E6%A0%91-3.png)
1. `node->realtion() != node->fa->relation()`:  `roate(x); rotate(x)`； ![splay操作3](https://oi-songer.github.io/In%20Blog/Splay%E5%B9%B3%E8%A1%A1%E6%A0%91-4.png)

这便是Splay中比较基础的两个操作，其他具体用到的函数一般都会调用到这两个函数。其它具体函数的原理会在下面讨论。

## 实现细节

代码参考: [_Menci_](https://oi.men.ci/splay-template/)

### 节点(Node)

这是Node结构体的定义，提供了所需的属性和基本的函数:

```C++
struct Node
{
    //value为数值，size表示子树大小，cnt表示当前节点的数有多少个
    int value;
    int size, cnt;

    Node *fa, *son[2];

    //如果是左儿子就是0(L)，否则是1(R)
    bool relation()
    {
        return this == this->fa->son[R];
    }

    Node(const int &val = 0, Node *f = NULL)
        :value(val), size(1), cnt(1), fa(f)
    {
        son[L] = son[R] = NULL;
    }

    ~Node()
    {
        if (son[L])
            delete son[L];
        if (son[R])
            delete son[R];
    }
};
```

### 旋转(rotate)

旋转操作的基本原理已于上处讲过，不再赘述。这里的旋转将左旋和右旋结合在了一起。

```C++
//旋转操作
void rotate(Node *x)
{
    Node *old = x->fa;
    int flag = x->relation();

    // 将x的父节点指向x的祖父节点
    if (old->fa)
        old->fa->son[ old->relation() ] = x;
    x->fa = old->fa;

    //将x的某个儿子指向x的父亲
    if (x->son[ flag ^ 1 ])
        x->son[ flag ^ 1 ]->fa = old;
    old->son[ flag ] = x->son[ flag ^ 1 ];

    //将x的父亲指向x
    old->fa = x;
    x->son[ flag ^ 1 ] = old;

    //更新信息
    update(old);
    update(x);

    if (x->fa==NULL)
        root = x;
        
    return;
}
```

### 伸展(splay)

Splay操作也如上文所说，不再赘述。

```C++
//splay操作
Node *splay(Node *x, Node *target = NULL)
{
    if (!x)
        return x;

    while (x->fa != target)
    {
        if (x->fa->fa == target)
            rotate(x);
        else if (x->fa->relation() == x->relation() )
        {
            rotate(x->fa);
            rotate(x);
        }else
        {
            rotate(x);
            rotate(x);
        }
    }

    return x;
}
```

### 更新(update)

`update()`函数负责对节点的`size`进行更新。实现也很简单:

```C++
void update(Node *x)
{
    if (!x)
        return;

    x->size = x->cnt;
    if (x->son[L])
        x->size += x->son[L]->size;
    if (x->son[R])
        x->size += x->son[R]->size;
        
    return;
}
```

### 查找(find)

查找也是一个基础操作，按照常规的二叉查找树的搜索方法即可:

```C++
//查找某个数
Node *find(const int &value)
{
    Node *x = root;

    while (x && x->value!=value)
    {

        if (value < x->value)
            x = x->son[L];
        else
            x = x->son[R];
    }

    if (!x)
        return NULL;

    splay(x);

    return x;
}
```

### 插入(insert)

插入是平衡树中很基本的操作。在Splay中，我们在插入前首先需要考虑该数值在树内是否存在。如果存在，我们只需要让`cnt++`即可；但若是不存在，我们便需要先查找到适合插入的位置，然后新建节点插入，最后在伸展才可以。

```C++
//插入操作
Node *insert(const int &value)
{
    if (root==NULL)
    {
        root = new Node(value, NULL);
        return root;
    }

    //先查找在平衡树中是否存在
    Node *x = find(value);
    if (x)
    {
        x->cnt ++;
        x->size ++;

        return x;
    }

    //target为当前点，parent为上一次的点，mark标记target是parent的左儿子还是右儿子
    Node *target = root, *parent = NULL;
    bool mark;

    //找到需要插入的位置
    while (target)
    {
        parent = target;
        parent->size ++;

        if (value < parent->value)
            target = parent->son[mark = L];
        else 
            target = parent->son[mark = R];
    }

    //新建Node, 如果parent不是NULL的话，对parent的儿子指针进行更改
    target = new Node(value, parent);
    if (parent)
        parent->son[ mark ] = target;

    splay(target);

    return target;
}
```

### 删除(erase)

删除操作和插入操作也类似，我们需要考虑删除的数是否只存在一个。若是存在多个，我们只需要让`cnt--`即可。但是若是存在一个，我们便需要通过一个较为复杂的方法对节点进行删除。

首先，很明显，我们不能直接对一个节点进行删除，这样的话可能会破坏树的结构。那么，我们的思路便是令我们想要删除的节点`node`不存在子节点，然后再删除。对此，我们有一个较为简单的方案：先将`node`的前趋节点移到根节点，再将`node`的后继节点移到根节点的右儿子的位置。此时，步骤如下，可以看出`node`节点变成了其后继的儿子，且其没有任何儿子，所以我们可以直接进行删除。

![删除操作](https://oi-songer.github.io/In%20Blog/Splay%E5%B9%B3%E8%A1%A1%E6%A0%91-5.png)

代码如下:

```C++
//节点的删除操作(只删除一个)
void erase(Node *x)
{
    if (x->cnt > 1)
    {
        splay(x);
        x->cnt --;
        x->size --;

        return;
    }

    Node *pre = pred(x);
    Node *suc = succ(x);

    splay(pre);
    splay(suc, pre);

    delete x;
    if (x->fa)
        x->fa->son[ x->relation() ] = NULL;
    
    if (x==root)
        root = NULL;

    update(suc);
    update(pre);

    return;
}
```

对数的删除操作只需要对上个函数进行调用就好了:

```C++
//某个数的删除操作(只删除一个)
void erase(const int &value)
{
    erase(find(value));

    return;
}
```

### 前趋(pred)

因为我们每个节存储的是当前数值的所有数，而不是一个数，所以求前趋就非常简单了。在大多数情况下，一个数的前趋就是这个点的前趋。我们只需要求其左儿子，然后若存在右儿子，一直向下求即可:

```C++
Node *pred(Node *x)
{
    Node *pre = x->son[L];

    if (!pre)
        return NULL;
    
    while (pre->son[R])
        pre = pre->son[R];
    
    return pre;
}
```

当然，可能会存在一个节点没有左儿子的情况，这种情况下，一个节点的前趋一般为其父亲。不过，由于我们在这里一般调用的是`pred(int):int`，而在这个函数里(具体来说，是在其中调用的`find()`函数里)，我们对该节点进行了一次`splay()`，所以其一定为根节点，所以不需要考虑这种情况。

在`pred(int):int`中，我们还需要多考虑一种情况：当想要查询的数值不存在时。这是我们需要手动插入一个节点，然后查询，最后再将这个节点删除。

```C++
//查询某个数的前趋
const int &pred(const int &value)
{
    Node *x = find(value);

    if (x)
        return pred(x)->value;
    else
    {
        x = insert(value);
        const int &ans = pred(x)->value;
        erase(x);

        return ans;
    }
}
```

### 后继(succ)

后继和前趋类似，分为节点查询和数查询两个函数:

```C++
//查询某个节点的后继
Node *succ(Node *x)
{
    Node *suc = x->son[R];

    if (!suc)
        return NULL;
    
    while (suc->son[L])
        suc = suc->son[L];

    return suc;
}
```

```C++
//查询某个数的后继
const int &succ(const int &value)
{

    Node *x = find(value);

    if (x)
        return succ(x)->value;
    else
    {
        x = insert(value);
        const int &ans = succ(x)->value;
        erase(x);

        return ans;
    }
}
```

### 查询数的排名(rank)

查询排名也分为了两个函数，一个是查询节点排名，一个查询数的排名。对于节点，和前趋和后继一样，因为在`rank(int)`中伸展过，我们还是只考虑当前节点已被移到根节点的情况，较为简单，所以函数如下:

```C++
//查询某个点的排名
int rank(Node *x)
{
    return (x->son[L]==NULL) ? 0: x->son[L]->size;
}
```

对于数，我们也还是需要考虑当前数不存在的情况:

```C++
//查询某个数的排名
int rank(const int &value)
{
    Node *x = find(value);

    if (x)
        return rank(x);
    else
    {
        x = insert(value);
        int ans = rank(x);
        erase(x);

        return ans;
    }
}
```

### 查询特定排名的节点或数(select)

`select(int)`函数主要依赖`rank(int)`来运作。这里需要注意，因为在查询过程中我们没有进行`Splay()`,所以说`rank(Node*)`代表的并不是该节点的排名，而是其左子树的大小。所以我们在向右子树搜索的时候需要将当前节点和左子树的大小减去，然后搜索。

```C++
//选择第k大的数
Node *select(int k)
{
    Node *x = root;
    while ( !( rank(x)+1 <= k && (rank(x) + x->cnt >=k) ) )
    {
        
        if (k < rank(x) + 1)
            x = x->son[L];
        else
        {
            k -= rank(x) + x->cnt;
            x = x->son[R];
        }
    }

    splay(x);

    return x;
}
```


## 例题

### Luogu 3369

题目来源: [_Luogu_](https://www.luogu.org/problemnew/show/P3369)

非常裸的一道平衡树，涉及了很多基本的操作。

```C++
#include <iostream>

#define L 0
#define R 1

using namespace std;    

struct Node
{
    //value为数值，size表示子树大小，cnt表示当前节点的数有多少个
    int value;
    int size, cnt;

    Node *fa, *son[2];

    //如果是左儿子就是0(L)，否则是1(R)
    bool relation()
    {
        return this == this->fa->son[R];
    }

    Node(const int &val = 0, Node *f = NULL)
        :value(val), size(1), cnt(1), fa(f)
    {
        son[L] = son[R] = NULL;
    }

    ~Node()
    {
        if (son[L])
            delete son[L];
        if (son[R])
            delete son[R];
    }
};

struct Splay
{
    Node *root;

    Splay()
    {
        root = NULL;
    }

    ~Splay()
    {
        delete root;
    }

    //更新节点的size
    void update(Node *x)
    {
        if (!x)
            return;

        x->size = x->cnt;
        if (x->son[L])
            x->size += x->son[L]->size;
        if (x->son[R])
            x->size += x->son[R]->size;

        return;
    }

    //旋转操作
    void rotate(Node *x)
    {
        Node *old = x->fa;
        int flag = x->relation();
    
        // 将x的父节点指向x的祖父节点
        if (old->fa)
            old->fa->son[ old->relation() ] = x;
        x->fa = old->fa;

        //将x的某个儿子指向x的父亲
        if (x->son[ flag ^ 1 ])
            x->son[ flag ^ 1 ]->fa = old;
        old->son[ flag ] = x->son[ flag ^ 1 ];

        //将x的父亲指向x
        old->fa = x;
        x->son[ flag ^ 1 ] = old;

        //更新信息
        update(old);
        update(x);

        if (x->fa==NULL)
            root = x;

        return;
    }

    //splay操作
    Node *splay(Node *x, Node *target = NULL)
    {
        if (!x)
            return x;

        while (x->fa != target)
        {
            if (x->fa->fa == target)
                rotate(x);
            else if (x->fa->relation() == x->relation() )
            {
                rotate(x->fa);
                rotate(x);
            }else
            {
                rotate(x);
                rotate(x);
            }
        }

        return x;
    }

    //查询某个节点的前趋
    Node *pred(Node *x)
    {
        Node *pre = x->son[L];

        if (!pre)
            return NULL;

        while (pre->son[R])
            pre = pre->son[R];

        return pre;
    }

    //查询某个节点的后继
    Node *succ(Node *x)
    {
        Node *suc = x->son[R];

        if (!suc)
            return NULL;
        
        while (suc->son[L])
            suc = suc->son[L];

        return suc;
    }

    //查询某个点的排名
    int rank(Node *x)
    {
        return (x->son[L]==NULL) ? 0: x->son[L]->size;
    }

    //查找某个数
    Node *find(const int &value)
    {
        Node *x = root;

        while (x && x->value!=value)
        {

            if (value < x->value)
                x = x->son[L];
            else
                x = x->son[R];
        }

        if (!x)
            return NULL;

        splay(x);

        return x;
    }

    //插入操作
    Node *insert(const int &value)
    {
        if (root==NULL)
        {
            root = new Node(value, NULL);
            return root;
        }

        //先查找在平衡树中是否存在
        Node *x = find(value);
        if (x)
        {
            x->cnt ++;
            x->size ++;

            return x;
        }

        //target为当前点，parent为上一次的点，mark标记target是parent的左儿子还是右儿子
        Node *target = root, *parent = NULL;
        bool mark;

        //找到需要插入的位置
        while (target)
        {
            parent = target;
            parent->size ++;

            if (value < parent->value)
                target = parent->son[mark = L];
            else target = parent->son[mark = R];
        }

        //新建Node, 如果parent不是NULL的话，对parent的儿子指针进行更改
        target = new Node(value, parent);
        if (parent)
            parent->son[ mark ] = target;

        splay(target);

        return target;
    }

    //节点的删除操作(只删除一个)
    void erase(Node *x)
    {
        if (x->cnt > 1)
        {
            splay(x);
            x->cnt --;
            x->size --;

            return;
        }

        Node *pre = pred(x);
        Node *suc = succ(x);

        splay(pre);
        splay(suc, pre);

        delete x;
        if (x->fa)
            x->fa->son[ x->relation() ] = NULL;
        
        if (x==root)
            root = NULL;

        update(suc);
        update(pre);

        return;
    }

    //某个数的删除操作(只删除一个)
    void erase(const int &value)
    {
        erase(find(value));

        return;
    }

    //查询某个数的排名
    int rank(const int &value)
    {
        Node *x = find(value);

        if (x)
            return rank(x);
        else
        {
            x = insert(value);
            int ans = rank(x);
            erase(x);

            return ans;
        }
    }

    //选择第k大的数
    Node *select(int k)
    {
        //k++;

        Node *x = root;
        while ( !( rank(x)+1 <= k && (rank(x) + x->cnt >=k) ) )
        {
            
            if (k < rank(x) + 1)
                x = x->son[L];
            else
            {
                k -= rank(x) + x->cnt;
                x = x->son[R];
            }
        }

        splay(x);

        return x;
    }

    //查询某个数的前趋
    const int &pred(const int &value)
    {
        Node *x = find(value);

        if (x)
            return pred(x)->value;
        else
        {
            x = insert(value);
            const int &ans = pred(x)->value;
            erase(x);

            return ans;
        }
    }

    //查询某个数的后继
    const int &succ(const int &value)
    {

        Node *x = find(value);

        if (x)
            return succ(x)->value;
        else
        {
            x = insert(value);
            const int &ans = succ(x)->value;
            erase(x);

            return ans;
        }
    }

    //debug用
    void print(Node *x)
    {
        if (x)
        {
            cout << "(" << x->value << ", " << x->cnt << ")-[ ";
            print(x->son[L]);
            cout << ", ";
            print(x->son[R]);
            cout << "]";
        }
    }

}*splay;

int main()
{
    splay = new Splay();

    int n;
    cin >> n;

    for (int i = 1; i<=n; i++)
    {
        int opt;
        cin >> opt;

        int x;
        switch(opt)
        {
            case 1:
                cin >> x;
                splay->insert(x);
                break;
            case 2:
                cin >> x;
                splay->erase(x);
                break;
            case 3:
                cin >> x;
                cout << splay->rank(x)+1 << endl;
                break;
            case 4:
                cin >> x;
                cout << splay->select(x)->value << endl;
                break;
            case 5:
                cin >> x;
                cout << splay->pred(x) << endl;
                break;
            case 6:
                cin >> x;
                cout << splay->succ(x) << endl;
                break;
            default:
                cout << "Error: No such operation!" << endl;
        }
        //splay->print(splay->root);
        //cout << endl;
    }
}

```

### Luogu 3391

题目来源: [_Luogu_](https://www.luogu.org/problemnew/show/P3391)01postpublish01110228c8d7e8a03900e1f917bf3d783b25b{"cid":3,"title":17,"slug":3,"created":10,"modified":10,"text":1871,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}291热浪 [Dijkstra]29115399369601543591173<!--markdown-->## Code[VS] 1557

> 整理板子时发现这个博客里竟然没有Dijkstra的板子。

<!--more-->

题目来源: [_Code\[VS\]_](http://codevs.cn/problem/1557/)

## 分析

简单的带有heap的Dijkstra。

## 代码

```C++
#include <iostream>
#include <queue>

#define INF 0x3f3f3f3f
#define MAXN 3000

using namespace std;

struct Node
{
    struct Edge *edge;
    int dist;
    int id;

    Node()
    {
        edge = NULL;
        dist = INF;
    }

    const bool operator <(const Node &tmp) const
    {
        return this->dist < tmp.dist;
    }

}node[MAXN];

struct Edge
{
    Node *from, *to;
    Edge *next;
    
    int val;

    Edge(Node *from, Node *to, int val):
        from(from), to(to), next(from->edge), val(val)  {}
};

int dist[MAXN];

priority_queue<Node> q;
void Dijkstra(Node st)
{
    dist[st.id] = 0;
    st.dist = 0;

    q.push(st);
    while (!q.empty())
    {
        Node tmp = q.top();
        q.pop();

        if (dist[tmp.id]!=tmp.dist)
            continue;
        
        for (Edge *e = tmp.edge; e; e = e->next)
        {
            if ( dist[e->to->id] > tmp.dist + e->val)
            {
                Node to = *e->to;
                dist[to.id] = tmp.dist + e->val;
                to.dist = dist[to.id];

                q.push( to );
            }
        }
    }
}

int main()
{
    int t, c, ts, te;
    cin >> t >> c >> ts >> te;

    for (int i = 1; i<=t; i++)
    {
        dist[i] = INF;
        node[i].id = i;
    }
    for (int i = 0; i<c; i++)
    {
        int x, y, z;
        cin >> x >> y >> z;

        node[x].edge = new Edge(&node[x], &node[y], z);
        node[y].edge = new Edge(&node[y], &node[x], z);
    }

    Dijkstra(node[ts]);

    cout << dist[ node[te].id ];
}
```01postpublish01110a84760765f9f35f646b24a3ac48c9f01{"cid":3,"title":9,"slug":3,"created":10,"modified":10,"text":2597,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}308World Cup30815440989981544098998<!--markdown-->
## CF Gym 101194 L

> 这其实就是2016年EC final的题目，发布在了CF上。这道题还是属于比较简单的一道。

<!--more-->

题目来源： [_Codeforces_](https://codeforces.com/gym/101194/attachments)

## 分析

给出了四个队伍，他们互相之间进行6场比赛。每次比赛中，获胜方加3分，失败方不加分。若平局的话则各加一分。要求对于给出的四个队伍的比赛后的分数，判断其是否合法。若合法，判断其是否可以通过该分数得出每场比赛的胜负（即得出的分数的比赛结果是否唯一）。

对于这道题，因为一个队伍只能打3场比赛，所以其最高分数就是9分。多余9分的情况接不可能。所以，我们能够用一个四位数来表示当前的状态，四个数字分别代表四个队伍的分数。这样的话，我们便可以通过一个预处理算出所有可行的情况，然后每组数据只需查询即可。

我们的预处理可以通过dfs来完成，通过枚举每场比赛的三个不同的结果，最后将当前状态的计数器加1。在查询时，若计数器为0，则说明`Wrong Scoreboard`；若计数器为1，则说明`Yes`；若计数器大于等于2，则是`No`。

## 代码

```C++
#include <iostream>
#include <algorithm>

using namespace std;

int mark[1000000];
int both[7][2] = { {0, 0}, {1, 2}, {1, 3}, {1, 4}, {2, 3}, {2, 4}, {3, 4} };

int a[6];
void make(int cnt)
{
    //cout << a[1] << " " << a[2] << " " << a[3] << " " << a[4] << endl;
    if (cnt>6)
    {
        mark[ a[1] + a[2]*10 + a[3]*100 + a[4]*1000 ]++;
        
        //cout << a[1] + a[2]*10 + a[3]*100 + a[4]*1000 << endl;

        return;
    }

    a[ both[cnt][0] ] += 3;
    make(cnt+1);
    a[ both[cnt][0] ] -= 3;

    a[ both[cnt][0] ] += 1;
    a[ both[cnt][1] ] += 1;
    make(cnt+1);
    a[ both[cnt][0] ] -= 1;
    a[ both[cnt][1] ] -= 1;

    a[ both[cnt][1] ] += 3;
    make(cnt+1);
    a[ both[cnt][1] ] -= 3;

}

int main()
{
    int T;
    cin >> T;

    make(1);

    for (int cas = 1; cas<=T; cas++)
    {
        for (int i = 1; i<=4; i++)
        {
            cin >> a[i];
        }

        //sort(a+1, a+5);
        int sum = a[1] + a[2]*10 + a[3]*100 + a[4]*1000;
        //cout << sum << endl;

        cout << "Case #" << cas << ": ";
        if (mark[sum]==0)
            cout << "Wrong Scoreboard" << endl;
        else if (mark[sum]==1)
            cout << "Yes" << endl;
        else cout << "No" << endl;
    }
}
```01postpublish01110cea4194f14815ef1a0e6e49a6462a1c1{"cid":3,"title":21,"slug":3,"created":10,"modified":10,"text":2876,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}311大二上第十八周31115462721471546272147<!--markdown-->
## 2018 12 31 周一

<!--more-->

大概还有半个小时，2018年就要过去了。我向来是一个没有什么节日感的人，不知道从什么时候开始，不再为节日而感到兴奋。不过此时此刻，却多少想要写些东西，但也无从下笔。

18年一整年，其实给了我非常大的变化。这一年里，我ACM参加了一次校赛，一次市赛，一次省赛，一次CCPC，两次ICPC和一次ICPC EC final。代码技术不见得增长了多少，但是于我独立处事方面有不小的帮助。从最初出远门时的紧张，到后来作为队长安排事宜时的逐渐熟悉。我终于明白了，ACM确实对人来说是一种成长，一种见识和能力的成长，而不仅仅是竞赛水平。

不过说到竞赛，这一年的成长或许确实不够大。从大一时偶尔水水题，到后来的集训，再到后来比赛后整天咕咕咕。我现在也很难弄明白我这一年的成长大不大。Cf的分数倒是从1500多涨到了1700多，但总感觉有些虚，不知是因为水平的自然增长还是只是因为人品比较好。

不过回头看看，我的所谓Diary却几乎成了ACM Diary。我这一年中，总还是该有些和ACM无关的事情的。但是仔细想想，似乎除了一些学习相关却无事可记。感觉自己，似乎已经被“计算机”或者说是“梦想”困住了。况且，我真的有“梦想”吗？我自认为是一个理想主义者。但我似乎也说不出一个真正的属于我的理想。消除不公？奉献于科学？还是只是为了满足自己的满足感，去争一个所谓的第一？但生活中的阻碍又太多，不论什么理想，总有感觉与现实十分遥远。这两天，我确实地感觉到了确切地迷茫：我到底想要什么？我已经碌碌了很久了，往往被自己心中的一些小小的满足欺骗，告诉自己“这就够了”。但是，这真的够了吗？

我或许真的没有理想罢。很多人都是有理想的，尽管有人的理想是钱，有人的理想是名，有人的理想是权。但理想确实是理想，许多人是存在这种理想的。但我想要什么呢？我只是有着一丝不甘平庸。但我不知道我的目的地。

于是，在这无目的的旅途上，我又航行了一年。2018已经快要过去了，一年匆匆，感觉没有任何现实感。今年的雪也已经飘过了，但是感觉和去年的没有什么不同。

昨天晚上做了一个梦，梦见自己在一个孤岛上的小房子里，从窗户望去是泛着绿色的与天空相接映的海面。可随之而来的是一场毁灭一切的风暴。没有任何意义的梦，不过总是心中有种悲伤异或悲壮的感觉。

在打下这一段时，2019年也迎来了它的第一刻。灯熄了。新的一年要开始了。01postprivate01110a425d7896d3f8e38e66516ce2b22089e{"cid":3,"title":12,"slug":3,"created":10,"modified":10,"text":4632,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}316拆拆拆数31615489100801548912305<!--markdown--># Wannafly Day 0 C

> 一道大分类讨论。

<!--more-->

## 分析
这道题就是一道构造题，我们需要将`x`和`y`分为`n`份，使得$\sum_{i=1}^n a_i = x$,$\sum_{i=1}^n b_i = y$,并且令$n$尽可能地小。此时我们需要根据情况进行分类讨论。

1. 当$gcd(x,y)=1$时,这时候$x$,$y$互质，所以$n$就为$1$。所以直接输出$x$和$y$即可。
2. 当他们不互质时，首先考虑当$x$和$y$同奇或同偶的时候。我们可以把第一个数分为$2$和$x-2$，然后我们将$y$分为$y+1-x$和$x-1$。很明显，首先，$x-2$与$x-1$互质。然后，因为$x$,$y$同奇偶，所以$y-x+1$一定是个奇数，因此其与$2$互质。当然，此时需要确保$x<y$，若不符合，置换`x`,`y`即可。
3. 但是，上面的情况其实需要考虑一种特殊情况。因为题目要求了$a_i, b_i > 1$，而当$x=y$时，$x-y+1=1$，所以不符合题目要求。此时，我们只要令$a_1 = 2, a_2 = x - 2, b_1 = 3, b_2 = y - 3$即可。因为$2$,$3$互质，$x-2$,$x-3$互质。
4. 然后我们便需要考虑$x$,$y$奇偶不同的时候了。我们此时先假设$x$为奇数，$y$为偶数的情况。然后，我们其实需要根据$x$的情况再进行分类：
    1. 当$x\ mod 3 \neq 2$时，我们可以将$x$分为$2$,$x-2$，并且将$y$分为$y-3$,$3$。因为$x\ mod 3 \neq 2$，所以$(x-2)\ mod 3 \neq 0$，所以它们互质。然后又因为$y$是偶数，所以$y-3$是奇数，所以它与$2$互质。
    2. 当$x\ mod 3 = 2$时，我们则可以将$x$分为$4$,$x-4$，并且将$y$分为$y-3$,$3$。这样的话，此时因为$x\ mod 3 = 2$，所以$(x-4)\ mod 3 \neq 0$，所以它们互质。而$y-3$又与$4$互质，因此满足条件。
    3. 此外，我们可能会注意到，$x-4$在$x=5$时可能为$1$，所以我们还需要单独考虑这种情况。因为$5$是素数，且$x$,$y$不互质，所以$y$一定是它的倍数，所以$y>=10$。那么我们便令$a_1 = 2, a_2 = 3$，并且$b_1 = y - 5, b_2 = 5$即可。

## 总结

~ ans = \\left\\{ \\begin{aligned} &a_1 = x,& &b_1 = y,& &\\gcd(x,y)=1& \\\\ &a_1=2, a_2 = x - 2,& &b_1 = 3, b_2 = y - 3,& &x = y& \\\\ &a_1 = 2, a_2 = x - 2, &&b_1 = y+1-x, b_2 = x-1, &&x\\ mod 2 = y\\ mod 2& \\\\ &a_1 = 2, a_2 = x - 2,& &b_1 = y-3, b_2 = 3,& &x\\text{ odd }y\\text{ even },\\text{and }x\\ mod 3 \\neq 2& \\\\ &a_1 = 2, a_2 = 3,& &b_1 = y-5, b_2=5,& &x=5,y\\text{ even }& \\\\ &a_1 = 4, a_2 = x - 4,& &b_1 = y-3, b_2 = 3,& &x\\text{ odd }y\\text{ even },\\text{and }x\\ mod 3 = 2 & \\end{aligned} \\right. ~

## 代码

```C++
#include <iostream>
#include <algorithm>

using namespace std;

int n;
long long ans[5][2];
int k = 0;

long long gcd(long long x, long long y)
{
    return x % y == 0? y : gcd(y, x%y);
}

int main()
{
    int T;
    cin >> T;

    while (T--)
    {
        k = 0;

        long long x, y;
        cin >> x >> y;

        if (gcd(x, y)==1)
        {
            n = 1;
            ans[1][0] = x;
            ans[1][1] = y;
        }
        else
        {
            n = 2;

            if (x == y)
            {
                ans[1][0] = 2;
                ans[2][0] = x - 2;
                ans[1][1] = 3;
                ans[2][1] = x - 3;
            }
            else if (x % 2 == y % 2)
            {
                if (y<x)
                {
                    swap(x, y);
                    k = 1;
                }

                ans[1][0] = 2LL;
                ans[2][0] = x - 2;
                ans[1][1] = y + 1 - x;
                ans[2][1] = x - 1;
            }else
            {
                if (x%2==0)
                {
                    swap(x, y);
                    k = 1;
                }
                if (x % 3 != 2)
                {
                    ans[1][0] = 2LL;
                    ans[2][0] = x - 2;
                    ans[1][1] = y - 3;
                    ans[2][1] = 3LL;
                }
                else if (x==5)
                {
                    ans[1][0] = 2;
                    ans[2][0] = 3;
                    ans[1][1] = y - 5;
                    ans[2][1] = 5;
                }
                else 
                {
                    ans[1][0] = 4LL;
                    ans[2][0] = x - 4;
                    ans[1][1] = y - 3;
                    ans[2][1] = 3LL;
                }
            }
        }

        cout << n << endl;
        for (int i = 1; i<=n; i++)
            cout << ans[i][k] << " " << ans[i][k^1] << endl;
    }
}
```01postpublish011101585cfa6af66dfe20dc2ae8e230e4156{"cid":3,"title":26,"slug":3,"created":10,"modified":10,"text":3568,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}326爬爬爬山 [SPFA+建图]32615490029001549002974<!--markdown--># Wannafly Day 0 F

> 一道建图题。

<!--more-->

题目来源：[_comet OJ_](https://zhixincode.com/contest/3/problem/F?problem_id=39)

## 分析

这道题的主要难点在于如何建图（虽然也不是很难）。在题目给出的情况中，有`n`座山，和`m`条路，我们先把它们建成一个图。但是，我们可以发现我们还需要考虑“削山”的费用，那么，我们便可以把“削山”这个过程转化为一条边来处理。我们可以看出，wls的初始体力为$k+hegiht[1]$，所以说所有途径的大于该高度的山都需要削。那么我们便可以将一座山分为两个点，一个只有入边，一个只有出边，然后将他们之间连上一条权值等于$\max(0, (k+height[1]-height[i])^2)$的边，然后跑一遍最短路即可。

> 虽然wls说这道题没卡SPFA，但是不知道为什么我的SPFA和Dijkstra都过不了。。。。最后只有加了LLL优化和读入优化之后SPFA才过。。。而且还比别人的慢。。。我现在已经严重怀疑我的指针写法的效率了。。。。

## 代码

```C++
#include <iostream>
#include <algorithm>
#include <queue>

#define MAXN 100100
#define MAXM 200100
#define INF 0x3f3f3f3f3f3f3f3f

using namespace std;

struct Edge;

struct Node
{
    Edge *edge;
    long long high, dist;
    bool flag;

    Node()
    {
        high = 0;
        flag = false;
        dist = INF;
        edge = NULL;
    }
}node[2*MAXN];

struct Edge
{
    Node *from, *to;
    long long val;
    Edge *next;

    Edge(Node *from = NULL, Node *to = NULL, long long val = 0)
        :from(from), to(to), val(val), next(from? from->edge: NULL)   {}

};

long long n, m, k;

deque<Node*> q;
long long SPFA(Node *s, Node *t)
{
    s->dist = 0;
    s->flag = true;
    q.push_back(s);

    while (!q.empty())
    {
        Node *tmp = q.front();
        q.pop_front();

        for (Edge *e = tmp->edge; e; e = e->next)
        {
            if (tmp->dist + e->val < e->to->dist)
            {
                e->to->dist = tmp->dist + e->val;

                // cout << e->to->high << " " << e->to->dist << endl;

                if (!e->to->flag)
                {
                    e->to->flag = true;
                    if ( (!q.empty()) && e->to->dist < q.front()->dist)
                        q.push_front(e->to);
                    else q.push_back(e->to);
                }
            }
        }
        tmp->flag = false;
    }

    return t->dist;
}

long long getlonglong()
{
    long long x = 0;

    char c = getchar();

    while (c<'0' || c>'9')
        c = getchar();

    while (c<='9' && c>='0')
        x = x * 10 + c - '0', c = getchar();

    return x;
}

int main()
{
    cin >> n >> m >> k;

    for (long long i = 1; i<=n; i++)
    {
        node[i].high = getlonglong();
        node[n+i].high = - node[i].high;
    }

    for (long long i = 1; i<=m; i++)
    {
        long long x, y, z;
        x = getlonglong();
        y = getlonglong();
        z = getlonglong();

        node[n+x].edge = new Edge(&node[n+x], &node[y], z);
        node[n+y].edge = new Edge(&node[n+y], &node[x], z);
    }

    k += node[1].high;

    for (long long i = 1; i<=n; i++)
    {
        long long x = max(node[i].high - k, 0LL);
        node[i].edge = new Edge(&node[i], &node[n+i], x*x);
    }

    long long ans = SPFA(&node[1], &node[2*n]);

    cout << ans << endl;
}
```01postpublish01110abe43a2c93affa539257642731fc4e6f{"cid":3,"title":32,"slug":3,"created":10,"modified":10,"text":2289,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}309Ice Cream Tower [ 二分答案 ]30915440996751544099686<!--markdown-->
## CF Gym 101194 D

<!--more-->

## 分析

这道题第一眼看上去感觉贪心可做，然而会发现存在不可行的情况。对于一个高度为`k`的Tower，其最大值肯定越小越好，其最小值肯定也越大越好。但是中间值却不一定，其是存在后效性的。所以贪心是不可行的。

既然贪心不可行，而有没有什么其他的好方法，便只能用二分了。二分的难点在于`check()`操作是否可行，答案是否单调。首先答案明显是单调的，所以问题不大。而`check()`操作是否可以实现呢？假设我们当前需要check`m`个Tower，那么我们完全可以假设这`m`个Tower是以最小的`m`为顶。我们可以发现，这完全是可行的。然后，所以往后的操作也是贪心的，即若是可以加入便可以直接加。那么，我们可以得到一个$O(n)$的`check()`操作。此问题得解。

此外，还要注意一个二分时常见的问题--答案是“靠左的”还是“靠右的”。若答案是靠左的，`mid`应取`(l+r)/2`，且`x<=a[mid]`时`r=mid`；若答案时靠右的，`mid`应取`(l+r)/2+1`，且`x>=a[mid]`时`l=mid`。

## 代码

```C++
#include <iostream>
#include <algorithm>

#define MAXN 300100

using namespace std;

long long a[MAXN];
long long b[MAXN];

bool check(int m, int n, int k)
{
    for (int i = 1; i<=m; i++)
        b[i] = a[i];

    int j = m+1;
    if (j == m * k + 1)
        return true;

    for (int i = m+1; i<=n; i++)
    {
        if ( a[i] >= b[ (j - 1) % m + 1 ] * 2 )
        {
            b[ (j - 1) % m + 1 ] = a[i];
            j++;
            
            if (j == m * k + 1)
                return true;
        }
    }

    return false;
}

int main()
{
    int T;
    cin >> T;

    for (int cas = 1; cas<=T; cas++)
    {
        int n, k;
        cin >> n >> k;

        for (int i = 1; i<=n; i++)
            cin >> a[i];

        sort(a+1, a+1+n);

        int l = 0, r = n;
        while (l!=r)
        {
            int mid = (l + r) / 2 + 1;
            if (check(mid, n, k))
                l = mid;
            else r = mid - 1;
        }

        cout << "Case #" << cas << ": " << l << endl;
    }
}
```01postpublish01110025424bbee0eeed6219002734cef5bca{"cid":3,"title":19,"slug":3,"created":10,"modified":10,"text":6446,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}312Wannafly Camp Day 031215480026401548033126<!--markdown-->> 今天是Camp的第一天，总共才做出来两道题，其中一道还几乎和我无关（捂脸。不过今天由于比较自闭，所以闲的没事几乎把所有题看了一下。其中有两题思路已经接近正确答案了，但是并没有继续推下去。。。今天最主要的问题还是对于题目的深挖，很多题目分析到后来便感觉无力，然后就放弃了。其中一个原因是到了后来没有毅力做下去，还有一个便是对题目的当前做法的可行性的分析不够准确。这是目前主要需要提高的地方。

<!--more-->

## 题目及解析

### A 机器人

题目来源: [_comet OJ_](https://www.zhixincode.com/contest/3/problem/A?problem_id=34)

首先，这个题目给定的$n$的数据非常之大，所以我们首先要从此处着手。题目中给出的一个关键的性质是"agv只能在特殊站点掉头"，并且"agv只能通过这些特殊站点实现区与区之间的转换"。所以，我们可以看出，非特殊点的点其实是不具备节点的性质的，或者说，我们可以把他们缩为边的一部分。这样，我们便可以把它缩为200个结点的图。对于某个点必走的情况我们可以把他变成某个边必走的情况。

然后我们在这个图上根据实际情况进行分类讨论即可。然后对不同的情况直接求值即可。

### B 吃豆豆

题目来源: [_comet OJ_](https://www.zhixincode.com/contest/3/problem/B?problem_id=35)

首先我们来看$C$较小时($C=1018$)的做法。我们可以使用$dp[i][j][k]$来存储在第$k$秒时走到$(i,j)$的收集到的糖果量，然后直接DP即可，转移方程如下：

$$ dp[i][j][k] = dp[i+ip[z]][j+jp[z]][k-1] + ( T[i][j]%k==0?1:0 ) $$

其中，$ip[], jp[]$存储了一次移动的位移。当$dp[i][j][k] > C$时，条件便满足了。

然后，当我们的$C$变为$10^{18}$时，我们便需要使用倍增的方法来实现。因为$T[i][j] \leq 10$，所以我们可以把所有的$T[i][j]$的最小公倍数的最大值$2520$当作一个大周期。这样的话我们便可以利用大的周期来倍增去掉$C$中的大部分，最后剩下小于$2520$的部分再按照上面的DP直接求即可。

### C 拆拆拆树

题目来源: [_comet OJ_](https://www.zhixincode.com/contest/3/problem/C?problem_id=36)

这道题我们队是按照构造题来做的，情况比较复杂，但是构造出来之后问题就不大了。其情况大致如下：

~\\left\\{ \\begin{align} n = 1, &&\\ a_1 = x, && b_1 = y \\ &\\ (x,y互\\ \\ 质\\ \\ )\\\\ n = 2, &&\\ a_1 = 2, a_2 = x - 2, && b_1 = y + 1 - x, b_2 = x - 1 \\ &\\ (x,y同\\ \\ 奇\\ \\ 或\\ \\ 同\\ \\ 偶\\ \\ ) \\\\ n = 2, &&\\ a_1 = 2, a_2 = x - 2, && b_1 = y - 3, b_2 = 3 \\ &\\ (x奇\\ \\ y偶\\ \\ 且\\ \\ x\\ mod\\ 3 \\neq 2)\\\\ n = 2, &&\\ a_1 = 4, a_2 = x - 4, && b_1 = y - 3, b_2 = 3 \\ &\\ (x奇\\ \\ y偶\\ \\ 且\\ \\ x\\ mod\\ 3 = 2)\\\\ \\end{align} \\right. ~

实际情况下，还要根据$x,y$是否相等和是否会有为$1$的输出特殊判断，此外还要注意因为我们上式中假设了$x$奇$y$偶，若情况相反时`swap()`后输出要注意输出顺序。

### D 超难的数学题

题目来源: [_comet OJ_](https://www.zhixincode.com/contest/3/problem/D?problem_id=37)

这题并不会，当时讲的时候也没有听懂，留位置以用于补题。

### E 流流流动

题目来源: [_comet OJ_](https://www.zhixincode.com/contest/3/problem/E?problem_id=105)

这题当时想了很长时间，并没有想到树上DP的做法，甚至完全没有想到DP上去。因为给定的数字建出的图的特殊性质，该图实际上是一棵树，然后直接树上DP即可。

### F 爬爬爬山

题目来源: [_comet OJ_](https://www.zhixincode.com/contest/3/problem/F?problem_id=39)

这题其实就是一个建图题，难度在于如何建图，而且实际上也比较简单。因为wls体力不能低于$0$，所以最高的山也应该小于$k+high[1]$。这样的话，走最高的山就会有一个$(k+high[1]-high[i])^2$的代价。我们可以将这个代价抽象为一条边，对这个节点进行拆电，然后跑一边最短路即可。

### G 双重矩阵

题目来源: [_comet OJ_](https://www.zhixincode.com/contest/3/problem/G?problem_id=40)

这题比赛时我们队伍是按照分类讨论的方法来想的，但是情况比较复杂，最后并没有分析出来。实际上利用我们要求的是最大的子矩阵的这个性质，我们完全可以暴力枚举一个举行的上、左、下三个边，然后由于我们只考虑比当前的答案更大的值，所以右边的边会只会向右移动而不会向左移动，所以并不会增加时间。此外加上一个树状数组或线段树来维护区间的`gcd()`，这样便能在给定时间内求出了。

### H 我爱割葱

题目来源: [_comet OJ_](https://www.zhixincode.com/contest/3/problem/H?problem_id=41)

这题当时做的时候便认为是DP，但是由于并没有写过这种递归类型的DP，所以只是认为需要找一个方程然后循环即可，所以并没能找到一个可用的DP方程。实际的做法应该为根据葱的底将从分为互不相连的几部分，然后递归的让他们计算出来，最后再用这些部分来更新当前部分的信息。

### I 起起落落

题目来源: [_comet OJ_](https://www.zhixincode.com/contest/3/problem/I?problem_id=42)

我们先分别存储到位置$i$的比$j$个数要小的数的个数，然后枚举所有的节点，按照下面的公式进行DP：

$$ dp[i] = \sum_1^{i-2}  dp[k] * smaller[k][i] $$

不过该方程智能计算$n$较小时的情况，所以还需要进一步的优化。但是当时并没有听懂优化的具体写法。

### J 夺宝奇兵

题目来源: [_comet OJ_](https://www.zhixincode.com/contest/3/problem/J?problem_id=43)

首先朴素的想，我们可以枚举除wls外宝物最多的人有多少宝物。然后我们需要拿走所有大于该数量的宝物，此后直接贪心的拿更便宜的直至符合条件，这样便能算出最少需要的金币。

不过这个算法较为朴素，所以我们还需要进一步优化，不过这题的优化也没有听懂。。。

### K 星球大战

题目来源: [_comet OJ_](https://www.zhixincode.com/contest/3/problem/K?problem_id=44)

此题同D，完全不懂。01postpublish0111006c2daac040a53bebc09cc8224f00d0c{"cid":3,"title":39,"slug":3,"created":10,"modified":10,"text":4309,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}333不同内存分配方式的时间差异33315502974601550297563<!--markdown-->> 自从开始熟悉的cpp的指针写法后，我在使用疯狂使用指针的路上一去不复返（苦笑）。然而，自此之后，我发现自己的程序总是比别人慢半拍（其实不止半拍。。）。于是想要比较一下不同写法的差异。没想得，只是写了一下内存分配的部分，就发现了问题的根源所在。。。

<!--more-->

## 分析

在这里，我们通过对新建$10^7$个`Node`结构体来比较不同的分配方法所花费的时间。并且，我们在分配完成后进行一次初始化操作。`Node`结构体如下：
```C++
struct Node
{
    int x;

    Node (int x = 0):x(x)   {}   
};
```

我们的所有操作都是在以下的循环体内进行：
```C++
for (int i = 0; i<MAXN; i++)
{
	//code here
}
```

首先，我们考虑的是最常用的情况：直接定义，赋值。代码为:`Node x = Node(i);`。经多次实验，所花费的时间大概为`31ms`。

然后，便是指针写法。代码为:`Node *x = new Node(i);`。所花费时间大致为`500ms`到`600ms`。

此外，我们尝试了一下提前获取内存空间，然后在需要指针时将已经获取到的内存空间分配给当前指针的写法。这里的写法是一个较为普适性的写法，使用了一个`MemoryPool`的结构体，若是只需分配一种结构体的空间则可以不用这么麻烦。`MemoryPool`的写法参照于[_Menci_](https://oi.men.ci/chairman-tree-notes/)，写法如下：
```C++
template <size_t SIZE>
struct MemoryPool
{
    char buf[SIZE], *cur;

    MemoryPool():cur(buf)  {}

    void *malloc(int size)
    {
        if (size + cur > buf + SIZE)
        {
            //cout << "out of memory" << endl;
            return malloc(size);
        }

        char *p = cur;
        cur += size;
        return (void *)p;
    }
};

MemoryPool<sizeof(Node) * MAXN> pool;
```
然后再循环内执行下列代码即可：
```C++
Node *x = (Node*)pool.malloc(sizeof(Node));
*x = Node(i);
```

该方法的循环执行时间大概为`90ms`，加上大致`30ms`的初始内存分配时间，大致为`120ms`。

另外，此时的循环内代码通过引用`new`头文件(`#include <new>`)，可以简写为`Node *x = new ((Node*)pool.malloc(sizeof(Node))) Node(i);`，对运行时间没有什么影响。

由此，我们可以得出结论。各方法的时间比约为$1:20:4$。也就是说，若是为了运行效率考虑，还是普通的直接定义使用的方法优先。但若是想用指针又想较为快速的话，也可以使用第三种方法，不过这样令变量的生命周期更加难于管理，所以在实际工程中不建议使用，在竞赛中可以作为优化指针速度的一种手段。

## 完整代码

```C++
#include <iostream>
#include <new>
#include <windows.h>

#define MAXN 10000000

using namespace std;

struct Node
{
    int x;

    Node (int x = 0):x(x)   {}   
};

template <size_t SIZE>
struct MemoryPool
{
    char buf[SIZE], *cur;

    MemoryPool():cur(buf)  {}

    void *malloc(int size)
    {
        if (size + cur > buf + SIZE)
        {
            //cout << "out of memory" << endl;
            return malloc(size);
        }

        char *p = cur;
        cur += size;
        return (void *)p;
    }
};

MemoryPool<2 * sizeof(Node) * MAXN> pool;

int main()
{
    DWORD a = GetTickCount();

    //方法一：直接定义
    for (int i = 0; i<MAXN; i++)
    {
        Node x = Node(i);
    }

    DWORD b = GetTickCount();

    //方法二：使用指针
    for (int i = 0; i<MAXN; i++)
    {
        Node *x = new Node(i);
    }

    DWORD c = GetTickCount();

    //方法三：提前分配空间，然后分配空间
    for (int i = 0; i<MAXN; i++)
    {
        Node *x = (Node*)pool.malloc(sizeof(Node));
        *x = Node(i);
    }

    DWORD d = GetTickCount();

    //方法四：在方法三的基础上使用new方法
    for (int i = 0; i<MAXN; i++)
    {
        Node *x = new ((Node*)pool.malloc(sizeof(Node))) Node(i);
    }

    DWORD e = GetTickCount();

    cout << "The time we spent were " << b - a << ": " << c - b << ": " << d - c << ": " << e - d << endl;

    return 0;
}
```01postpublish01110bbd9a06641a9e29fd85464d38b633671{"cid":3,"title":15,"slug":3,"created":10,"modified":10,"text":1171,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}341最小边覆盖34115504969601551147495<!--markdown-->## Wannafly Day 3 C

<!--more-->

题目来源：[_comet OJ_](https://zhixincode.com/contest/18/problem/C?problem_id=261)

## 分析

题目给出了一个图，要求判断该图能否有可能是某一个图的最小边覆盖。

那么，我们需要考虑的便是最小边覆盖的性质：所有点必须连边；边最少。那么，实际上整个图一定可以分成许多不连通的子图，并且它们只会存在两种情况：一条边连两个点；菊花状的$n$条边连接$n+1$个点。也就是说，不会有两个度数大于2的点相连，并且点的度数不能为$0$。

## 代码

```C++
#include <iostream>

using namespace std;
int a[300010],b[300010];
int h[200010];
bool res=1;

int main()
{
    int m,n;
    cin>>n>>m;
    for(int i=0;i<m;i++)
    {
        cin>>a[i]>>b[i];
        h[a[i]]++;
        h[b[i]]++;
    }
    for(int i=0;i<m;i++)
        if(h[a[i]]>=2 && h[b[i]]>=2)
            res=0;
            
    for(int i=1;i<=n;i++)
        if (!h[i])
            res = false;
    if(res)
        cout<<"Yes"<<endl;
    else
        cout<<"No"<<endl;
    return 0;
}
```01postpublish0111002354cee6d25dc93a1f9686a53e2f9af{"cid":3,"title":21,"slug":3,"created":10,"modified":10,"text":1465,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}344小小马 [思维题]34415505848001551147532<!--markdown-->## Wannafly Day3 F

<!--more-->

题目来源：[_comet OJ_](https://zhixincode.com/contest/18/problem/F?problem_id=264)

## 分析

这题其实也是一道思维题。首先，我们先考虑黑点和白点的问题。由于马的跳法，每次$x$轴和$y$轴的位移一奇一偶，那么下一个点一定和当前点颜色不同。所以，只要起点和终点颜色不同，则此条件一定满足。

然后我们考虑是否能到达的问题。我们来考虑棋盘上马的跳法，可以发现，当棋盘的大小大于$3\times 3$时，马可以到达任何地方。而正好等于$3\times 3$时，最中间的点无法到达。而棋盘等于$2 \times n$的时候也直接判断即可。

## 代码

```C++
#include <iostream>
#include <stdlib.h>
using namespace std;
int m,n,sx,sy,ex,ey;
bool res=1;

int main()
{
    cin>>n>>m>>sx>>sy>>ex>>ey;
    if(n==1||m==1||(sx&1)^(sy&1)==(ex&1)^(ey&1))
    {
        res=0;
    }
    else if(n==2)
    {
        if(abs(ey-sy)%2)
            res=0;
        else if(ex!=2-(sx+abs(ey-sy)/2)%2)
            res=0;
    }else if(m==2)
    {
        if(abs(ex-sx)%2)
            res=0;
        else if(ey!=2-(sy+abs(ex-sx)/2)%2+1)
            res=0;
    }
    else if(m==3&&n==3)
    {
        if((ex==2&&ey==2)||(sx==2&&sy==2))
            res=0;
    }
    if(res)
        cout<<"Yes"<<endl;
    else
        cout<<"No"<<endl;
    return 0;
}
```01postpublish011104ef0964404ea20ff79904b5bd65a973d{"cid":3,"title":24,"slug":3,"created":10,"modified":10,"text":1375,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}343夺宝奇兵 [思维题]34315505840801551147507<!--markdown-->## Wannafly Day 3 A

<!--more-->

题目来源：[_comet OJ_](https://zhixincode.com/contest/18/problem/A?problem_id=259)

## 分析

这道题的关键在于依次从$1$到$n$然后从$n$到$1$。我们只考虑从$i$到$i+1$的情况，因为我们可以发现不同的$i$之间是不会相互干扰的，那么：当我们的$i$已确定时，我们只需要选择距离最近的$i+1$即可。但我们要令$i$到$i+1$和后来的从$i+1$回到$i$的距离之和最小，那么只需要组合一下，取和最小的情况即可。

## 代码

```C++
#include <iostream>
#include <algorithm>

#define MAXN 100100

using namespace std;

int x[MAXN][2], y[MAXN][2];

int calc(int i, int j)
{
    if (j)
        return abs(x[i+1][0] - x[i][0]) + abs(x[i+1][1] - x[i][1]) + abs(y[i+1][0] - y[i][0]) + abs(y[i+1][1] - y[i][1]);
    else
        return abs(x[i+1][0] - x[i][1]) + abs(x[i+1][1] - x[i][0]) + abs(y[i+1][0] - y[i][1]) + abs(y[i+1][1] - y[i][0]);
}

int main()
{
    int n, m;
    cin >> n >> m;

    for (int i = 1; i<=n; i++)
    {
        cin >> x[i][0] >> y[i][0];
        cin >> x[i][1] >> y[i][1];
    }

    long long ans = 0;
    for (int i = 1; i<n; i++)
        ans += min( calc(i,0), calc(i,1) );

    ans += abs(x[n][0] - x[n][1]) + abs(y[n][0] - y[n][1]);

    cout << ans << endl;
}
```01postpublish01110e68dbf70a565ffdf2800a67852c7bd7f{"cid":3,"title":12,"slug":3,"created":10,"modified":10,"text":1497,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}345置置置换34515506713801551230323<!--markdown-->## Wannafly Day 3 G

<!--more-->

题目来源：[_comet OJ_](https://zhixincode.com/contest/18/problem/G?problem_id=265)

## 分析

这道题我们是套用公式来解的，不过好像可以使用DP来解决。DP的方法日后补充。

## 代码

```C++
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
using namespace std;
const int MOD=1000000007;
int n;
long long A[1010];
long long phi(long long k)
{
    long long res=k,tmp=k;
    for(long long i=2;i*i<=tmp;i++)
    {
        if(k%i==0)
        {
            res=res/i*(i-1);
            res%=MOD;
            while(k%i==0) k/=i;
        }
    }
    if(k>1) res=res/k*(k-1);
    return res;
}
long long C[1010][1010];
int main()
{
    scanf("%d",&n);
    A[0]=A[1]=A[2]=1;
    C[1][0]=C[1][1]=1;
	for (int i=2;i<=1000;i++)
	{
		C[i][0]=1;
		for(int j=1;j<=1000;j++)
        {
            C[i][j]=(C[i-1][j]+C[i-1][j-1]);
            C[i][j]%=MOD;
        }
	}
    for(int i=3;i<=1000;i++)
    {
        for(int j=0;j<=i-1;j++)
        {
            A[i]+=(C[i-1][j]*A[j]%MOD)*A[i-1-j] % MOD;
            A[i]%=MOD;
        }
        A[i]=(A[i] * 500000004)%MOD;
    }
    printf("%lld\n",A[n]);
    /*if(n%2==0) printf("%lld\n",phi(n)%MOD);
    else
    {
        for(int i=0;i<=n;i++)
        {
            ans+=phi(i)*cal(n,i,MOD);
        }
        printf("%lld\n",ans);
    }*/
    return 0;
}
```01postpublish0111078d3ede75cf4e7dce1968a2e7f55ef72{"cid":3,"title":27,"slug":3,"created":10,"modified":10,"text":2626,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}339排列 [构造，思维题]33915504096601551147482<!--markdown-->## Wannafly Day 2 G

<!--more-->

题目来源：[_comet OJ_](https://zhixincode.com/contest/14/problem/G)

## 分析

在分析之前，我们要再重述一下`q`数组的求法：对于排列$p$，我们对其所有的前缀排序，然后用排序后的顺序的前缀的长度组成排列$p$。

其中，前缀之间的比较遵循以下规则：
1. $min(p_j)$更小的前缀更小。$(j = 1..i)$
2. 当$min(p_j)$相同时，长度更小的前缀更小。

那么，遵循以上规则，我们其实可以发现一些规律。首先，我们假设一个前缀中最小的$p_j$为“决定因子”。那么：
1. 长度最小的前缀的最后一位一定是$1$；
2. 比上一个前缀长度更大且排名更靠后的前缀的最后一位一定不为决定因子；
3. 比上一个前缀长度更小且排名更靠后的前缀的最后一位一定为决定因子。

在尝试推出这些结论之前，我们要先确定一个事实：数组`q`中的前缀的决定因子一定为降序。这里不再证明，应该很好理解。

首先，第一个结论非常容易得出。

而第二个结论：若前缀长度为$p_j$，则其决定因子一定大于等于$p_{j-1}$的决定因子。又由于它的长度大于$p_{j-1}$，所以它包含了$p_{j-1}$的前缀，所以其决定因子等于$p_{j-1}$的决定因子。所以，其决定因子一定不在最后一位。所以，最后一位的数值对其排名无影响。

而对于第三个结论：若前缀长度为$p_j$。由于当前前缀比$p_{j-1}$更靠后，且长度更小，说明而$p_j$的决定因子更大。那么这个决定因子一定是第一次出现。一个决定因子决定的排序最靠前的前缀一定是以这个决定因子为最后一位。

那么，我们这时直接构造即可。按照之前的原理，我们只需要令$p_j < p_{j-1}$的前缀的最后一位为决定因子，它们为从1开始逐个递增。剩下的位置，由于答案要求字典序，则从前到后按字典序填充即可。

## 代码

```C++
#include <iostream>
#include <algorithm>

#define MAXN 100100

using namespace std;

int q[MAXN], p[MAXN];

int main()
{
    int n;
    cin >> n;

    for (int i = 1; i<=n; i++)
    {
        cin >> q[i];
        p[i] = 0;
    }

    int cnt = 1;
    for (int i = 1; i<=n; i++)
    {
        if (i==1 || q[i]<q[i-1])
            p[q[i]] = cnt++; 
    }

    for (int i = 1; i<=n; i++)
        if (p[i]==0)
            p[i] = cnt++;

    for (int i = 1; i<=n; i++)
        cout << p[i] << " ";
    cout << endl;
}
```
01postpublish0111054e8afadab7989e5a90d4767371c86f2{"cid":3,"title":29,"slug":3,"created":10,"modified":10,"text":2977,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}337Cosmic Cleaner [计算几何]33715504006601551147439<!--markdown-->## Wannafly Day 1 H

> 一道裸的三维计算几何题，也是当天当时唯一做出来的一道题。

<!--more-->

题目来源：[_comet OJ_](https://zhixincode.com/contest/11/problem/H)

## 分析

这道题的题意十分好分析，其实就是求一个大球和$n$个小球的交的总和。对于球的交，我们可以先判断它们是否相交，若相交直接套用公式即可，否则要判断一下特殊情况。

## 题解

```C++

#include <iostream>
#include <algorithm>
#include <cmath>
#include <iomanip>
#include <cstring>

using namespace std;

const double PI = acos(-1.0);

struct Point
{
    double x, y, z;

    Point() {}

    Point(double x, double y, double z)
        :x(x), y(y), z(z) {}

    Point operator - (const Point &tmp) const
    {
        return Point(this->x - tmp.x, this->y - tmp.y, this->z - tmp.z);
    }

    Point operator + (const Point &tmp) const
    {
        return Point(this->x + tmp.x, this->y + tmp.y, this->z + tmp.z);
    }

    Point operator * (const double &k) const
    {
        return Point(this->x * k, this->y * k, this->z * k);
    }

    Point operator / (const double &k) const
    {
        return Point(this->x / k, this->y / k, this->z / k);
    }

    double operator * (const Point &tmp) const
    {
        return this->x * tmp.x + this->y * tmp.y + this->z * tmp.z;
    }
};

double dist(Point a, Point b)
{
    return sqrt( (a - b) * (a - b) );
}

struct Sphere
{
    Point center;
    double r;

    Sphere()    {};

    Sphere(Point center, double r)
        :center(center), r(r)   {}
}a[110];

double SphereInterV(Sphere a, Sphere b)
{
    double d = dist(a.center, b.center);
    double l1 = ( (a.r * a.r - b.r * b.r) / d + d) / 2.0;

    double l2 = d - l1;
    double x1 = a.r - l1, x2 = b.r - l2;

    double v1 = PI * x1 * x1 * (a.r - x1 / 3.0);
    double v2 = PI * x2 * x2 * (b.r - x2 / 3.0);

    double v = v1 + v2;
    return v;
}

int main()
{
    ios::sync_with_stdio(false);

    int T;
    cin >> T;

    for (int cas = 1; cas<=T; cas++)
    {
        memset(a, 0, sizeof(a));

        int n;
        cin >> n;

        for (int i = 1; i<=n; i++)
        {
            int x, y, z, r;
            cin >> x >> y >> z >> r;

            a[i] = Sphere(Point(x, y, z), r);
        }

        int x, y, z, r;
        cin >> x >> y >> z >> r;
        Sphere clear(Point(x, y, z), r);

        double ans = 0;
        for (int i = 1; i<=n; i++)
        {
            if ( dist(clear.center, a[i].center) + a[i].r <= clear.r)
                ans += 4.0 / 3 * PI * a[i].r * a[i].r * a[i].r;
            else if ( dist(clear.center, a[i].center) < a[i].r + clear.r)
                ans += SphereInterV(clear, a[i]);
        }

        cout << fixed;
        cout << "Case #" << cas << ": " << setprecision(20) << ans << endl;
    }
}
```01postpublish01110acd5a95dbb73e3daeecfdd4940f084cf{"cid":3,"title":28,"slug":3,"created":10,"modified":10,"text":3079,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}348Special Judge [计算几何]34815508451401551147568<!--markdown-->## Wannafly Day4 J

<!--more-->

题目来源：[_comet OJ_](https://zhixincode.com/contest/22/problem/J?problem_id=315)

## 分析

一道计算几何的模板题，难点在于特殊情况的判断很复杂，很容易想漏。我们需要分别对端点对端点，端点对线段，线段对线段，平行，重合并相交，重合但是线段不相交，重合并包含这几种情况分别进行判断。

## 代码

```C++
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
using namespace std;

const double eps=1e-8;
const double PI=acos(-1.0);
int sgn(double x)
{
    if(fabs(x)<eps) return 0;
    if(x<0) return -1;
    else return 1;
}
struct Point
{
    double x,y;
    int mark;

    Point(){}
    Point(double _x,double _y)
    {
        x=_x;
        y=_y;
    }
    bool operator == (const Point &b)const
    {
        return sgn(x-b.x)==0&&sgn(y-b.y)==0;
    }
    Point operator - (const Point &b)const
    {
        return Point(x-b.x,y-b.y);
    }
    double operator ^ (const Point &b)const
    {
        return x*b.y-y*b.x;
    }
    double operator * (const Point &b)const
    {
        return x*b.x+y*b.y;
    }
};
struct Line
{
    Point s,e;
    Line(){}
    Line(Point _s,Point _e)
    {
        s=_s;
        e=_e;
    }
};

bool inter(Line l1,Line l2)
{
    return
    max(l1.s.x,l1.e.x)>=min(l2.s.x,l2.e.x)&&
    max(l2.s.x,l2.e.x)>=min(l1.s.x,l1.e.x)&&
    max(l1.s.y,l1.e.y)>=min(l2.s.y,l2.e.y)&&
    max(l2.s.y,l2.e.y)>=min(l1.s.y,l1.e.y)&&
    sgn((l2.s-l1.e)^(l1.s-l1.e))*sgn((l2.e-l1.e)^(l1.s-l1.e))<=0&&
    sgn((l1.s-l2.e)^(l2.s-l2.e))*sgn((l1.e-l2.e)^(l2.s-l2.e))<=0;
}

bool cmp(Point p,Point q)
{
    if(p.x==q.x) return p.y<q.y;
    return p.x<q.x;
}
Point a[1010];
int u[2010],v[2010];
int ans,n,m;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
        scanf("%d%d",&u[i],&v[i]);
    for(int i=1;i<=n;i++)
    {
        scanf("%lf%lf",&a[i].x,&a[i].y);
    }
    for(int i=1;i<=m;i++)
    {
        for(int j=i+1;j<=m;j++)
        {
            Line l1(a[u[i]],a[v[i]]),l2(a[u[j]],a[v[j]]);
            if(sgn((l1.e-l1.s)^(l2.e-l2.s))==0)
            {
                if(inter(l1,l2))
                {
                    Point b[5];
                    b[1]=a[u[i]];
                    b[1].mark = i;
                    b[2]=a[u[j]];
                    b[2].mark = j;
                    b[3]=a[v[i]];
                    b[3].mark = i;
                    b[4]=a[v[j]];
                    b[4].mark = j;
                    sort(b+1,b+1+4,cmp);

                    if (b[1].mark!=b[2].mark && !(b[2].x == b[3].x && b[2].y == b[3].y))
                        ans ++;

                }
            }
            else
            {
                if(inter(l1,l2)) ans++;
                if(u[i]==u[j]||v[i]==u[j]||u[i]==v[j]||v[i]==v[j]) ans--;
            }
        }
    }
    printf("%d\n",ans);
    return 0;
}
```01postpublish011101138e01b68b4ef3ec8c2c5058e5bb3d6{"cid":3,"title":24,"slug":3,"created":10,"modified":10,"text":1703,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}347欧拉回路 [构造题]34715507583201551147559<!--markdown-->## Wannafly Day3 D

> 虽说是构造题，实际这题并没有要求构造，只需输出最值即可。

<!--more-->

题目来源：[_comet OJ_](https://zhixincode.com/contest/18/problem/D?problem_id=262)

## 分析

对于这题，我们可以向欧拉回路的性质上去靠。首先我们都知道，欧拉回路的所有的点的度数都为偶数。那么，我们可以首先假设所有的边都被走过了一遍，此时我们可以得到一个此时的所有的点各自的度数的值。

那么，我们的目标便是令这些值都为偶数。方法则为将临近的两个奇数度数的点的连边走的次数+1，此时这两个点的度数都会便为偶数。若它们不相邻，则通过连边可以令度数为奇数的点的位置发生移动，最后移到相邻为止即可。

那么，消去某两个奇数度数点的代价其实就相当于它们之间的曼哈顿距离。而对于题目给出的这个矩形的图，所有奇数点都会出现在非四个顶点位置的四个边上。那么，我们便先将相邻的消掉，然后在对剩下的几个特殊判断处理即可。

## 代码

```C++
#include <iostream>
#include <algorithm>

using namespace std;

int main()
{
    int n, m;
    cin >> n >> m;

    int ans = 0;
    ans += (n-1) * m + (m-1) * n;

    if (n%2==0 && m%2==0)
    {
        ans += n - 2 + m - 2;
    }else if (n%2==1 && m%2==1)
    {
        ans += n - 3 + m - 3 + 4;
    }else if (n%2==0 && m%2==1)
    {
        ans += n - 2 + m - 3 + min(3, n - 1);
    }else if (n%2==1 && m%2==0)
    {
        ans += n - 3 + m - 2 + min(3, m - 1);
    }

    cout << ans << endl;
}
```01postpublish01110c298e3bf0877f0b2e2fd13d30a5e7135{"cid":3,"title":21,"slug":3,"created":10,"modified":10,"text":1109,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}357Two Cakes [思维题]35715510769801551403133<!--markdown-->## CF Contest 542 B

<!--more-->

题目来源：[_codeforces_](https://codeforces.com/problemset/problem/1130/B)

## 分析

这道题其实和Wannafly Camp中的[_夺宝奇兵_](../343/)有异曲同工之妙。我们有两个人，他们分别需要从`0`走到`n`，那么我们其实可以发现对于每次从第$i$个走到$i+1$个，谁在哪个位置完全没有影响，我们只需要考虑怎么走最近即可。

## 代码

```C++
#include <iostream>
#include <algorithm>

#define MAXN 100100

using namespace std;

int a[MAXN][2];

int main()
{
    int n;
    cin >> n;

    for (int i = 1; i<=2*n; i++)
    {
        int x;
        cin >> x;
        if (a[x][0]==0)
            a[x][0] = i;
        else a[x][1] = i;
    }

    long long ans = 0;
    ans += a[1][0] + a[1][1] - 2;
    for (int i = 1; i<n; i++)
    {
        int min1 = abs(a[i][0] - a[i+1][0]) + abs(a[i][1] - a[i+1][1]);
        int min2 = abs(a[i][0] - a[i+1][1]) + abs(a[i][1] - a[i+1][0]);

        ans += min(min1, min2);
    }

    cout << ans << endl;
}
```01postpublish0111083927b90633033a3d9eff276a6d3ff61{"cid":3,"title":26,"slug":3,"created":10,"modified":10,"text":1904,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}369Zero Quantity Maximization36915530850501553085050<!--markdown-->
# CF 1133 D

<!--more-->

题目来源：[_Codeforces_](https://codeforces.com/contest/1133/problem/D)

## 分析

题目给出两个数组`a[]`和`b[]`，要求对于满足$c_i = d \cdot a_i + b_i$的数组`c[]`，当`d`取何值时`c[]`中有尽可能多的`0`。

我们只需要假设所有的`c[i]`都为`0`，然后求出满足其关系的`d`，找到出现次数最多的`d`就可以了。

这题当时做的时候最早没有用`map<>`，而是使用了排序后手动计算的方法，结果莫名其妙的出现了许多的bug，换成`map<>`之后就好了。。。此外，这里其实可以不使用`Node`，而是直接用一个`pair<int, int>`即可，只需要记住用`gcd()`将分数化为最简形式即可。

## 代码

```C++
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cmath>
#include <map>

#define MAXN 200100

using namespace std;

struct Node
{
    long long a, b;
    int k;

    void getK()
    {
        if (this->a * this->b<0)
            this->k = -1;
        else this->k = 1;
    }

    const bool operator < (const Node &tmp)const{
        return abs(this->b * tmp.a) * this->k < abs(tmp.b * this->a) * tmp.k;
    }

}node[MAXN];

map<Node, int> mp;

int main()
{
    ios::sync_with_stdio(false);

    int n;
    cin >> n;

    for (int i = 1; i<=n; i++)
        cin >> node[i].a;

    for (int i = 1; i<=n; i++)
    {
        cin >> node[i].b;
        node[i].getK();
    }

    int cnt = 0;
    for (int i = 1; i<=n; i++)
        if (node[i].a==0 && node[i].b==0)
        {
            cnt ++;
        }else if (node[i].a!=0)
        {
            mp[node[i]]++;
        }

    int ans = 0;
    map<Node, int>::iterator it;
    for (it = mp.begin(); it!=mp.end(); it++)
        ans = max(ans, it->second);

    cout << ans + cnt << endl;
}
```01postpublish011108245a5f1e6f082f679f41f3955460c09{"cid":3,"title":7,"slug":3,"created":10,"modified":10,"text":2223,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}358Connect35815510777411551077741<!--markdown-->
## CF Contest 542 C

<!--more-->

题目来源：[_codeforces_](https://codeforces.com/contest/1130/problem/C)

## 分析

这题还算是很裸的题目。我们首先通过BFS分别找到所有和起点和终点相连的点，然后将它们之间一一计算距离，取最小值即可。

## 代码

```C++
#include <iostream>
#include <cstring>
#include <queue>
#include <cstdio>

#define MAXN 55
#define INF 0x3f3f3f3f

using namespace std;

int n;
int a[MAXN*MAXN][2], b[MAXN*MAXN][2];
int an = 0, bn = 0;
char mp[MAXN][MAXN];
bool flag[MAXN][MAXN];

const int xp[] = {-1, 1, 0, 0};
const int yp[] = {0, 0, -1, 1};

bool in(int x,int y)
{
    return x>0 && x<=n && y>0 && y<=n;
}

queue< pair<int, int> > q;
void mk(int x, int y, int res[MAXN][2], int &cnt)
{
    memset(flag, false, sizeof(flag));
    while (!q.empty())
        q.pop();

    res[++cnt][0] = x;
    res[cnt][1] = y;

    flag[x][y] = true;
    q.push( pair<int, int>(x, y) );
    while (!q.empty())
    {
        int x = q.front().first;
        int y = q.front().second;
        q.pop();

        for (int i = 0; i<4; i++)
            if ( flag[x + xp[i]][y + yp[i]] == false && mp[x+xp[i]][y+yp[i]]=='0' && in(x+xp[i], y+yp[i]))
            {
                flag[x + xp[i]][y + yp[i]] = true;
                res[++cnt][0] = x + xp[i];
                res[cnt][1] = y + yp[i];
                q.push( pair<int ,int >(x + xp[i], y + yp[i]) );
            }
    }
}

int main()
{
    cin >> n;

    int sx, sy, ex, ey;
    cin >> sx >> sy;
    cin >> ex >> ey;

    for (int i = 1; i<=n; i++)
    {
        for (int j = 1; j<=n; j++)
            cin >> mp[i][j];
        getchar();
    }

    mk(sx, sy, a, an);
    mk(ex, ey, b, bn);

    int ans = INF;
    for (int i = 1; i<=an; i++)
        for (int j = 1; j<=bn; j++)
        {
            int xd = a[i][0] - b[j][0];
            int yd = a[i][1] - b[j][1];

            // cout << a[i][0] << " " << a[i][1] << endl;
            // cout << b[j][0] << " " << b[j][1] << endl;
            
            ans = min(ans, xd * xd + yd * yd);
        }

    cout << ans << endl;
}
```01postpublish011109ae7590789da4c50e1cee3fd9cdbaa69{"cid":3,"title":30,"slug":3,"created":10,"modified":10,"text":1576,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}351抢红包机器人 [思维题]35115509187001551147585<!--markdown-->## Wannafly Day5 G

<!--more-->

题目来源：[_comet OJ_](https://zhixincode.com/contest/26/problem/G?problem_id=375)

## 分析

由于题目要求至少存在一个机器人，所以我们必须先假设某一个人是机器人，然后以此向下推，推出所有必须是机器人的人，最后的总数就是机器人的最少数量。

那么，这个问题就变成了“第一个”机器人应该选谁的问题。事实上，由于不同人之间的关系是偏序的，即是可以传递的，譬如`i`比`j`快，`j`比`k`快，那么`i`为机器人时`k`也一定为机器人,所以我们可以直接用类似于floyd的方法推出对于任意的$i,j$，$i$是否比$j$快。然后我们只需要找到能够影响的$j$最少的$i$即可。

## 代码

```C++
#include <iostream>

using namespace std;
int n,m,b,res,c[105],sum;
bool a[105][105];

int main()
{
    cin>>n>>m;
    for(int i=0;i<m;i++)
    {
        cin>>b;
        for(int j=1;j<=b;j++)
        {
            cin>>c[j];
            for(int k=1;k<j;k++)
                a[c[k]][c[j]]=1;
        }
    }
    for(int k = 1; k <= n; ++k)
        for(int i = 1; i <= n; ++i)
            for(int j = 1; j <= n; ++j)
                if(a[i][k] == 1 && a[k][j] == 1)
                    a[i][j] = 1;
    res=105;
    for(int i=1;i<=n;i++){
        sum=0;
        for(int j=1;j<=n;j++)
            sum+=a[j][i];
        if(a[i][i]==0)
            sum++;
        res=min(sum,res);
    }
    cout<<max(1,res)<<endl;
    return 0;
}
```01postpublish0111017676ea31182c62ccd12648e460f0528{"cid":3,"title":12,"slug":3,"created":10,"modified":10,"text":841,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}355Be Positive 35515510760801551077540<!--markdown-->## CF Contest 542 A

<!--more-->

题目来源：[_codeforces_](https://codeforces.com/problemset/problem/1130/A)

## 分析

这题一看其实就是一个水题。我们只需要分别判断正负数的个数即可。正数数量$>= \frac{n}{2}$就输出`1`，负数数量$>= \frac{n}{2}$就输出`-1`，否则输出`0`。

## 代码

```C++
#include <iostream>

using namespace std;

int cnt[2];

int main()
{
    int n;
    cin >> n;
    
    cnt[0] = cnt[1] = 0;
    for (int i = 1; i<=n; i++)
    {
        int x;
        cin >> x;
        if (x>0)
            cnt[0] ++;
        else if (x<0)
            cnt[1] ++;
    }

    if (cnt[0] >= (n + 1) / 2)
        cout << 1 << endl;
    else if (cnt[1] >= (n + 1) / 2)
        cout << -1 << endl;
    else cout << 0 << endl;
}
```01postpublish01110671ff3bf4c8a32f9a57295ff31d201d7{"cid":3,"title":24,"slug":3,"created":10,"modified":10,"text":3515,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}353迷宫 [树，思维题]35315509209801551257531<!--markdown-->## Wannafly Day 5 A

<!--more-->

题目来源：[_comet OJ_](https://zhixincode.com/contest/26/problem/A?problem_id=369)

## 分析

首先很明显，题目中给出的是一颗树。我们需要将所有的人移到根节点，并且一个节点同时刻只能有一个人。

我们先假设如果不会有人的位置发生冲突的话，那么花费的时间其实就等于深度最大的人所花费的时间。但实际情况是有可能会有两个人同时需要进入同一个父节点（发生冲突），所以其中一个需要为另一个让路。那么我们可以发现，深度相同的节点之间一定会早晚发生冲突。两个节点发生冲突的结果就是其中一个需要多花费一个时间节点，那么若是三个节点发生冲突呢？一个节点多花费一个时间节点，还有一个多花费两个时间节点。也就是说，对于深度相同的节点来说，若共有$n$个人，那么便需要比起一个人多花费$n-1$的时间将所有人走完。

那么，我们便可以系统地考虑一下这道题里的情况了。我们可以令深度更小的节点一定先到达根节点，这可以确保答案最小。然后我们每一层都有两个关键的性质：深度`depth`和人数`n`。然后我们用`t[i]`表示深度为`i`的人走完后所花费的时间。深度能够决定当前层的第一个人到达根节点的可能最小时间（实际并不一定是，因为可能深度更小的节点的人未走完），人数则表示该层共花费的时间。那么公式便如下：

~ t[i] = max(t[ i - 1], depth - 1) + n - 1 ~

## 代码

```C++
#include <iostream>
#include <algorithm>
#include <queue>

#define MAXN 100100
#define INF 0x3f3f3f3f

using namespace std;

int a[MAXN];
int dist[MAXN];
bool flag[MAXN];
int maxDepth = 0;

struct Node
{
    struct Edge *edge;
    int num, depth, max;

    Node()
    {
        edge = NULL;
        depth = num = 0;
        max = INF;
    }

}node[MAXN];

struct Edge
{
    Node *from, *to;
    Edge *next;

    Edge()
    {
        from = to = NULL;
        next = NULL;
    }
    Edge(Node *from, Node *to, Edge *next=NULL)  
        :from(from), to(to), next(from->edge)  {}
};

int cnt[MAXN];
queue<Node *> q;
void build(Node *nd)
{
    q.push(nd);

    while (!q.empty())
    {
        Node *node = q.front();
        q.pop();
        for (Edge *e = node->edge; e; e = e->next)
        {
            if (e->to->depth == 0)
            {
                e->to->depth = node->depth + 1;
                if (e->to->num==1)
                    cnt[e->to->depth] ++;

                maxDepth = max(maxDepth, e->to->depth);

                q.push(e->to);
            }
        }
    }
}

int main()
{
    ios::sync_with_stdio(false);

    int n;
    cin >> n;

    for (int i = 1; i<=n; i++)
        cin >> node[i].num;

    for (int i = 1; i<n; i++)
    {
        int x, y;
        cin >> x >> y;
        node[x].edge = new Edge(&node[x], &node[y]);
        node[y].edge = new Edge(&node[y], &node[x]);
    }

    node[1].depth = 1;
    build(&node[1]);
    if (node[1].num==1)
        cnt[1] = 1;

    int t = 0;
    for (int i = 2; i<=maxDepth; i++)
        if (i-1>t && cnt[i])
        {
            t = i - 2 + cnt[i];
        }else if (i-1<=t && cnt[i])
        {
            t += cnt[i];
        }

    cout << t + cnt[1] << endl;

    return 0;
}
```01postpublish0111049eeb59a3e8360117307e5c92d637aa3{"cid":3,"title":21,"slug":3,"created":10,"modified":10,"text":2095,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}359Toy Train [思维题]35915510787801551230193<!--markdown-->## CF Contest 542 D

<!--more-->

## 分析

题目要求对于$n$个不同的起点，分别给出将所有糖果送完花费的最小时间。

我们可以先假设起点已经固定。由于我们每次可以携带多个糖果，并且可以卸下多个糖果，所以我们可以发现对于不同的$j$，将最初位于节点$j$的糖果送完所花费的时间相互之间互不干扰。

那么对于第$j$个节点，将这个节点的所有糖果送完所需要花费的时间是多少呢？我们假设起点为$i$。那么，我们第一次到达$j$所花费的时间就是$(j - i + n) \mod n$。然后我们假设节点$j$共有$k$个糖果，那么我们可以发现我们至少需要经过$j$节点$k$次才能拿到所有糖果。所以拿到所有糖果至少需要$(j - i + n) \mod n + (k - 1) *n$次移动。

此外，我们可以发现在下一次到达$j$点前，我们一定可以将上次从$j$点拿走的糖果送出去，所以，我们最后只剩下一个糖果没有送到位置。由于我们想令答案最小，所以只需要令最后送的位置最近即可。

那么，对于起点$i$,位置$j$的$k$个糖果$a_1 - a_k$（$k$必须不为$0$），所需花费的时间为:

~ t[j] = (j - i + n) \\mod n + (k - 1) * n + min( (a_i - j + n) \\mod n) ~

那么，对于起点$i$，所花费的最小时间即为$min(t[j])$。 

## 代码

```C++
#include <iostream>
#include <algorithm>

#define MAXN 5010
#define INF 0x3f3f3f3f

using namespace std;

int cnt[MAXN], nearest[MAXN];

int main()
{
    int n, m;
    cin >> n >> m;

    for (int i = 1; i<=n; i++)
        nearest[i] = INF;

    for (int i =1; i<=m; i++)
    {
        int x, y;
        cin >> x >> y;
        cnt[x] ++;
        nearest[x] = min(nearest[x], (y + n - x) % n );
    }

    for (int i = 1; i<=n; i++)
    {
        int ans = 0;
        for (int j = 1; j<=n; j++)
            if (cnt[j])
                ans = max(ans, (cnt[j] - 1) * n + nearest[j] + (j - i + n) % n );

        cout << ans << " ";
    }
}
```01postpublish01110086e88c749c6fd5df5dfdf7a3e091c50{"cid":3,"title":33,"slug":3,"created":10,"modified":10,"text":2312,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}360Wrong Answer [数学，构造题]36015510799801551080077<!--markdown-->
## CF Contest 542 E

<!--more-->

题目来源：[_codeforces_](https://codeforces.com/contest/1130/problem/E)

## 分析

这题算是一个十分有趣的题目，题目给出了一个代码，目标是求最大的$(r-l+1)*\sum_{i=l}^r a_i$，但是代码是错的。题目给出一个$k$，要求构造一组数据，该代码与正确答案的差恰好为$k$。

由于这题是构造题，那么我们尽可以向特殊情况去考虑。我采用了一种$0, -1, a_3, ..., a_n$的结构，这里$a_3$到$a_n$都大于$0$。那么实际上此时我们可以确定正确答案一定为$n \sum_{i=1}^n a_i$，并且题目给出的代码算出的一定是$(n-2) \sum_{i=3}^n a_i$。此时，我们就可以给出一个$k$的等式：

~ k = n \\sum_{i=1}^n a_i - (n-2) \\sum_{i=3}^n a_i ~

~ k = n \\times (a_1 + a_2) + n \\sum_{i=3}^n a_i - (n - 2) \\sum_{i=3}^n a_i ~

~ k = n \\times (a_1 + a_2) + 2 \\sum_{i=3}^n a_i ~

~ k = 2 \\sum_{i=3}^n a_i - n ~

又因为$a_i \leq 1e6$，所以：

~ \\frac{k + n}{2} = \\sum_{i=3}^n a_i ~

~ \\frac{k+n}{2 \\times (n -2)} = a_i ~

~ \\frac{k+2}{2 \\times (n-2)} + \\frac{1}{2} = a_i \\leq 1e6 ~

所以，我们只需要随便找到一个能够满足上述不等式的$n$，然后再带回去算出$\sum_{i=3}^n a_i$，然后将它们分到$n-2$个位置即可。

此外，我们还需要注意奇偶的问题。由于$k+n$一定是$2$的倍数，所以我们要根据$k$的奇偶性来确定$n$的奇偶性。

## 代码

```C++
#include <iostream>
#include <algorithm>

using namespace std;

int ans[2010];

int main()
{
    int k;
    cin >> k;

    int n = 3;
    ans[1] = 0;
    ans[2] = -1;

    if (k % 2 == 1)
    {
        for (; (k+2) / (n-2) > 1e6; n++);

        int t = ( k + n ) / 2;
        for (int i = 3; i<=n; i++)
        {
            ans[i] = t / (n - i + 1);
            t -= ans[i];
        }
    
    }else
    {

        for (; (k+2) / (n-2) > 1e6; n++);
        if (n%2==1)
            n++;

        int t = ( k + n ) / 2;
        for (int i = 3; i<=n; i++)
        {
            ans[i] = t / (n - i + 1);
            t -= ans[i];
        }
    }

    cout << n << endl;
    for (int i = 1; i<=n; i++)
        cout << ans[i] << " ";

}
```01postpublish01110b547488040b48cc8afd11da744cc3d4b{"cid":3,"title":26,"slug":3,"created":10,"modified":10,"text":2760,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}372Camp Schedule [KMP变形]37215530895601553089733<!--markdown--># CF 1137 B

<!--more-->

题目来源：[_Codeforces_](https://codeforces.com/contest/1137/problem/B)

## 分析

题目给出两个`01`串`s`和`t`，要求对`s`进行重新排列，令其含有尽可能多的`t`的子串。最简单的看，我们只需要令`s`被尽可能多的`t`的子串构成即可。

但实际上，如果`t`中存在部分前缀和部分后缀相同的情况的话就会非常麻烦。此外，还有可能`t`本身就是由数个重复串组成的。这时，我们可以用KMP中的`fail[]`数组来解决这个问题。

首先，我们需要先找出`t`中的循环节。注意，这时我们考虑的循环节，包括了`t`中的最后的后缀是循环节的一部分但并不是一个完整的循环节的情况（譬如，`ababa`的循环节即为`ab`，因为`a`也是`ab`的前缀，只是不是一个完整的循环节）。找出该循环节，我们其实可以用以下代码实现(参考于[_Cyclic Nacklace \[KMP变型\]_](http://songer.xyz/index.php/archives/235/))：

```C++
for (int i = t.length(); i>0; i = fail[i])
        x = max(x, i - fail[i]);
```

这样，我们其实只需要看`s`中有多少个`t`的循环节就好了。然后我们减去`t`本身有多少个循环节再加一即为答案。

## 代码

```C++
#include <iostream>
#include <algorithm>
#include <string>

#define MAXN 500100

using namespace std;

string s, t;

int fail[MAXN];

void getFail(string s)
{
    fail[0] = 0;

    for (int i = 1; i<s.length(); i++)
    {
        int j = fail[i];
        while (j && s[i]!=s[j])
            j = fail[j];
        fail[i+1] = s[i]==s[j]? j+1 : 0;
    }
}

int cnt[2];
int sum[2];
string str;

int main()
{
    cin >> s;
    cin >> t;

    getFail(t);

    str = "";
    int lent = t.length();
    int lens = s.length();
    int x = t.length();

    for (int i = t.length(); i>0; i = fail[i])
        x = max(x, i - fail[i]);

    for (int i = 0; i<lent; i++)
        cnt[ t[i] - '0' ] ++;

    for (int i = 0; i<lens; i++)
        sum[ s[i] - '0' ] ++;

    if (sum[0] >= cnt[0] && sum[1] >= cnt[1])
    {
        cout << t;
        sum[0] -= cnt[0];
        sum[1] -= cnt[1];

        cnt[0] = 0;
        cnt[1] = 0;

        for (int i = fail[lent]; i<lent; i++)
        {
            cnt[ t[i] - '0' ] ++;
            str += t[i];
        }

        while (sum[0] >= cnt[0] && sum[1] >= cnt[1])
        {
            cout << str;
            sum[0] -= cnt[0];
            sum[1] -= cnt[1];
        }

        while (sum[0]--)
            cout << 0;
        while (sum[1]--)
            cout << 1;

        cout << endl;
    }else 
        cout << s << endl;
}
```01postpublish011103a118247507c774f90da02b19ca5771a{"cid":3,"title":23,"slug":3,"created":10,"modified":10,"text":3330,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}371Skycsrapers [思维题]37115530873611553087361<!--markdown-->
# CF 1137 A

> 这是我的第一场Div.1，结果打完之后又掉回Div.2了，结束了我短暂的Div.1生涯。。。

<!--more-->

题目来源：[_Codeforces_](https://codeforces.com/contest/1137/problem/A)

## 分析

题目给出了一个$n \times m$的地图`mp[][]`，假设其由`n`条横向道路和`m`条纵向道路组成，并且在每一个路口都有一个摩天大楼，高度为`mp[i][j]`。然后，我们希望在不更改同一行或同一列的大楼之间的高度关系的情况下，令高度最高的大楼的高度尽可能的小。

这其实就是一个Hash，我们对于每一行或者每一列都Hash映射到尽可能小的数即可。不过我们还要考虑一个点同时对行和列的影响。譬如一个点在行中算出其为`10`，但是在列中是最小的。所以我们需要令列中的所有数都按照正常Hash的情况再加`9`。所以实际上，我们可以记录，每个点在行中或者列中，小于等于它的数的Hash值的数目和大于等于的数目，即`smaller[i][j][]`和`bigger[i][j][]`。第三维通过`0,1`来记录行列，然后答案在`smaller[i][j][]`和`bigger[i][j][]`中取组合的最大值即可。

## 代码

```C++
#include <iostream>
#include <algorithm>
#include <string>

#define MAXN 1010

using namespace std;

struct A
{
    int i, j;
    int x;

    A(){}

    A(int x, int i, int j):x(x), i(i), j(j) {}

    const bool operator < (const A &tmp) const
    {
        return this->x < tmp.x;
    }

    const bool operator != (const A &tmp) const
    {
        return this->x != tmp.x;
    }

}a[MAXN];

int mp[MAXN][MAXN];
int smaller[MAXN][MAXN][2], bigger[MAXN][MAXN][2];

int main()
{
    ios::sync_with_stdio(false);

    int n, m;
    cin >> n >> m;

    for (int i = 1; i<=n; i++)
        for (int j = 1; j<=m; j++)
            cin >> mp[i][j];

    for (int i = 1; i<=n; i++)
    {
        for (int j = 1; j<=m; j++)
            a[j] = A(mp[i][j], i, j);

        sort(a+1, a+1+m);

        int t = 1;
        smaller[ a[1].i ][ a[1].j ][0] = 1;
        for (int j = 2; j<=m; j++)
        {
            if (a[j]!=a[j-1])
                t++;

            smaller[ a[j].i ][ a[j].j ][0] = t;
        }

        for (int j = 1; j<=m; j++)
            bigger[ a[j].i ][ a[j].j ][0] = t - smaller[ a[j].i ][ a[j].j ][0];
    }

    for (int j = 1; j<=m; j++)
    {
        for (int i = 1; i<=n; i++)
            a[i] = A(mp[i][j], i, j);

        sort(a+1, a+1+n);

        int t = 1;
        smaller[ a[1].i ][ a[1].j ][1] = 1;
        for (int i = 2; i<=n; i++)
        {
            if (a[i]!=a[i-1])
                t++;

            smaller[ a[i].i ][ a[i].j ][1] = t;
        }

        for (int i = 1; i<=n; i++)
            bigger[ a[i].i ][ a[i].j ][1] = t - smaller[ a[i].i ][ a[i].j ][1];
    }

    for (int i = 1; i<=n; i++)
    {
        for (int j = 1; j<=m; j++)
        {
            int ans = max(smaller[i][j][0] + bigger[i][j][1], smaller[i][j][1] + bigger[i][j][0]);  
            ans = max(ans, smaller[i][j][0] + bigger[i][j][0]);
            ans = max(ans, smaller[i][j][1] + bigger[i][j][1]);

            cout << ans << " ";
        }
        cout << endl;
    }
}
```01postpublish011104c6648a752650ad1383aa9998868b8bd{"cid":3,"title":16,"slug":3,"created":10,"modified":10,"text":4742,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}374K Balanced Teams37415544317001555946065<!--markdown--># Codeforces 1133 E

<!--more-->

题目来源：[_Codeforces_](https://codeforces.com/contest/1133/problem/E)

## 分析

### 题意

我们需要将`n`个人分为`k`组，并且对于每组里的人，每个人都有一个`a[i]`，使得任意两人间的`a[i]`的差不超过`5`。

### 错误的思路

> 以下是我比赛时错误的思路，可以直接跳过不看。

首先，我们可以看到，我们可以使用`f[i][j]`来表示所有的状态。其中`i`表示使用前`i`个人，`j`表示将这些人分成`j`个组。很明显，这样完全可以表示所有状态，并且也方便转移。

那么，接下来我们就要考虑转移方程。比赛的时候，当时我认为，转移可以分为三种情况：

1. `f[i][j] = f[i-1][j-1] + 1` : 从第`i`个人开始，我们新开一个组。
2. `f[i][j] = f[i-1][j]` : 不选择第$i$个人。因为我们可能在两个组中间跳过一些人。
3. `f[i][j] = f[i-1][j] + 1` : 将当前的人加入到上一个组中。注意，此时应该满足组内`a[i]`之差小于`5`的条件。

这样，我就得到了一整个转移方程。然而，交上代码后却发现WA在了第25组。我本来以为是特判的问题。结果在反复测试后发现，以下的样例无法得出正确答案：

```
5 1
1 4 7 9 14
```

正确答案为`3`，选择的是`4, 7, 9`。但是实际上，通过我的程序跑出来的是`2`，选择了`1, 4`。也就是说，我的算法并不会"抛弃"一个组中的某些数从而去换取更好的答案。我们的`f[2][1]`记录了一个从`1`开始的组，但是实际上一个从`4`开始的组才能得到最佳答案，尽管从`f[2][1]`上来看它不是最佳的。也就是说，转移方程存在根本的问题。

### 正解

我们之前提到，我们要采用`f[i][j]`来存储状态，`i`表示取到第`i`个人，`j`表示将这些人分为了`j`组。但官方题解中给出的略有不同，其中`i`表示取到了第`i-1`个人，具体原因与转移方程有关。

官方的题解共有以下两个转移方程：

1. `f[i+1][j] = max(f[i+1][j], f[i][j])` : 当我们将不选择第`i`个的时候。
2. `f[i + cnt[i]][j + 1] = max(f[i + cnt[i]][j + 1], f[i][j] + cnt[i])` : 当我们以第$i$个开始选择`cnt[i]`个数作为第`j + 1`组的时候。其中`cnt[i]`表示从第`i`个人开始最多可以选几个符合条件的人，可以通过$O(n^2)$的初始化得出。

这样，我们最后可以输出`f[n+1][k]`，即为最终答案。

### 错解与正解的比较和分析

那么，之前的错解到底错在什么地方呢？

实际上，我的`f[i][j]`和正解中表示的`f[i][j]`表示的状态并不是相同的。我的`f[i][j]`表示的是取到第`i`个人共`j`个组。但是题解中给出的`i`,`j`，除了`i`表示的是第`i-1`个人以外，还有更重要的一点，此时选择的最后一个人（即第`i-1`个人，或者是我的方程中的第`i`个人），他要么是不被某个组选择（由方程1转移而来），或是是某个组的最后一个人（由方程2转移而来）。也就是说，他不可能是某个组的中间的人。

因为，实际上，我的`f[i][j]`是不能保证“最优子状态”的。它会将某些状态抹消掉，从而无法得出正确答案。

因此，错解的直接原因就是对状态的选择存在问题，或者说对“最优子状态”这一概念理解的还不够。

不过，初次之外还有一个很明显的问题。我们对比这两个解法的转移方程可以发现一个明显的不同：一个是枚举状态`y`，然后找到所有能转移的`y`的`x`，这也是最常见的写法；另一种是枚举`x`，然后找到所有能从此转移过去的`y`。此题由于`cnt[i]`的存在，所以明显更适合第二种写法。但是由于我这种写法写的很少，所以也很少向这个方向考虑，这也是限制我思路的一大因素。

## 代码

```C++
#include <iostream>
#include <algorithm>

#define MAXN 5010

using namespace std;

int a[MAXN];
int f[MAXN][MAXN];
int cnt[MAXN];

int main()
{
    int n, k;
    cin >> n >> k;

    for (int i = 1; i<=n; i++) 
        cin >> a[i];

    sort(a+1, a+n+1);

    for (int i = 1; i<=n; i++)
        while ( i + cnt[i] <= n && a[i + cnt[i]] - a[i] <= 5)
            cnt[i] ++;

    int ans = 0;
    for (int i = 1; i<=n; i++)
        for (int j = 0; j<=k; j++)
        {
            f[i+1][j] = max(f[i+1][j], f[i][j]);

            if (j<k)
            {
                f[i + cnt[i]][j + 1] = max(f[i + cnt[i]][j + 1], f[i][j] + cnt[i]);
            }
        }

    cout << f[n+1][k] << endl;
}
```01postpublish011106dcb8ba260686db45660493328c57b3e{"cid":3,"title":46,"slug":3,"created":10,"modified":10,"text":8445,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}377[学习笔记]可持久化线段树(主席树)37715560226601556025224<!--markdown-->

<!--more-->

## 算法介绍

### 可持久化线段树

**可持久化线段树**，也被称为**主席树**和**函数式线段树**。和字面意思一样，其指的是对一个线段树进行可持久化的维护。（**可持久化数据结构(Persisten data structure)**就是利用函数式编程的思想使其支持查询历史版本、同时充分利用它们之间的共同数据来减少时间和空间消耗）。

当我们想要对一个线段树进行可持久化的维护时，最简单的方式是将之前的线段树复制一份存起来，然后再对当前线段树进行更改。但是这样效率很低，并且会占用大量的内存。

由于我们每次操作只是对一个区间或者一个点进行了操作，所以我们每次操作所涉及的所有节点都会在根节点向下延伸的某一条链上。我们利用这个性质，每次更改后只新建发生了数据更改的链，其它的节点都指向原来的节点即可。

![主席树](https://oi-songer.github.io/In%20Blog/%E4%B8%BB%E5%B8%AD%E6%A0%91.jpg)

此时，当我们想要查询某个时间节点的线段树时，只需要找对应的根节点向下查找即可。

### 权值线段树

在说到主席树之前，我们需要提一下**权值线段树**。权值线段树存储的并非仅仅是元素，还有元素出现的次数，以及该区间所有元素出现的次数。其可以很方便的实现$n$个数的第$k$大的查询，只需要判断$k$和$son[L].size + 1$即可，若$k$更小则其在左子树，否则在右子树。

~~这不就是一个不平衡的平衡树吗！~~

确实很类似。不过平衡树由于旋转操作，所以并不能做持久化维护，所以只能使用这种方式。权值线段树与平衡树的不同主要在于其只有叶子节点才存储数值，而非所有节点都代表一个元素。

### 主席树

那么，讲完了权值线段树，我们就回到**主席树**上来。在很多时候，我们可能需要查询某个区间`[l..r]`的第$k$小。前面我们已经知道了如何使用可持久化的线段树，那么我们很容一边可以知道如何查询`[1..r]`的第$k$小：从第`r`个根节点开始向下查询即可。但是，我们如何去查询`[l..r]`的呢？

我们仔细地研究一下可以发现，可持久化线段树其实是前缀和的格式。我们可以通过第`r`个线段树减去第`l-1`个线段树来得到`[l..r]`的线段树。但是很明显这个操作的时间开销是巨大的。我们的删除操作明显是$O(n\log n)$的。

实际上，我们可以通过动态的查询来实现同样的效果。我们可以在`Query()`函数中同时传入两个`Node`，分别是位于`l-1`和`r`位置的根节点。当我们每次查询时,我们的`son[L].size()`可以通过`node[r].son[L].size() - node[l-1].son[L].size()`获得，然后通过该值判断应该查询左子树还是右子树，然后递归查询即可。

### 一点优化

在实际的题目中，我们可能经常遇到$n \leq 10^5$然而$-10^9 \leq a_i \leq 10^9$的情况。假设我们采取普通的方案，那么我们需要的空间即为$\log 10^9 \times 10^5 \times sizeof(Node)$。但是这样的空间需求约为$200$M，然而对于比如下面的"POJ 2104"来说，空间开销还是过大了。此时我们可以对$a_i$排序，然后将其排序后的下标当作其Hash值存到主席树中，这样的话我们的空间即为$\log 10^5 \times 10^5 \times sizeof(Node)$。

## 详细代码

在讨论详细的实现代码之前，我们要先写出对应的存储结构：

```C++
#define L 0
#define R 1

struct Node
{
    int id, cnt;
    int l, r;
    int son[2];

    void pushDown();
    Node *insert(const int);
    Node *query();
};

struct ChairmanTree
{
    Node *root[MAXN];

    void build(int);

    int query(Node *, Node *, int);
    int query(int, int, int)
};
```

此外，还有一个会被下方的函数调用的`pushDown()`函数:

```C++
void pushDown()
{
    int mid = (l + r) / 2;
    if (!son[L])
        son[L] = new Node(l, mid);
    else
        son[R] = new Node(mid + 1, r);
}
```

由于要考虑对新节点的引入，所以`Insert()`较为关键：

```C++
Node *insert(const int num)
{
    //如果不是要插入的节点
    if (num < l || num > r)
        return this;

    //如果已经到了num
    if (l==r)
        return new Node(l, r, this->cnt + 1);

    //创建子节点
    this->pushDown();

    int mid = (l + r) / 2;
    if (num <= mid)
        return new Node(l, r, this->cnt + 1, son[L]->insert(num), son[R]);
    else
        return new Node(l, r, this->cnt + 1, son[L], son[R]->insert(num));
}
```

此外，比较特殊的即为主席树中的查询函数`query()`:

```C++
int query(Node *x, Node *y, int k)
{
    if (x->l == x->r)
        return x->id;

    //pushDown(), 避免其没有子节点
    x->pushDown();
    y->pushDown();

    //对其左子树求差，算出实际[l..r]区间内的左子树的元素个数
    int t = y->son[L]->cnt - x->son[L]->cnt;

    if (k <= t)
        return query(x->son[L], y->son[L], k);
    else
        return query(x->son[R], y->son[R], k - t);
}

int query(int l, int r, int k)
{
    return query(root[l-1], root[r], k);
}
```

## 例题

### POJ 2104

题目来源: [_POJ_](http://poj.org/problem?id=2104)

```C++
#include <cstdio>
#include <algorithm>
#include <new>

#define L 0
#define R 1
#define MAXN 100100
#define INF 1000000000

using namespace std;

template <size_t SIZE>
struct MemoryPool
{
    char buf[SIZE], *cur;

    MemoryPool() : cur(buf) {}

    void *malloc(int size)
    {
        if (size + cur > buf + SIZE)
            return malloc(size);

        char *p = cur;
        cur += size;
        return (void *)p;
    }
};

MemoryPool<MAXN * 18 * 32> pool;

struct Node
{
    int l, r;
    int cnt;
    Node *son[2];

    Node(int l, int r, int cnt = 0, Node *sonl = NULL, Node *sonr = NULL)
        : l(l), r(r), cnt(cnt)
    {
        son[L] = sonl;
        son[R] = sonr;
    }

    void pushDown()
    {
        int mid = l + (r - l) / 2; //这里必须这样写，防止(l+r)为负数导致除以2后并非我们要的数字

        if (!son[L])
            son[L] = new (pool.malloc(sizeof(Node))) Node(l, mid);
        if (!son[R])
            son[R] = new (pool.malloc(sizeof(Node))) Node(mid + 1, r);
    }

    Node *insert(const int num)
    {
        if (num < l || num > r)
            return this;

        if (l == r)
            return new (pool.malloc(sizeof(Node))) Node(l, r, this->cnt + 1);

        this->pushDown();

        const int mid = l + (r - l) / 2;
        if (num <= mid)
            return new (pool.malloc(sizeof(Node))) Node(l, r, this->cnt + 1, son[L]->insert(num), son[R]);
        else
            return new (pool.malloc(sizeof(Node))) Node(l, r, this->cnt + 1, son[L], son[R]->insert(num));
    }
};

struct ChairmanTree
{
    Node *root[MAXN];

    void build(int *a, int n)
    {
        root[0] = new (pool.malloc(sizeof(Node))) Node(1, n);
        for (int i = 1; i <= n; i++)
            root[i] = root[i - 1]->insert(a[i]);
    }

    Node *query(Node *x, Node *y, int k)
    {
        if (x->l == x->r)
            return x;

        x->pushDown();
        y->pushDown();

        int t = y->son[L]->cnt - x->son[L]->cnt;

        if (k <= t)
            return query(x->son[L], y->son[L], k);
        else
            return query(x->son[R], y->son[R], k - t);
    }

    int query(int l, int r, int k)
    {
        return query(root[l - 1], root[r], k)->l;
    }
} tree;

struct Set
{
    int val, id;

    const bool operator<(const Set &tmp) const
    {
        return this->val < tmp.val;
    }
} set[MAXN];

int a[MAXN];
int main()
{
    int n, m;
    scanf("%d%d", &n, &m);

    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &set[i].val);
        set[i].id = i;
    }

    sort(set + 1, set + 1 + n);
    for (int i = 1; i <= n; i++)
        a[set[i].id] = i;

    tree.build(a, n);

    for (int cas = 1; cas <= m; cas++)
    {
        int x, y, z;
        scanf("%d%d%d", &x, &y, &z);
        printf("%d\n", set[tree.query(x, y, z)]);
    }
}
```01postpublish0111049aeca71e896418aac6f3a293f5da986{"cid":3,"title":22,"slug":3,"created":10,"modified":10,"text":2730,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}380大二下第十五周 38015600924601560092591<!--markdown-->## 2019 6 9 周日

<!--more-->

距离上一次的“日记”已经过去了半年，最近几天又突然有了写一篇的念头。毕竟半年过去了，多少有些能记一下的东西。

这半年过得其实有些庸碌，刷题量明显变少，实验室也终于不去了（虽然我去也没有事情），博客的更新频率也大不如前。所以说，这半年算是“庸碌”的半年。不过，妄想用一个词就概括进两百天明显也是有失偏颇的。

说到博客，最近GFW明显变高，导致我的博客和ss都被墙掉了，所以想要更新就显得更加麻烦。我尝试新开了几个不同地区的VPS，结果都是过了几天就被封掉了。今天我又开了一个阿姆斯特丹的VPS搭了一个openVPN，不知道究竟能不能用到明天（苦笑。

虽说在ACM上算是几乎“毫无进展”，不过最近找到了一本好书。加缪的《堕落(The fall)》，虽然汉译本的翻译略显晦涩，但是加缪所描述的律师突然让我有些共鸣。或许有时间我会专门记一下吧。

另外，最近我刚刚换了一个手机，魅族16th，感觉还行，不过使用白条买的，到现在还没有还清。

不过，我感觉我这半年间，却又越来越有了一种“自以为高雅”的感觉。我自以为高尚，看到低俗的信息就看到厌恶、与不屑。B站我也不太想看了，只是偶尔看看新闻。我尽可能的想要“理性客观”，想要把自己从主观与情绪中剖离出去。不过，这是好是坏呢？

虽说日记本就应该是记一些琐碎事。但是我在之前的几篇日记中频频给自己打鸡血，感觉有些偏离本意。虽说如此，我最近确实算是有些颓废。没有目标，整天有些得过且过。期末考试不会是目标，应付作业也不会是目标。我应该再去找一些“提升自我”的事情做，而不是空闲下来就去打打游戏、玩玩手机。

说起来，还有一件我非常想记下的事情。大概是几天前，其实不只是几天前，这已经是第二次了。我梦见我站在宿舍的阳台上，阳台外是碧蓝到发绿的大海。海上有山，有船，甚至有一个海上乐园。然后就发生了水灾。我看见人被冲来冲去，在水中挣扎，然后便轮到了我。

这突然让我想起了几天前，我看了一遍敦刻尔克。看着里面的士兵在被淹没的船舱里挣扎。我突然感到了科技战争的“冷酷”。即便是死亡，也不再是刀起刀落，而是淹没的船舱，是焚烧的坦克，是孤立无援的绝望。

说来说去，结果有说了一堆毫无头绪的东西。就到这为止吧。
01postprivate01110f23d3a2a0c8524c52a943b97e2b781f7{"cid":3,"title":26,"slug":3,"created":10,"modified":10,"text":5922,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}382[学习笔记]笛卡尔树38215664607401566460835<!--markdown-->> 不知不觉，这估计是自从我用这个博客以来“停更”最长的了。各种奇奇怪怪的原因综合在一起导致连续三个月没有写任何博客。其实过去半年感觉投入到ACM的时间就有点少。最近几天也是。话说笛卡尔树我从前一直没听说过（汗），最近比赛完后看题解才知道这玩意儿。。。

<!--more-->

## 介绍

**笛卡尔树**是一种特定**二叉树**数据结构，可由数列构造，在**范围最值查**、**范围top k查询（range top k queries）**等问题上有广泛应用。它具有堆的有序性，中序遍历可以输出原数列。笛卡尔树结构由Vuillmin(1980)在解决范围搜索的几何数据结构问题时提出。从数列中构造一棵笛卡尔树可以线性时间完成，需要采用基于栈的算法来找到在该数列中的所有最近小数。

于[_维基百科_](https://zh.wikipedia.org/wiki/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91)上的图例能很好地展现它的性质：

![笛卡尔树](https://oi-songer.github.io/In%20Blog/cartesian-tree-1.png)

## 实现细节

### 构造

我们固然可以通过一个个插入来构造笛卡尔树，虽然平均时间复杂度为$O(n \log n)$，但是在成链的条件下会退化为$O(n^2)$。而若我们使用单调栈，则可以直接实现$O(n)$的时间复杂度。

使用单调栈构造的主要思路是：维护一个存储了**从根节点一直走右儿子到当前插入节点的所有节点**的栈。比如当我们插入完了上图中的$10$时，单调栈存储的便为$[1, 8, 10]$（此时$8$还是$1$的右儿子）。我们令栈顶的值为`now`，然后我们尝试取插入下一个数`next`。此时有如下三种情况：

1. $next > now$: 此时我们直接令`next`为`now`的右儿子，并且令`now`原来的右儿子为`next`的左儿子；
2. $next < now$: 将栈顶取出，然后再令当前栈的栈顶为`now`；
3. 栈为空：令当前根节点的父亲指向`next`，并将`next`设为根节点。

代码实现如下：
```C++
stack<Node*> s;
struct CartesianTree
{
    Node *root;

    CartesianTree(int *a, int n)
    {
        s = stack<Node *>();

        for (int i = 0; i<n; i++)
        {
            Node *next = new Node(a[i]);
            Node *last = NULL;
            while (!s.empty())
            {
                if (s.top()->val < next->val)
                {
                    Node *tmp = s.top();

                    if (tmp->son[R])
                        tmp->son[R]->fa = next;
                    next->son[L] = tmp->son[R];

                    tmp->son[R] = next;
                    next->fa = tmp;

                    break;
                }

                last = s.top();
                s.pop();
            }

            if (s.empty() && last)
            {
                next->son[L] = last;
                last->fa = next;
            }

            s.push(next);
        }

        while (!s.empty())
        {
            root = s.top();
            s.pop();
        }
    }
};
```

## 例题

### hdu 1506

题目来源：[_hdu_](http://acm.hdu.edu.cn/showproblem.php?pid=1506)

#### 分析

题目给定了长度为$10^5$的`h[]`。要求求出最大的矩形。

我们可以构造一个笛卡尔树。由于笛卡尔树的性质可得，一个节点的子节点一定都大于该节点并且与它相邻。所以对于每个节点，高度为该子节点高度的最大矩形的面积便为$size \times height$。取所有节点的$max$即可。

#### 代码

```C++
#include <iostream>
#include <algorithm>
#include <stack>

#define L 0
#define R 1
#define MAXN 100100

using namespace std;

struct Node
{
    int height;
    int size;
    Node *fa;
    Node *son[2];

    Node(int height = 0)
    {
        this->height = height;
        size = 1;
        fa = NULL;
        son[0] = son[1] = NULL;
    }
};
int cnt;

stack<Node*> s;
struct CartesianTree
{
    Node *root;

    CartesianTree(int *a, int n)
    {
        s = stack<Node *>();

        for (int i = 0; i<n; i++)
        {
            Node *next = new Node(a[i]);
            Node *last = NULL;
            while (!s.empty())
            {
                if (s.top()->height < next->height)
                {
                    Node *tmp = s.top();

                    if (tmp->son[R])
                        tmp->son[R]->fa = next;
                    next->son[L] = tmp->son[R];

                    tmp->son[R] = next;
                    next->fa = tmp;

                    break;
                }

                last = s.top();
                s.pop();
            }

            if (s.empty() && last)
            {
                next->son[L] = last;
                last->fa = next;
            }

            s.push(next);
        }

        while (!s.empty())
        {
            root = s.top();
            s.pop();
        }
    }

    long long run(Node *node = NULL)
    {  
        if (node==NULL)
            node = root;

        long long ans = 0;

        if (node->son[L])
        {
            ans = max(ans, run(node->son[L]));
            node->size += node->son[L]->size;
        }
        if (node->son[R])
        {
            ans = max(ans, run(node->son[R]));
            node->size += node->son[R]->size;
        }

        ans = max(ans, (long long)node->height * (long long)node->size);

        return ans;
    }
};


int h[MAXN];
int main()
{
    ios::sync_with_stdio(false);

    int n;
    cin >> n;

    while (n)
    {
        for (int i = 0; i < n; i++)
            cin >> h[i];

        CartesianTree *ct = new CartesianTree(h, n);

        cout << ct->run() << endl;

        cin >> n;
    }
}

```
01postpublish011105ffc092bf9b660435044a565b60e0da3{"cid":3,"title":34,"slug":3,"created":10,"modified":10,"text":3273,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}384Equivalent Prefixes [笛卡尔树]38415665683801566568871<!--markdown-->## 2019牛客多校 第一场 A

<!--more-->

题目来源：[_Nowcoder_](https://ac.nowcoder.com/acm/contest/881/A)

## 分析

题目给定了`a[]`,`b[]`，要求找出最大的$p \leq n$满足$[a_1, a_2, ... , a_p]$和$[b_1, b_2, ... ,b_p]$是“相等”的。相等在这个题目中的定义为：对于长度都为`n`的序列`u[]`和`v[]`，任意的$1 \leq 1 \leq l \leq r \leq n$都能使$RMQ(u, l, r) = RMQ(v, l, r)$。$RMQ()$即为区间最小值的下标。

我们先来研究如何判断两个序列是“相等”的。很明显，由于对于任意的$l$和$r$，$RMQ(l,r)$都相同，那么这两个序列中每个数的相对顺序都是一样的。其实，这也就代表着，这两个序列构造出的[_笛卡尔树_](http://songer.xyz/index.php/archives/382/)的结构是相同的。

但是，答案要求的是“最小的满足条件的$p$”。如果我们每次都对笛卡尔树的结构做一次比较的话，由于每次要比较所有的点，所以时间为$O(n^2)$，肯定超时了。那么，还有什么能够让我们确定这两个笛卡尔树相同呢？笛卡尔树构造中的单调栈。单调栈能够唯一地反映当前插入的点的位置，只要每次的单调栈相同，那么生成的笛卡尔树一定相同。而且实际上，由于单调栈的长度变化能唯一的反映出插入点位置的变化，所以只需要每次比较单调栈的长度即可。

## 代码

```C++
#include <iostream>
#include <algorithm>
#include <stack>

#define L 0
#define R 1
#define MAXN 100100

using namespace std;

struct Node
{
    int val;
    Node *fa;
    Node *son[2];

    Node(int val = 0)
    {
        this->val = val;
        fa = NULL;
        son[L] = NULL;
        son[R] = NULL;
    }
};

struct CartesianTree
{
    stack<Node *> s;
    Node *root;

    CartesianTree()
    {
        root = NULL;
        s = stack<Node *>();
    }

    void insert(int a)
    {
        Node *next = new Node(a);
        Node *last = NULL;

        while (!s.empty())
        {
            if (s.top()->val < next->val)
            {
                Node *tmp = s.top();
                if (tmp->son[R])
                    tmp->son[R]->fa = next;
                next->son[L] = tmp->son[R];
                tmp->son[R] = next;
                next->fa = tmp;
                break;
            }
            last = s.top();
            s.pop();
        }

        if (s.empty() && last)
        {
            next->son[L] = last;
            last->fa = next;

            if (last==root)
                root = next;
        }
        if (root==NULL)
            root = next;

        s.push(next);
    }
};

int a[MAXN], b[MAXN];

int main()
{
    ios::sync_with_stdio(false);

    int n;

    while (cin>>n)
    {
        for (int i = 0; i<n; i++)
            cin >> a[i];
        for (int i = 0; i<n; i++)
            cin >> b[i];

        CartesianTree x, y;

        int i;
        for (i = 0; i<n; i++)
        {
            x.insert(a[i]);
            y.insert(b[i]);

            if (x.s.size() != y.s.size())
                break;
        }

        cout << i << endl;
    }
}
```
01postpublish0111089efd04135f6007236b421e583243337{"cid":3,"title":9,"slug":3,"created":10,"modified":10,"text":1705,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}386ABBA [DP]38615666216451566621645<!--markdown-->
## 2019牛客多校 第一场 E

<!--more-->

题目来源：[_Nowcoder_](https://ac.nowcoder.com/acm/contest/881/E)

## 分析

我们可以把这个题目看作一个已经拥有$n$个`AB`和$m$个`BA`，把它放入一个数组的过程。那么，题目即为要求有多少种放法。

这个题目的主要限制在于`AB`中的`A`一定先于`B`放入，`BA`同理。那么，我们可以发现，已放置的`A`和`B`的放置顺序对答案没有影响。即，只有“是否已放置”有影响，“放置在哪里”没有影响。那么，很明显，这道题便是一个DP了。我们使用`dp[i][j]`记录答案，其中`i`是放置了多少个`A`，`j`是放置对了多少个`B`。那么，很明显，我们需要满足以下两个条件：

1. $i \leq n + j$;
2. $j \leq m + i$.

在以上两个条件下进行状态转移即可。

## 代码

```C++
#include <iostream>
#include <algorithm>

#define MAXN 1010
#define MOD 1000000007

using namespace std;

long long dp[2 * MAXN][2 * MAXN];

int main()
{
    int n, m;
    
    while (cin >> n >> m)
    {
        for (int i = 0; i<=n+m; i++)
            for (int j = 0; j<=n+m; j++)
                dp[i][j] = 0;

        dp[0][0] = 1;
        for (int i = 0; i<=n + m; i++)
            for (int j = 0; j<=m + n; j++)
            {
                if (i < n + j)
                    dp[i+1][j] = (dp[i+1][j] + dp[i][j]) % MOD;
                if (j < m + i)
                    dp[i][j+1] = (dp[i][j+1] + dp[i][j]) % MOD;

                // cout << i << " " << j << " " << dp[i][j] << endl;
            }   

        cout << dp[n+m][n+m] << endl;
    }
}
```01postpublish0111029a7437aef0468c65414c724f0532cdc{"cid":3,"title":20,"slug":3,"created":10,"modified":10,"text":2035,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}388Integration [数学]38815666561601566699165<!--markdown-->## 2019牛客 第一场 B

<!--more-->

题目来源：[_Nowcoder_](https://ac.nowcoder.com/acm/contest/881/B)

## 分析

这道题就是一道纯粹的数学题。。题目要求计算如下公式：

~ \\frac{1}{\\pi} \\int_0^{\\infty} \\frac{1}{\\prod_{i=1}^n (a_i^2 + x^2)} dx ~

首先，我们先假设一个变量：

~ c_i = \\frac{1}{\\prod_{j \\neq i}(a_j^2 - a_i^2)}~

那么，其实第一个公式便可以进行如下的化简：(由于多行LaTeX支持较差，故放图片)

![Nowcoder-1-B-1](https://oi-songer.github.io/In%20Blog/Nowcoder-1-B-1.png)

### 实现细节

这道题主要由两个细节问题：

1. 不能频繁的进行取乘法逆元操作，否则会超时。应先乘在一起，然后再求逆元。
2. 注意$a_j^2 - a_i^2$可能为负数。

## 代码

```C++
#include <iostream>

#define MAXN 1010
#define MOD 1000000007

using namespace std;

long long pow(long long x, long long n, long long mod)
{
    long long ret = 1;
    long long t = x % mod;

    while (n)
    {
        if (n & 1)
            ret = ret * t % mod;

        n /= 2;
        t = t * t % mod;
    }

    return ret;
}

long long reverse(long long x, long long mod)
{
    return pow(x, mod - 2, mod);
}

long long a[MAXN];

int main()
{
    ios::sync_with_stdio(false);

    int n;
    while (cin >> n)
    {
        for (int i = 1; i<=n; i++)
            cin >> a[i];

        long long ans = 0;
        for (int i = 1; i<=n; i++)
        {
            long long tmp = 1;
            for (int j = 1; j<=n; j++)
                if (i!=j)
                {
                    long long m = a[j] * a[j] - a[i] * a[i];
                    m %= MOD;
                    if (m<0)
                        m += MOD;
                    tmp = tmp * m % MOD;
                }

            tmp = tmp * 2 * a[i] % MOD;

            ans = (ans + reverse(tmp, MOD)) % MOD;
        }

        cout << ans << endl;
    }
}
```
01postpublish00000fdd16998249de4f72cf50bf1d35e6a8b{"cid":3,"title":29,"slug":3,"created":10,"modified":10,"text":1783,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}394Remainder Problem [思维题]39415667118401566711938<!--markdown-->## CF Edu 71 F

<!--more-->

题目来源：[_Codeforces_](https://codeforces.com/contest/1207/problem/F)

## 分析

题目给了长度为$5 \times 10^5$的全$0$数组，然后给出了两种操作：

1. `1 x y`: 令$a_x$加$y$；
2. `2 x y`: 求下标$i$满足$i \equiv y (\mod x)$的$a_i$的和。

假如我们直接维护一个$a_i$数组，那么如果我们暴力进行操作$2$的话，时间复杂度显然是$O\left(\frac{x}{x} \right)$的。当$x^2>N$时，该操作是$O(n^{\frac{1}{2}})$的。但是，当$x$较小时呢？我们可以直接维护一个$ans[x][y]$数组，在每次进行操作$1$时，对所有影响的数组进行更新即可。因为$x^2 \leq N$，所以插入操作也是$O(n^{\frac{1}{2}})$的。所以，我们最后得到了一个$O(q \sqrt{n})$的算法。

而实际上，由于大部分$x$都是不等于$\sqrt(n)$的，所以实际的时间要比$O(q \sqrt{n})$要小，所以可以通过该题。

## 代码

```C++
#include <iostream>
#include <algorithm>

#define MAXN 500000
#define K 750

using namespace std;

int a[MAXN + 1];
long long ans[K+1][K];

int main()
{
    int q;
    cin >> q;

    for (int i = 1; i<=q; i++)
    {
        int op, x, y;
        cin >> op;
        cin >> x >> y;

        if (op==1)
        {
            a[x] += y;
            for (int j = 1; j<=K; j++)
                ans[j][x % j] += y;
        }else
        {
            if (x>K)
            {
                long long tmp = 0;
                for (int j = y; j<=MAXN; j+=x)
                    tmp += a[j];
                cout << tmp << endl;
            }else
            {
                cout << ans[x][y] << endl;
            }
            
        }
    }
}
```
01postpublish01110e0d436b25bc8279d764d8c75da24ea1e{"cid":3,"title":24,"slug":3,"created":10,"modified":10,"text":2592,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}396最大全1子矩阵 [DP]39615668043711566804386<!--markdown-->## POJ 3494

<!--more-->

题目来源：[_POJ_](http://poj.org/problem?id=3494)

## 分析

这也算是一个十分经典的DP题了。给定一个01矩阵，要求求出最大的全1子矩阵。

首先，我们可以通过$O(n^2)$的预处理算出$h[i][j]$，代表的是$i,j$坐标的点
向上的连续`1`的数目。

然后，我们采用“悬线法”来计算答案。假如$l_i$是最靠左的令$h[x] \geq h[i], (l_i \leq x \leq i)$,$r_i$同理。那么$(r_i - l_i + 1) \times 1$就是高度为$h_i$且$i,j$在底边上的最大矩形。

那么，问题就在于如何求$l_i$和$r_i$了。如果我们暴力地去求，那么整个算法地时间复杂度就是$O(n^3)$，明显太慢。在这里，我们就要用DP的方法来实现了。

我们令所有的$j<i$,$l_j$都已经算出，那么，当$h_j < h_i$时，那么，我们可以保证$h_{l_j} < h_i$。然后，我们可以继续比较$h_{h_j - 1}$和$h_i$。这样，我们可以快速地算出$l_i$，$r_i$。

## 代码

```C++
#include <iostream>
#include <algorithm>
#include <cstdio>

#define MAXN 2010

using namespace std;

int a[MAXN][MAXN];
int h[MAXN][MAXN];
int l[MAXN], r[MAXN];

int getint()
{
    char c = getchar();

    while (c<'0' || c>'9')
        c = getchar();

    int ret = 0;
    while (c>='0' && c<='9')
        ret = ret * 10 + c - '0', c = getchar();

    return ret;
}

int main()
{
    // ios::sync_with_stdio(false);

    int n, m;
    while (~scanf("%d%d", &n, &m))
    {
        for (int i = 1; i<=n; i++)
            for (int j = 1; j<=m; j++)
                a[i][j] = getint();
                // scanf("%d",&a[i][j]);
                // cin >> a[i][j];

        for (int i = 1; i<=n; i++)
            for (int j = 1; j<=m; j++)
                if (a[i][j]==1)
                    h[i][j] = h[i-1][j] + 1;
                else
                    h[i][j] = 0;

        int ans = 0;
        for (int i = 1; i<=n; i++)
        {
            for (int j = 1; j<=m; j++)
            {
                l[j] = j;

                while ( l[j]>1 && h[i][ l[j] - 1 ] >= h[i][j])
                    l[j] = l[ l[j] - 1];

            }
            for (int j = m; j>=1; j--)
            {
                r[j] = j;

                while ( r[j]<m && h[i][ r[j] + 1 ] >= h[i][j])
                    r[j] = r[ r[j] + 1];

                ans = max(ans, (r[j] - l[j] + 1) * h[i][j] );
            }
        }

        printf("%d\n", ans);
        // cout << ans << endl;
    }
}
```01postpublish011100edf28a2574e34b9fdbfc2fe71a6eca8{"cid":3,"title":22,"slug":3,"created":10,"modified":10,"text":2997,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}402H-index [优先队列]40215821988001582198855<!--markdown-->## Kick Start 2019 H

> 最近有好久没有做过算法题了，而且博客更是很久没有更新过了。最近Google的Kick Start快要开始了。趁这个机会，刷一刷Kick Start的题，重新找一下做算法题时的思路。

<!--more-->

题目来源：[_Kick Start_](https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050edd/00000000001a274e)

## 分析

虽说这题是2019 H的第一题，然而我还是没能想到正确的做法用一个优先队列即可。题目给出了$10^5$的数据范围，虽说给了整整$50$s,但是$O(n^2)$的算法实际上还是不现实，所以我们仍要实现一个$O(n log n)$的算法。

简单地分析题目，首先可以得到一个较为显然的结论： **对于同一组数据的$n$个解，其一定是单调不下降的。** 因此，若我们维护一个值$ans$作为完成第$i$个paper时的解。那么，当$i++$时，我们我们需要做的便是将$ans++$，然后验证是否合法。若合法，则继续$ans++$，直到不合法为止。由于实际上每个$ans$只会加一次，因此不论验证步骤，该算法目前是$O(n)$的。也就是说，我们需要实现一个$O(log n)$的验证操作。

我们又可以发现，当写完第$i$个paper后，这$i$个paper中所有的citation小于$ans$的论文都对答案没有影响。也就是说，它们是“可抛弃的”。若当前确认$ans$合法，并且去验证$ans+1$是否合法，我们即可以将所有小于$ans + 1$的值抛弃，此时剩下的paper便是所有citation大于等于$ans + 1$的，若此时数目大于$ans + 1$，则说明$ans + 1$合法。实现时只需要使用一个优先队列（小根堆），然后维护当前大于等于$ans$的所有的数。若$ans$增加了，则将所有小于$ans$的值删掉，然后验证$ans$是否合法即可。最后由于所有的数只会入队和出队一次，且查询次数也为$O(n)$，所以最后该算法的时间复杂度为$O(n log n)$。

## 代码

```C++
#include <iostream>
#include <algorithm>
#include <queue>

#define MAXN 100100

using namespace std;

priority_queue<int, vector<int>, greater<int> > q;

int main()
{
    int T;
    cin >> T;

    for (int cas = 1; cas <= T; cas ++)
    {
        q = priority_queue<int, vector<int>, greater<int> >();

        int n;
        cin >> n;

        cout << "Case #" << cas << ":";

        int ans = 0;
        for (int i = 1; i<=n; i++)
        {
            int x;
            cin >> x;

            q.push(x);

            while (true)
            {
                while (q.size() && q.top() < (ans + 1))
                    q.pop();

                // cout << "! " << ans << " " << q.size() << endl;

                if (q.size() > ans)
                    ans ++;
                else
                    break;
            }

            cout << " " << ans;
        }

        cout << endl;
    }
}
```01postpublish0111091be6a117d1b80bcc8e0af247cc2c172{"cid":3,"title":27,"slug":3,"created":10,"modified":10,"text":3251,"order":1,"authorId":1,"template":null,"type":4,"status":7,"password":null,"commentsNum":1,"allowComment":1,"allowPing":1,"allowFeed":1,"parent":1}400Second Large Rectangle [DP]40015668262651566826265<!--markdown-->
## 2019牛客 第二场 H

<!--more-->

题目来源：[_Nowcoder_](https://ac.nowcoder.com/acm/contest/882/H)

## 分析

题目要求“次大全1子矩阵”。其实我们将最大全1子矩阵的代码略加改动便可得到答案。

由于我们之前算的是最大子矩阵，所以在代码里，我们每次根据$i, j$和$h_{i,j}$算出$l_{i,j}$,$r_{i,j}$时，都只用到了$h_{i,j} \times (r_{i,j} - l_{i,j} + 1)$这么一种情况去更新答案。也就是说，我们只考虑了最大的情况。那么，这次，我们只需要将$(h_{i,j} - 1) \times (r_{i,j} - l_{i,j} + 1)$和$h_{i,j} \times (r_{i,j} - l_{i,j})$考虑进去就行了。此时我们只需维护最大值和次大值两个值即可。

但是，还有一种特殊情况。当同一行几个相邻点$h_{i,j}$相同时，同一答案可能被计算多次。在计算最大子矩阵时不需要在乎此问题，但在这里就需要考虑了。我们可以发现，当几个点在同一行时，它们的$l_{i,j}$和$r_{i,j}$在一起能共同决定整个矩形。也就是说，我们只要将$(l_{i,j},r_{i,j})$扔到`set`里即可。当然，`set`只需判断在同一行的情况。

## 代码

```C++
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <set>

#define MAXN 1010

using namespace std;

int a[MAXN][MAXN];
int h[MAXN][MAXN];
int l[MAXN], r[MAXN];

set<pair<int, int>> s;

int main()
{
    int n, m;
    while (~scanf("%d%d", &n, &m))
    {
        for (int i = 1; i<=n; i++)
        {
            getchar();
            for (int j = 1; j<=m; j++)
                a[i][j] = getchar() - '0';
        }

        for (int i = 1; i<=n; i++)
            for (int j = 1; j<=m; j++)
                if (a[i][j]==1)
                    h[i][j] = h[i-1][j] + 1;
                else
                    h[i][j] = 0;

        int ans = 0, maxn = 0;
        for (int i = 1; i<=n; i++)
        {
            s.clear();

            for (int j = 1; j<=m; j++)
            {
                l[j] = j;

                while ( l[j]>1 && h[i][ l[j] - 1 ] >= h[i][j])
                    l[j] = l[ l[j] - 1];
            }

            for (int j = m; j>=1; j--)
            {
                r[j] = j;

                while ( r[j]<m && h[i][ r[j] + 1 ] >= h[i][j])
                    r[j] = r[ r[j] + 1];

                // cout << l[j] << " " << r[j] << " " << h[i][j] << endl;

                if (s.find(pair<int, int>(l[j], r[j])) == s.end())
                {
                    s.insert(pair<int, int>(l[j], r[j]));

                    int m = (r[j] - l[j] + 1) * h[i][j];

                    if (m > maxn)
                    {
                        ans = maxn;
                        maxn = m;

                        if (m - h[i][j] > ans)
                            ans = m - h[i][j];
                        if (m - (r[j] - l[j] + 1) > ans)
                            ans = m - (r[j] - l[j] + 1);

                    }else if (m > ans)
                        ans = m;
                }
                
            }
        }

        printf("%d\n", ans);
        // cout << ans << endl;
    }
}
```