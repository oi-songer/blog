---
title:Balance[DP]
date:2018-08-24 15:37:24
tags:
---

# Balance[DP]

# POJ 1837

<!--more-->

题目来源: [_POJ_](http://poj.org/problem?id=1837)

## 分析

题目给出了`C`个"hook",要求将`G`个砝码挂在这些"hook"上，使得最后整个杠杆是平衡的。砝码必须被全部使用，但是"hook"不一定要全部挂有砝码。因为题目给出的数据范围较小，$2 \leq C \leq 20 $,$2 \leq G \leq 20$, "hook"的坐标为$[-15,15]$。并且很明显，这个问题也是一个多段决策问题: `G`个砝码时的答案可以由`G-1`个时推理而来，并且也满足最优子结构和无后效性。所以我们使用动态规划来解决此问题。

那么我们首先就需要来确定DP方程。我们最终需要的答案是方案数, 而影响方案数的变量为砝码数量，平衡点位置。也就是说，我们可以建立一个二维的DP方程。`f[][]`,一维存放砝码数量，一位存放平衡点的位置。在这里，平衡位置指的是$\sum_{(i,j)} w_i \times h_j$,而不是物理上实际的平衡位置。

然后我们便需要确立转移方程。这个是较为显然的，当前砝码数的方案数等于其减去上一个砝码在不同"hook"上的情况的方案数的和(下面`w[]`表示砝码重量，`h[]`表示"hook"位置):

$$ f_{i,j} = \sum_{k=1}^C f_{i-1,j-(w_{i-1}\times h_k)} $$

然后注意因为平衡位置`j`可能为负数，所以加上一个基数即可。

## 代码

```C++
#include <iostream>

using namespace std;

int f[22][2010];
int h[22], a[22];

int main()
{
	int c,g;
	cin >> c >> g;

	for (int i = 0; i<c; i++)
		cin >> h[i];

	for (int i = 1; i<=g; i++)
		cin >> a[i];

	f[0][1000] = 1;
	for (int i = 1; i<=g; i++)
		for (int j = -1000; j<=1000; j++)
			for (int k = 0; k<c; k++)
			{
				if (j-h[k]*a[i]>=-1000 && j-h[k]*a[i]<=1000)
					f[i][j+1000] += f[i-1][j-h[k]*a[i]+1000];
				//if (f[i][j+1000]>0)
				//	cout << i << " " << j << " " << f[i][j+1000] << endl;
			}

	cout << f[g][1000] << endl;
}
```