---
title: "[学习笔记]后缀自动机"
tags: 
---

# [学习笔记]后缀自动机

> 通过阅读[_OI wiki_](https://oi-wiki.org/string/sam/#_8)，终于大致理解了什么是后缀自动机。这篇博客主要是从个人的角度简单地梳理以下，若想系统地学习，还是推荐上面提到的链接，或直接观看原文章的[_英译版_](https://cp-algorithms.com/string/suffix-automaton.html)或[_俄文原版_](http://e-maxx.ru/algo/suffix_automata)。

<!--more-->

<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=3 orderedList=false} -->

<!-- code_chunk_output -->

- [介绍](#介绍)
- [定义](#定义)
  - [状态](#状态)
  - [`endpos()`](#endpos)
  - [`link`](#link)
- [实现](#实现)
- [应用](#应用)
  - [检查字符串是否出现](#检查字符串是否出现)
  - [计算不同子串的个数](#计算不同子串的个数)
  - [计算不同子串的总长度](#计算不同子串的总长度)
  - [寻找字典序第$k$大子串](#寻找字典序第k大子串)
  - [最小循环移位](#最小循环移位)
  - [子串出现次数](#子串出现次数)
  - [子串第一次出现的位置](#子串第一次出现的位置)
  - [子串的所有出现位置](#子串的所有出现位置)
- [例题](#例题)

<!-- /code_chunk_output -->

## 介绍

**后缀自动机 (suffix automaton, SAM)** 是一个能解决许多字符串相关问题的有力的数据结构。其本质上是一个**DFA(确定性有限自动机或确定性有限状态自动机)**，并且压缩存储了字符串`s`的所有子串。其可以保证$O(n)$的构造时间复杂度和$O(n |\Sigma|)$的空间复杂度，其中$\Sigma$为字符集，或者用`map`实现，变为$O(n \log |\Sigma|)$时间复杂度和$O(n \log |\Sigma|)$的空间复杂度。此外，SAM可以保证最多有$2n - 1$个节点和$3n - 4$个转移边。

## 定义

由于SAM是一个DFA，所以它实际上为一个有向无环图。我们可以将图中的结点称为**状态**，边称为**转移**。

在每一条边上，都会标记有一个字符，而一条路径就可以根据边上的字符构成一个字符串。

在用字符串`s`构造的SAM中，会有一个唯一的**初始状态**$t_0$。此外，还会有一个或多个**终止状态**。对于任意从起始状态到任意一个终止状态的路径，都构成了一个`s`的子串。

由于从起点到某一个终点的路径可能存在多条，所以我们可以用这个终点表示这些路径代表的子串的集合。也就是说，一个状态可以代表一些子串的集合。

此外，我们还有几个概念需要介绍一下：

### 状态

如之前所说，状态表示的是DFA图中的一个结点，并且也能代表从起点到当前点的路径代表的子串的集合。它本身会一般有以下几个属性：

- `next[]`: 表示由它指向其它结点的转移。下标一般为字符集，存储的是指向的结点。
- `len`: 表示从起点到当前状态的长度。
- `link`: 于下方阐述。

在引入`link`之前，我们需要先引入`endpos()`的概念。

### `endpos()`

对于一个在字符串`s`中出现的子串`x`，我们称`x`在`s`中所有出现的位置为${p_i}$。那么，$endpos(x)$即为${p_i + len(x)}$，即`x`的所有最后一个字符出现的位置。很明显，不同的子串的$endpos$可能是相同的，我们令$endpos$相同的子串构成的集合称为 **$endpos$的等价类** 。那么，我们可以得到以下几个定理（不再证明，可以去[_OI wiki_](https://oi-wiki.org/string/sam/#_8)查看证明）： 

1. 两个非空子串$u$和$v$（假设$|u| \leq |v|$）的$endpos$相同，当且仅当字符串$u$是$v$的后缀。
2. 考虑两个非空子串$u$和$v$（假设$|u| \leq |v|$）。那么要么$endpos(u) \cap endpos(v) = \varnothing$，要么$endpos(v) \subseteq endpos(u) $，取决于$u$是否是$v$的一个后缀: $$ \left\{\begin{aligned} & endpos(v) \subseteq endpos(u) \ && \text{if}\ u\ \text{is suffix of}\ w \\ & endpos(v) \cap endpos(u) = \varnothing \ && \text{otherwise} \end{aligned} \right.  $$
3. 虑一个$endpos$等价类，将类中的所有子串按长度非递增的顺序排序。每个子串都不会比它前一个子串长，与此同时每个子串也是它前一个子串的后缀。换句话说，对于同一等价类的任一两子串，较短者为较长者的后缀，且该等价类中的子串长度恰好覆盖整个区间$[x,y]$。

我们之前提到了，我们可以$endpos()$相同的子串构成的集合称为$endpos()$的等价类。由于`endpos()`指的是终止的位置，那么，反过来说，我们可以通过一个点唯一的决定对应于这个点的等价类。也就是说，自动机中的结点和$endpos()$的等价类是一一对应的。

理解了以上性质以后，我们再回来看`link`。

### `link`

由前面可知，后缀自动机是一个DFA。我们令$v$为DFA里的一个状态，那么它能够对应一个$endpos$等价类，我们假设为$a$。我们令这个等价类中最长的字符串为$w$。有上面的定理我们可以得知，$endpos$中剩下的字符串一定是$w$的后缀。

但是，$w$的后缀却不一定都在$w$所在的等价类$a$中。那么，我们此时就能找到最长的不属于等价类$a$的字符串$x$。很明显，$x$也会对应一个等价类$b$，并且唯一的对应DFA中的状态$u$。那么，此时我们令$link(v) = u$。

也就是说，$link$指向的是对应于该状态$v$的$endpos$等价类中最长字符串（其实任一个都可以）的最长的不属于该$endpos$等价类的字符串对应的$endpos$等价类对应的状态$u$。（总算说完了，喘口气 (′д｀σ)σ

> 以上如果难以理解的话，还是建议上[_OI wiki_](https://oi-wiki.org/string/sam/#_8)看一下，或者翻阅其它博客。毕竟我感觉自己说的也不是很明白。(逃

## 实现

说了这么多，其实后缀自动机的实现是没有很复杂的。相较于它奇妙的思想和广泛的用途，代码可以算是十分简短了。当然，直接暴力的构造肯定也是不行的，所以我们还是需要用到一些技巧。

在构造之前，我们需要先定义一下存储结构，我们用结构体`State`来存储状态，代码如下：

```C++
struct State
{
    int len, link;
    int next[26];

    State()
    {
        for (int i = 0; i<26; i++)
            next[i] = 0;
    }
};
```

这里是假设字符集$\Sigma$为小写字母的情况。如果字符集较大，可以使用`map<>`来替换以节省空间，会将时间复杂度提升一个$\log |\Sigma|$。

然后是结构体`SAM`，提供了后缀自动机的基础操作：

```C++
struct SAM
{
    State state[2 * MAXN];
    int size, last;

    SAM()
    {
        state[0].len = 0;
        state[0].link = -1;

        size = 1;
        last = 0;
    }

    void extend(char c);
};
```

其中，`size`指的是整个`SAM`的大小，`last`是上一个插入的状态的下标，而`SAM.extend(char c)`便是后缀自动机的构造函数。其构造过程可以大致描述如下：

1. 首先，假设我们要插入的是字符$c$。此时，我们创建新的状态$cur$，并令$cur.len = last.len + 1$。
2. 对于状态$last$，我们看这个状态有无经过字符$c$的转移。
   2.1. 如果没有经过字符$c$的转移，我们就对状态$last$添加一个经过字符$c$的转移指向状态$cur$，并令状态$last = last.link$，重复步骤2。
   2.2. 如果没有，我们就标记当前的状态为$p$。 
3. 如果没有找到状态$p$，那么我们就令$cur.link = 0$，并跳到步骤5。
4. 否则，我们令$p.next[c]$指向的状态为状态$q$。并且，判断$p.len + 1$和$q.len$的关系：
   4.1. 如果$p.len + 1 = q.len$，我们令$cur.link = q$即可。
   4.2. 否则，我们需要复制状态$q$：我们创建一个新的状态$clone$，复制$q$的除了$len$以外的所有信息，并令所有指向状态$q$的$next$重新指向$clone$。然后，令$clone.len = p.len + 1$。复制之后，我们令$cur.link = clone$，$q.link = clone$。
5. 令$last = cur$。

该算法的正确性证明较为复杂，不再证明。我们下面直接贴上代码：

```C++
void extend(char c)
{
    int cur = size ++ ;
    state[cur] = State();
    state[cur].len = state[last].len + 1;

    int p = last;
    while (p!=-1 && !state[p].next[c - 'a'])
    {
        state[p].next[c - 'a'] = cur;
        p = state[p].link;
    }

    if (p==-1)
        state[cur].link = 0;
    else
    {
        int q = state[p].next[c - 'a'];
        if (state[p].len + 1 == state[q].len)
            state[cur].link = q;
        else
        {
            int clone = size ++;
            state[clone].len = state[p].len + 1;
            state[clone].link = state[q].link;

            for (int i = 0; i<26; i++)
                state[clone].next[i] = state[q].next[i];

            while (p!=-1 && state[p].next[c - 'a'] == q)
            {
                state[p].next[c - 'a'] = clone;
                p = state[p].link;
            }
            state[q].link = state[cur].link = clone;
        }
    }
    
    last = cur;
}
```

## 应用

后缀数组的构造十分巧妙，而其应用也十分丰富。在这里，我们列出几个较为典型的用法。

### 检查字符串是否出现

假设我们要计算字符串$t$是否在$S$中出现。因为我们构造的是后缀自动机，所以我们能够从起点$t_0$遍历出任意后缀子串，而任一子串一定是其中某个后缀子串的前缀。所以说，我们只需要从起点$t_0$按照字符串$t$的字符向下转移即可。只要能转移完，则说明字符串$t$是字符串$S$的子串，否则不是。

### 计算不同子串的个数

我们已经知道，从起点$t_0$出发的路径对应于字符串$S$的所有子串。也就是说，不同子串的个数，其实等价于自动机中从$t_0$出发的不同路径的条数。

#### 方法1（DP）

因为SAM是一个DAG，所以，我们可以通过DP的方式进行计算。转移方程如下：

$$ dp_u = 1 + \sum_{v \in u.next} dp_v $$

最后，由于$t_0$本身代表着空串，所以输出$dp_{t_0} - 1$即可。

#### 方法2

我们也可以利用后缀自动机的性质，对所有的状态的$len - link.len$求和即可。

### 计算不同子串的总长度

### 寻找字典序第$k$大子串

### 最小循环移位

### 子串出现次数

### 子串第一次出现的位置

### 子串的所有出现位置

## 例题
