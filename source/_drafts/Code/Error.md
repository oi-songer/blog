---
title: "Error"
tags: 
---

<!-- K Balanced Teams -->

# Codeforces 1133 E

<!--more-->

题目来源：[_Codeforces_](https://codeforces.com/contest/1133/problem/E)

## 分析

### 题意

我们需要将`n`个人分为`k`组，并且对于每组里的人，每个人都有一个`a[i]`，使得任意两人间的`a[i]`的差不超过`5`。

### 错误的思路

> 以下是我比赛时错误的思路，可以直接跳过不看。

首先，我们可以看到，我们可以使用`f[i][j]`来表示所有的状态。其中`i`表示使用前`i`个人，`j`表示将这些人分成`j`个组。很明显，这样完全可以表示所有状态，并且也方便转移。

那么，接下来我们就要考虑转移方程。比赛的时候，当时我认为，转移可以分为三种情况：

1. `f[i][j] = f[i-1][j-1] + 1` : 从第`i`个人开始，我们新开一个组。
2. `f[i][j] = f[i-1][j]` : 不选择第$i$个人。因为我们可能在两个组中间跳过一些人。
3. `f[i][j] = f[i-1][j] + 1` : 将当前的人加入到上一个组中。注意，此时应该满足组内`a[i]`之差小于`5`的条件。

这样，我就得到了一整个转移方程。然而，交上代码后却发现WA在了第25组。我本来以为是特判的问题。结果在反复测试后发现，以下的样例无法得出正确答案：

```
5 1
1 4 7 9 14
```

正确答案为`3`，选择的是`4, 7, 9`。但是实际上，通过我的程序跑出来的是`2`，选择了`1, 4`。也就是说，我的算法并不会"抛弃"一个组中的某些数从而去换取更好的答案。我们的`f[2][1]`记录了一个从`1`开始的组，但是实际上一个从`4`开始的组才能得到最佳答案，尽管从`f[2][1]`上来看它不是最佳的。也就是说，转移方程存在根本的问题。

### 正解

我们之前提到，我们要采用`f[i][j]`来存储状态，`i`表示取到第`i`个人，`j`表示将这些人分为了`j`组。但官方题解中给出的略有不同，其中`i`表示取到了第`i-1`个人，具体原因与转移方程有关。

官方的题解共有以下两个转移方程：

1. `f[i+1][j] = max(f[i+1][j], f[i][j])` : 当我们将不选择第`i`个的时候。
2. `f[i + cnt[i]][j + 1] = max(f[i + cnt[i]][j + 1], f[i][j] + cnt[i])` : 当我们以第$i$个开始选择`cnt[i]`个数作为第`j + 1`组的时候。其中`cnt[i]`表示从第`i`个人开始最多可以选几个符合条件的人，可以通过$O(n^2)$的初始化得出。

这样，我们最后可以输出`f[n+1][k]`，即为最终答案。

### 错解与正解的比较和分析

那么，之前的错解到底错在什么地方呢？

实际上，我的`f[i][j]`和正解中表示的`f[i][j]`表示的状态并不是相同的。我的`f[i][j]`表示的是取到第`i`个人共`j`个组。但是题解中给出的`i`,`j`，除了`i`表示的是第`i-1`个人以外，还有更重要的一点，此时选择的最后一个人（即第`i-1`个人，或者是我的方程中的第`i`个人），他要么是不被某个组选择（由方程1转移而来），或是是某个组的最后一个人（由方程2转移而来）。也就是说，他不可能是某个组的中间的人。

因为，实际上，我的`f[i][j]`是不能保证“最优子状态”的。它会将某些状态抹消掉，从而无法得出正确答案。

因此，错解的直接原因就是对状态的选择存在问题，或者说对“最优子状态”这一概念理解的还不够。

不过，初次之外还有一个很明显的问题。我们对比这两个解法的转移方程可以发现一个明显的不同：一个是枚举状态`y`，然后找到所有能转移的`y`的`x`，这也是最常见的写法；另一种是枚举`x`，然后找到所有能从此转移过去的`y`。此题由于`cnt[i]`的存在，所以明显更适合第二种写法。但是由于我这种写法写的很少，所以也很少向这个方向考虑，这也是限制我思路的一大因素。

## 代码

```C++
/*
Wrong test case:
5 1
1 4 7 9 14

answer should be 3 rather than 2
*/
#include <iostream>
#include <algorithm>

#define MAXN 5010

using namespace std;

int a[MAXN];
int f[MAXN][MAXN];
int cnt[MAXN];

int main()
{
    int n, k;
    cin >> n >> k;

    for (int i = 1; i<=n; i++) 
        cin >> a[i];

    sort(a+1, a+n+1);

    for (int i = 1; i<=n; i++)
        while ( i + cnt[i] <= n && a[i + cnt[i]] - a[i] <= 5)
            cnt[i] ++;

    int ans = 0;
    for (int i = 1; i<=n; i++)
        for (int j = 0; j<=k; j++)
        {
            f[i+1][j] = max(f[i+1][j], f[i][j]);

            if (j<k)
            {
                f[i + cnt[i]][j + 1] = max(f[i + cnt[i]][j + 1], f[i][j] + cnt[i]);
            }
        }

    cout << f[n+1][k] << endl;
}
```