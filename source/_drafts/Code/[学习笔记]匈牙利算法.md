---
title:[学习笔记]匈牙利算法
tags:
---

# [学习笔记]匈牙利算法(最大二分图匹配)

> 尽管欠了一周的博客没有整理，不过我觉得还是先整理一下今天上课的内容吧。。。。这篇博客可能比较长，请善用网页右侧的目录。

<!--more-->

## 算法介绍

### 一些基础概念

**二分图**: 对于图$G$，若其所有顶点可以被分别放置在两个集合$X$和$Y$中，使得对于所有的边满足边所连接的两个顶点分别在这两个集合中，这个图便是二分图。

匈牙利算法解决的是**二分图的最大匹配问题**。若给定一个二分图$G$，$M$边集为$G$的一个子集，且满足$M$中任意两条边不会依附于同一个顶点，则称$M$是图$G$的一个匹配。而包含边数最多的匹配便是二分图的最大匹配。

此外，还有一些其他的基础概念:

1. **未盖点**: 设$M$为图$G$的一个匹配，$V_i$是图$G$的一个顶点，若$V_i$不与边集$M$中任意一条边相关联，则称$V_i$为未盖点;
2. **交错路**: 设$P$为图$G$的一条路，若$P$中任意两条相邻的边一条属于$M$，一条不属于$M$，则称$P$为交错路;
3. **可增广路**: 两个端点都为未盖点的成为可增广路。

### 算法原理

我们还是以较为常用的男女配对问题为例。假设我们有三个男生，三个女生，在他们中间存在着几对暧昧关系(不考虑奇怪的取向(/▽＼))。我们假设有暧昧关系的都可以成为情侣，那么问最多能凑成几对情侣呢？

我们先假设暧昧关系是如下图所示的:

![图1](http://ovi2jbxue.bkt.clouddn.com/Inblog%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95-1.png)

那么我们便开始配对的过程:

1. 我们首先来看男生1，他同时喜欢女生1，2，3.在这里，我们先假设他选择女生1，然后我们连接男生1与女生1的边。

![图2](http://ovi2jbxue.bkt.clouddn.com/Inblog%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95-2.png)

2. 然后，我们再来看男生2，他同时喜欢女生1和女生2。我们首先去看女生1，发现她已经和男生1配对了，但是男生1还有其他的选项，所以我们会让男生1换到下一个选择女生2，男生2选择女生1。

![图3](http://ovi2jbxue.bkt.clouddn.com/Inblog%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95-3.png)

3. 最后，我们来看男生3，他也同时喜欢女生1和女生2。我们先看女生1，她已经和男生2配对了，我们便来看看男生2是否能改动，然后发现可以配对的女生2已经和男生1配对了。这时我们再看男生1，发现其可以选择女生3，所以男生1会和女生3配对，男生2和女生2配对，男生3和女生1配对。

![图4](http://ovi2jbxue.bkt.clouddn.com/Inblog%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95-4.png)

那么，从图中可以看出，这个过程其实是一个寻找增广路的过程。某个男生还可以和某个没有配对过的女生配对，说明这条交错路的一段为未盖点，而因为另一端的男生一定还没有选择女生，也是未盖点，所以此时就存在一条可增广路，然后更改染色的边即可。

## 实现细节

虽说看上去比较复杂，但是实际上匈牙利算法的代码实现很是简单，其主要分为两部分:

在主函数中，我们枚举每个点，然后尝试配对，调用`find()`函数，返回是否配对成功。`cnt`则用来记录配对成功的数量，即最大匹配时边的数量。

```C++
for (int i = 0; i<n; i++)
{
	memset(flag,false,sizeof(flag));
    if (find(i))
    	cnt ++;
}
```

而在`find()`函数中，我们枚举所有和当前点相连的点，检查其是否走过，然后检查其是否可选。检查其是否可选时分为两种情况: 一种是其未被选择过，另一种是本来配对的点可以选择其他的点，这是我们需要递归调用函数。其中`belong[]`数组记录与之配对的点,我们初始为`-1`。

```C++
bool find(int x)
{
	for (int i = 0; i<edge[x].size(); i++)
    	if ( !flag[ edge[x][i] ] )
        {
        	int v = edge[x][i];
        	flag[v] = true;
            if (belong[v]==-1 || find(belong[v])
            {
            	belong[v] = x;
                return true;
            }
        }
    return false;
}
```

## 例题

### POJ 1274

题目来源: [_POJ_](http://poj.org/problem?id=1274
)

这道题算是非常裸的一道题目了，甚至可以直接用临界表:

```C++
#include <iostream>
#include <cstring>

using namespace std;

bool mp[210][210];
bool flag[410];
int belong[210];
int n,m;

bool find(int x)
{
    for (int i = 1; i<=m; i++)
        if (mp[x][i]==true && !flag[i])
        {
            flag[i] = true;
            if (!belong[i] || find(belong[i]))
            {
                belong[i] = x;
                return true;
            }
        }
    return false;
}

int main()
{
    while (cin >> n >> m)
    {
        memset(mp,false,sizeof(mp));
        memset(belong,0,sizeof(belong));

        for (int i = 1; i<=n; i++)
        {
            int x;
            cin >> x;
            for (int j = 1; j<=x; j++)
            {
                int y;
                cin >> y;
                mp[i][y] = true;
            }
        }

        int cnt = 0;
        for (int i = 1; i<=n; i++)
        {
            memset(flag,false,sizeof(flag));   
            if (find(i))
                cnt ++;
        }

        cout << cnt << endl;
    }
}
```

### hdu 3729

题目来源: [_hdu_](http://acm.hdu.edu.cn/showproblem.php?pid=3729)

题目也很简单，就是一个点对应的不再是一堆点，而是一段区间，这时我们直接记下给区间的左端点和右端点即可:

```C++
#include <iostream>
#include <cstring>

using namespace std;

bool flag[100100];
int l[100],r[100];
int belong[100100];
int ans[100];

bool find(int x)
{
    for (int i = l[x]; i<=r[x]; i++)
        if (!flag[i])
        {
            flag[i] = true;
            if (belong[i]==0 || find(belong[i]))
            {
                belong[i] = x;
                return true;
            }
        }
    return false;
}

int main()
{
    int T;
    cin >> T;
    while (T--)
    {
        memset(belong,0,sizeof(belong));

        int n;
        cin >> n;
        for (int i = 1; i<=n; i++)
            cin >> l[i] >> r[i];

        int cnt = 0;
        for (int i = n; i>0; i--)
        {
            memset(flag,false,sizeof(flag));
            if (find(i))
                ans[++cnt] = i;
        }

        cout << cnt << endl;
        for (int i = cnt; i>1; i--)
            cout << ans[i] << " ";
        cout << ans[1] << endl;
    }
}
```

## 引申用法

二分图匹配本身是一个比较固定的问题，但是能够将问题转化为二分图匹配的或者说甚至是等价的问题其实很多，下面会列举几种。

### 最小点覆盖

**最小点覆盖**要求用尽可能少的点来使得图中的每条边都与某个选择的点相关联。点的数量其实即为最大匹配数，以下是证明:

充分性: 假设二分图的最大匹配边集为$M$,我们选择其中每条边的某个定点，并且没有顶点相邻。此时一定是最小点覆盖。因为假设不是，即存在某个边未被覆盖，那么便存在了一条可增广路，与前提条件不符。

必要性: 仍然考虑二分图的最大匹配，我们只考虑最大匹配组成的交错路，明显我们需要至少$|M|$个点来覆盖所有的边，所以最小为$|M|$。

### 最小边覆盖

**最小边覆盖**，与上面类似，存在边集$E$使得图$G$中所有顶点都连在边集$E$中的某条边上，并且边集最小。

假设我们想要选边，为了边数尽可能小，我们肯定会优先选择能够对应两个点的边，即从一个交错路中取边。而最长的交错路便为最大匹配的边集所在的交错路，所以我们可以首先选择最大匹配的边集$M$中的所有边。此时，我们选了$|M|$个边，还剩下$ n - 2\times |M| $个点，而剩下的点都需要一个个的用边去掉，所以最后为$ |M| + n - 2 \times |M| = n - 2 \times |M| $。即最小边覆盖=点的总数-最大匹配。

### DAG图的最小路径覆盖

用尽量少的不相交简单路径覆盖有向无环(DAG)G的所有顶点，这就是DAG图的**最小路径覆盖**问题。

解决这个问题需要对图做一个转化。我们令所有的点都分为两部分，分别放在集合$X$和$Y$中，然后令所有的边都从集合$X$指向集合$Y$,之后再求最大二分图匹配。而我们要求的最小路径覆盖则为节点总数减去最大匹配数。证明如下:

我们首先假设倘若没有连边，我们边需要从所有的点开始，所以路径数等于点数$n$。而我们每多一条边，我们便可以少走一条路径，而使用最大二分图匹配的方法既保证了我们每个点出度和入度都最大为1，又能算出最多有多少可行的连边，所以最后的答案为$ n - |M| $。

### 二分图的最大独立集

**最大独立集**问题是指在$n$个点的图$G$中选出$m$个点，使这$m$个点两两之间没有边, 然后令$m$最大。

这个问题的数学证明也是较为显然的。我们需要去掉某些点，使得剩下的节点互不连接。而很明显，在最大二分图匹配中，所有的没有连接在$M$边集中的点都互不连接，而我们可以在与$M$边集相连的$2 \times |M|$个点中去掉$|M|$个，使得剩下$|M|$个互不连接，所以最后的答案也是$n-|M|$。
